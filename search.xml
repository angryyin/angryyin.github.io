<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链表反转]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%A1%A8%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627&lt;?php/*class ListNode&#123; var $val; var $next = NULL; function __construct($x)&#123; $this-&gt;val = $x; &#125;&#125;*/function ReverseList($pHead)&#123; // write code here if($pHead==NULL||$pHead-&gt;next==NULL)&#123; return $pHead; &#125; //将原链表的元素一个个插入到新链表的头部 $pPre = NULL; $pCur = $pHead; while ($pCur-&gt;next != NULL) &#123; $pNext = $pCur-&gt;next; $pCur-&gt;next = $pPre; $pPre = $pCur; $pCur = $pNext; &#125; $pCur-&gt;next = $pPre; return $pCur;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[树的层次遍历]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1、把根节点A放入队列，此时队列为：A，队列头指针指向A，也就是队列第一个元素2、把当前队列头指针所指元素的左右儿子放入队列，即将B C放入队列，此时队列为A B C ，队列头指针向下移一格，此时指向B3、不断重复2步骤。此时把B的左右儿子取出来放入队尾，队列变为A B C D E，队列头指针后移，指向c，c没有子节点，队列不再延长；4、结束条件，队列头指针和为指针重合时，输出最后一个元素，算法结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125;&#125;function reConstructBinaryTree($pre, $vin)&#123; // write code here if($pre &amp;&amp; $vin)&#123; $treeRoot = new TreeNode($pre[0]); $index = array_search($pre[0],$vin); $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125;&#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$re = reConstructBinaryTree($pre, $vin);PrintFromTopToBottom($re);function PrintFromTopToBottom($re)&#123; $quene=array(); $res=array(); if($re==null) return $res; array_push($quene,$re); while(!empty($quene))&#123; // quene出队，队头值赋值给tmp，最后打印tmp的val //这里使队列出队是为了将quene的指针右移，使tmp成为quene右移指针之后的树，如ABC，下一步要将B的孩子DE入队，那么就需要使tmp指向B $tmp=array_shift($quene); //左右节点依次入队 if($tmp-&gt;left!=null)&#123; array_push($quene,$tmp-&gt;left); &#125; if($tmp-&gt;right!=null)&#123; array_push($quene,$tmp-&gt;right); &#125; //将tmp的val入队 array_push($res,$tmp-&gt;val); &#125; print_r($res) ;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[树的遍历与对比]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%81%8D%E5%8E%86%E4%B8%8E%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpclass TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125;&#125;function reConstructBinaryTree($pre, $vin)&#123; // write code here if($pre &amp;&amp; $vin)&#123; $treeRoot = new TreeNode($pre[0]); $index = array_search($pre[0],$vin); $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125;&#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$pre1 = [1,2,4,7];$vin1 = [4,7,2,1];$pRoot1 = reConstructBinaryTree($pre, $vin);$pRoot2 = reConstructBinaryTree($pre1,$vin1);echo HasSubtree($pRoot1, $pRoot2);function HasSubtree($pRoot1, $pRoot2)&#123; $re = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if($pRoot1!=NULL&amp;&amp;$pRoot2!=NULL)&#123; //如果找到了对应Tree2的根节点的点 if($pRoot1-&gt;val==$pRoot2-&gt;val)&#123; //以这个根节点为为起点判断是否包含Tree2 $re = judge($pRoot1,$pRoot2); &#125; if(!$re)&#123; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 $re = HasSubtree($pRoot1-&gt;left,$pRoot2); &#125; if(!$re)&#123; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 $re = HasSubtree($pRoot1-&gt;right,$pRoot2); &#125; &#125; if($re == false)&#123; return 0; &#125;else&#123; return 1; &#125; return $re;&#125;function judge($pRoot1, $pRoot2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if($pRoot2 == NULL)&#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if($pRoot1 == NULL)&#123; return false; &#125; //如果其中有一个点没有对应上，返回false if($pRoot1-&gt;val != $pRoot2-&gt;val)&#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return judge($pRoot1-&gt;left,$pRoot2-&gt;left)&amp;&amp;judge($pRoot1-&gt;right,$pRoot2-&gt;right);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[位运算加法]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%AE%97%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213&lt;?phpfunction Add($num1, $num2)&#123; // write code here while($num2)&#123; //相加之后的进位 $tmp = $num1 ^ $num2; //相加之后没有进位 $num2 = ($num1 &amp; $num2) &lt;&lt; 1; $num1 = $tmp; &#125; return $num1;&#125; 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[五种常见的 PHP 设计模式]]></title>
    <url>%2F2019%2F04%2F01%2Fp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。策略模式的三个角色：1．抽象策略角色2．具体策略角色3．环境角色（对抽象策略角色的引用）实现步骤：1．定义抽象角色类（定义好各个实现的共同抽象方法）2．定义具体策略类（具体实现父类的共同方法）3．定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）就在编程领域之外，有许多例子是关于策略模式的。例如：如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。策略模式的代码实例：123456789101112131415161718192021222324&lt;?php abstract class baseAgent &#123; //抽象策略类 abstract function PrintPage(); &#125; //用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return 'IE'; &#125; &#125; //用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return 'not IE'; &#125; &#125; class Browser &#123; //具体策略角色 public function call($object) &#123; return $object-&gt;PrintPage (); &#125; &#125; $bro = new Browser (); echo $bro-&gt;call ( new ieAgent () );?&gt; 工厂模式 工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpheader('Content-Type:text/html;charset=utf-8');/** *简单工厂模式（静态工厂方法模式） *//** * Interface people 人类 */interface people&#123; public function say();&#125;/** * Class man 继承people的男人类 */class man implements people&#123; // 具体实现people的say方法 public function say() &#123; echo '我是男人&lt;br&gt;'; &#125;&#125;/** * Class women 继承people的女人类 */class women implements people&#123; // 具体实现people的say方法 public function say() &#123; echo '我是女人&lt;br&gt;'; &#125;&#125;/** * Class SimpleFactoty 工厂类 */class SimpleFactoty&#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125;&#125;/** * 具体调用 */$man = SimpleFactoty::createMan();$man-&gt;say();$woman = SimpleFactoty::createWomen();$woman-&gt;say(); 单例模式 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。单例模式有以下3个特点：1．只能有一个实例。2．必须自行创建这个实例。3．必须给其他对象提供这一实例。那么为什么要使用PHP单例模式？PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。123456789101112131415161718class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123;//声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123;//声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) self::$instance = new self(); return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname('hello world');$ob-&gt;setname('good morning');echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。12345678910111213141516&lt;?phpclass Register&#123; protected static $objects; function set($alias,$object)//将对象注册到全局的树上 &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name)&#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象。 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 接口 IDatabase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace IMooc;interface IDatabase&#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125;MySQL&lt;?phpnamespace IMooc\Database;use IMooc\IDatabase;class MySQL implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname, $conn); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125;&#125;MySQLi&lt;?phpnamespace IMooc\Database;use IMooc\IDatabase;class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125; 观察者模式1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。3：观察者模式实现了低耦合，非侵入式的通知与更新机制。定义一个事件触发抽象类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748EventGenerator.php&lt;?phprequire_once 'Loader.php';abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125;定义一个观察者接口Observer.php&lt;?phprequire_once 'Loader.php';interface Observer&#123; function update();//这里就是在事件发生后要执行的逻辑&#125;//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件实现require 'Loader.php';class Event extends EventGenerator&#123; function triger()&#123; echo "Event&lt;br&gt;"; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo "逻辑1&lt;br&gt;"; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo "逻辑2&lt;br&gt;"; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
  </entry>
  <entry>
    <title><![CDATA[php运行模式]]></title>
    <url>%2F2019%2F04%2F01%2Fhp%2F</url>
    <content type="text"><![CDATA[一、CGI：fork-and-excute CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。 CGI有很多缺点，每接收一个请求就要fork一个进程处理，只能接收一个请求作出一个响应。请求结束后该进程就会结束。 而FastCGI会事先启动起来，作为一个cgi的管理服务器存在，预先启动一系列的子进程来等待处理，然后等待web服务器发过来的请求，一旦接受到请求就交由子进程处理，这样由于不需要在接受到请求后启动cgi。FastCGI使用进程/线程池来处理一连串的请求。这些进程/线程由FastCGI服务器管理，而不是Web服务器。当进来一个请求时，Web服务器把环境变量和这个页面请求通过一个Socket长连接传递给FastCGI进程。在请求到达时不会花费时间去fork一个进程来处理。 二、FastCGI（协议）： FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 分叉-执行模式）。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。 FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 FastCGI特点FastCGI具有语言无关性. FastCGI在进程中的应用程序，独立于核心web服务器运行，提供了一个比API更安全的环境。APIs把应用程序的代码与核心的web服务器链接在一起，这意味着在一个错误的API的应用程序可能会损坏其他应用程序或核心服务器。 恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥。 FastCGI技术目前支持语言有：C/C++、Java、Perl、Tcl、Python、SmallTalk、Ruby等。相关模块在Apache, ISS, Lighttpd等流行的服务器上也是可用的。FastCGI的不依赖于任何Web服务器的内部架构，因此即使服务器技术的变化, FastCGI依然稳定不变。 FastCGI的工作原理 1、Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。 2、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 3、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。 在上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 FastCGI的不足 因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。PHP-CGIPHP-CGI是PHP自带的FastCGI管理器。PHP-CGI的不足：php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。） PHP-FPM（实现FASTCGI的程序）PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的，可以在 http://php-fpm.org/download下载得到。PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。现在我们可以在最新的PHP 5.3.2的源码树里下载得到直接整合了PHP-FPM的分支，据说下个版本会融合进PHP的主分支去。相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，所以被PHP官方收录了。PHP-FPM的使用非常方便，配置都是在PHP-FPM.ini的文件内，而启动、重启都可以从php/sbin/PHP-FPM中进行。更方便的是修改php.ini后可以直接使用PHP-FPM reload进行加载，无需杀掉进程就可以完成php.ini的修改加载结果显示使用PHP-FPM可以使php有不小的性能提升。PHP-FPM控制的进程cpu回收的速度比较慢,内存分配的很均匀。而PHP-FPM合理的分配，导致总体响应的提到以及任务的平均。 三、 LoadModule（Apache独有）：在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:/…/php71/php7apache2_4.dll”起到的作用就是这个 四、ISAPI（IIS独有）： 五、CLI：命令行模式CLI:就是命令行，例如可以在控制台或者是shell中键入命令 php -f index.php 总结：FastCGI 和 LoadModule 模式其实就是 CGI 模式的升级版，主要为了克服 CGI fork-and-execute 的弊端而产生的]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql千行笔记]]></title>
    <url>%2F2019%2F03%2F30%2Fysql%E5%8D%83%E8%A1%8C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Windows服务 -- 启动MySQL net start mysql -- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格) 连接与断开服务器 mysql -h 地址 -P 端口 -u 用户名 -p 密码 SHOW PROCESSLIST -- 显示哪些线程正在运行 SHOW VARIABLES -- 显示系统变量信息 数据库操作 -- 查看当前数据库 SELECT DATABASE(); -- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version(); -- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name -- 查看已有库 SHOW DATABASES[ LIKE &apos;PATTERN&apos;] -- 查看当前库信息 SHOW CREATE DATABASE 数据库名 -- 修改库的选项信息 ALTER DATABASE 库名 选项信息 -- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作 -- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;] -- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &apos;目录&apos; -- 索引文件目录 INDEX DIRECTORY = &apos;目录&apos; -- 表注释 COMMENT = &apos;string&apos; -- 分区选项 PARTITION BY ... (详细见手册) -- 查看所有表 SHOW TABLES[ LIKE &apos;pattern&apos;] SHOW TABLES FROM 表名 -- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;] SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;] -- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键 -- 删除表 DROP TABLE[ IF EXISTS] 表名 ... -- 清空表数据 TRUNCATE [TABLE] 表名 -- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名 -- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名 -- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... -- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... -- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM] -- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作 -- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...] -- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部 -- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码 -- MySQL、数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 SHOW VARIABLES LIKE &apos;character_set_%&apos; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码 SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk; SET NAMES GBK; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;] 查看所有字符集 SHOW COLLATION [LIKE &apos;pattern&apos;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型（列类型） 1. 数值类型 -- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&apos;123&apos;，补填后为&apos;00123&apos; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 2. 字符串类型 -- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime YYYY-MM-DD hh:mm:ss timestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmss date YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDD time hh:mm:ss hhmmss hhmmss year YYYY YY YYYY YY 4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) ); insert into tab values (&apos;男, 女&apos;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 选择类型 -- PHP角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- IP存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&apos;192.168.3.134&apos;)); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON(&apos;127.0.0.1&apos;) 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP 列属性（列约束） 1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &apos;val&apos;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &apos;val&apos;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. COMMENT 注释 例：create table tab ( id int ) comment &apos;注释内容&apos;; 7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范 -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3; c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;,&gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。 g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询 - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join) 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; 导出 select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &apos; &apos; enclosed by &apos;&apos; escaped by &apos;\&apos; terminated by &apos;string&apos; -- 终止 enclosed by &apos;char&apos; -- 包裹 escaped by &apos;char&apos; -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos; &apos; FROM test_table; lines 控制行格式 默认：lines terminated by &apos; &apos; terminated by &apos;string&apos; -- 终止 INSERT select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …; DELETE DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 TRUNCATE TRUNCATE [TABLE] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 备份与还原 备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database DB1 [DB2 DB3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql) 可以-w携带WHERE条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图 什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务(transaction) 事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。 -- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 -- 事务提交 COMMIT; -- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 -- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表 表锁定只用于防止其它客户端进行不正当地读取和写入 MyISAM 支持表锁，InnoDB 支持行锁 -- 锁定 LOCK TABLES tbl_name [AS alias] -- 解锁 UNLOCK TABLES 触发器 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROWtrigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构 -- 删除 DROP TRIGGER [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 SQL语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程 --// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取日期部分 time(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取时间部分 date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 DROP FUNCTION [IF EXISTS] function_name; -- 查看 SHOW FUNCTION STATUS LIKE &apos;partten&apos; SHOW CREATE FUNCTION function_name; -- 修改 ALTER FUNCTION function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 CREATE PROCEDURE sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 IN，表示输入型 OUT，表示输出型 INOUT，表示混合型 注意，没有返回值。 /* 存储过程 */ ------------------ 存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：CALL 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 IN|OUT|INOUT 参数名 数据类型 IN 输入：在调用过程中，将数据输入到过程体内部的参数 OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端 INOUT 输入输出：既可输入，也可输出 -- 语法 CREATE PROCEDURE 过程名 (参数列表) BEGIN 过程体 END 用户和权限管理 -- root密码重置 1. 停止MySQL服务 2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables 3. use mysql; 4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;; 5. FLUSH PRIVILEGES; 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES; -- 增加用户 CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD(&apos;密码&apos;) -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码 -- 删除用户 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;; -- 查看权限 SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 表维护 -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 &apos; 5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;G&quot;, &quot;g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 7. 清除已有语句：c]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php实现0-1背包问题]]></title>
    <url>%2F2019%2F03%2F29%2F1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526&lt;? phpfunction back()&#123; $a['w'] = [0, 2, 3, 4, 5, 9]; $a['v'] = [0, 3, 4, 5, 8, 10]; $b =array(); $n = 6; $w = 21; for($i=0;$i &lt; $n;$i++)&#123; for($j=0;$j &lt; $w;$j++)&#123; $b[$i][$j] = 0; &#125; &#125; for($k = 1; $k &lt; $n ;$k++)&#123; for($c = 1; $c &lt; $w ;$c++)&#123; if($a['w'][$k] &gt; $c)&#123; $b[$k][$c] = $b[$k-1][$c]; &#125;else&#123; $value1 = $b[$k-1][$c-$a['w'][$k]] + $a['v'][$k]; // 拿第k件物品 $value2 = $b[$k-1][$c]; // 不拿第k件物品 $b[$k][$c] = max($value1,$value2); &#125; &#125; &#125; print_r($b);&#125;back(); JAVA实现 1234567891011121314151617181920 class Main &#123; public static void main(String[] args) &#123; int[] w = &#123; 0, 2, 3, 4, 5, 9 &#125;; int[] v = &#123; 0, 3, 4, 5, 8, 10 &#125;; int N = 6, W = 21; int[][] b = new int[N][W]; for (int k = 1; k &lt; N; k++) &#123; for (int c = 1; c &lt; W; c++) &#123; if (w[k] &gt; c) &#123; b[k][c] = b[k - 1][c]; &#125; else &#123; int value1 = b[k - 1][c - w[k]] + v[k]; // 拿第k件物品 int value2 = b[k - 1][c]; // 不拿第k件物品 b[k][c] = Math.max(value1, value2); &#125; &#125; &#125; System.out.println(b[5][20]); &#125;&#125;]]></content>
      <categories>
        <category>高级算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解PHP闭包的使用以及实现]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3PHP%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/chenpingzhao/p/4553139.html https://www.cnblogs.com/XGHeaven/p/4245306.html 匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与贪心算法的区别与联系]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划的路径规划：https://blog.csdn.net/xgf415/article/details/52662389 0-1背包问题： https://www.jianshu.com/p/b86148c10142动态规划和贪心算法都是一种递推算法均有局部最优解来推导全局最优解背包问题可以由贪心算法求解，但是0-1背包问题不能而需要采取动态规划。 不同点： 贪心算法：1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。2.由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。 贪心法的基本思路：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。实现该算法的过程：从问题的某一初始解出发； while 能朝给定总目标前进一步 do求出可行解的一个解元素；由所有解元素组合成问题的一个可行解 贪心算法最经典的例子，给钱问题。比如中国的货币，只看元，有1元2元5元10元20、50、100 如果我要16元，可以拿16个1元，8个2元，但是怎么最少呢？如果用贪心算，就是我每一次拿那张可能拿的最大的。比如16，我第一次拿20拿不起，拿10元，OK，剩下6元，再拿个5元，剩下1元也就是3张 10、5、1。 每次拿能拿的最大的，就是贪心。 但是一定注意，贪心得到的并不是最优解，也就是说用贪心不一定是拿的最少的张数贪心只能得到一个比较好的解，而且贪心算法很好想得到。再注意，为什么我们的钱可以用贪心呢？因为我们国家的钱的大小设计，正好可以使得贪心算法算出来的是最优解（一般是个国家的钱币都应该这么设计）。如果设计成别的样子情况就不同了比如某国的钱币分为 1元3元4元如果要拿6元钱 怎么拿？贪心的话 先拿4 再拿两个1 一共3张钱实际最优呢？ 两张3元就够了 贪心算法两个最重要的性质：（1）贪心选择性质；（2）最优子结构性质； 其中，贪心选择性质：自顶向下进行决策，每次做出的决策都是局部最优解，且每次做出决策后问题规模都变小了；最优子结构性质：即问题的最优解结构中包含子问题的最优解； 动态规划算法的两个最重要的性质：（1）重叠子问题性质；（2）最优子结构性质； 其中最优解子结构性质和贪心算法相似，唯一不同的是重叠子问题性质，因为动态规划算法是自底向上的算法，它需要首先将原始问题分解为若干个相互有联系的子问题，在计算的时候有的子问题可能会被计算很多次，所以动态规划算法会将这些子问题的解存在一个表格中，使得最终对于这些子问题只需要求解一次（可以使原来需要再指数时间内解决的问题可以在多项式问题中得到解决）]]></content>
      <categories>
        <category>高级算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[music]]></title>
    <url>%2F2019%2F03%2F29%2Fnew%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前序与中序还原树]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425&lt;?php class TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125; &#125; function reConstructBinaryTree($pre, $vin) &#123; // write code here if($pre &amp;&amp; $vin)&#123; //前序遍历的第一个节点一定是根节点 $treeRoot = new TreeNode($pre[0]); //index判断根节点在中序中是否存在,并返回根节点在vin中的键名 $index = array_search($pre[0],$vin); $treeRoot-&gt;left=reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125; &#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$re = reConstructBinaryTree($pre, $vin);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序遍历与中序遍历与后续遍历的php实现]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php class Node&#123; public $value; public $left; public $right; &#125; //先序遍历 根节点 ---&gt; 左子树 ---&gt; 右子树 function preorder($root)&#123; $stack=array(); array_push($stack,$root); while(!empty($stack))&#123; $center_node=array_pop($stack); echo $center_node-&gt;value.' ';//先输出根节点 if($center_node-&gt;right!=null)&#123; array_push($stack,$center_node-&gt;right);//压入左子树 &#125; if($center_node-&gt;left!=null)&#123; array_push($stack,$center_node-&gt;left); &#125; &#125; &#125; //中序遍历，左子树---&gt; 根节点 ---&gt; 右子树 function inorder($root)&#123; $stack = array(); $center_node = $root; while (!empty($stack) || $center_node != null) &#123; while ($center_node != null) &#123; array_push($stack, $center_node); $center_node = $center_node-&gt;left; &#125; $center_node = array_pop($stack); echo $center_node-&gt;value . " "; $center_node = $center_node-&gt;right; &#125; &#125; //后序遍历，左子树 ---&gt; 右子树 ---&gt; 根节点 function tailorder($root)&#123; $stack=array(); $outstack=array(); array_push($stack,$root); while(!empty($stack))&#123; $center_node=array_pop($stack); array_push($outstack,$center_node);//最先压入根节点，最后输出 if($center_node-&gt;left!=null)&#123; array_push($stack,$center_node-&gt;left); &#125; if($center_node-&gt;right!=null)&#123; array_push($stack,$center_node-&gt;right); &#125; &#125; while(!empty($outstack))&#123; $center_node=array_pop($outstack); echo $center_node-&gt;value.' '; &#125; &#125; $a=new Node(); $b=new Node(); $c=new Node(); $d=new Node(); $e=new Node(); $f=new Node(); $a-&gt;value='A'; $b-&gt;value='B'; $c-&gt;value='C'; $d-&gt;value='D'; $e-&gt;value='E'; $f-&gt;value='F'; $a-&gt;left=$b; $a-&gt;right=$c; $b-&gt;left=$d; $c-&gt;left=$e; $c-&gt;right=$f; preorder($a);//A B D C E F echo '&lt;hr/&gt;'; inorder($a);//D B A E C F echo '&lt;hr/&gt;'; tailorder($a);//D B E F C A]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php十进制二进制算法题]]></title>
    <url>%2F2019%2F03%2F28%2Fhp%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[负数需要先置反为反码，然后再加1，并且循环需要32位 floor()舍去法取整 ceil – 进一法取整 round – 对浮点数进行四舍五入 %取余数 array_count_values()表示$v出现次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction NumberOf1($n)&#123; $arr = array(); if ($n &gt; 0)&#123; while($n != 0) &#123; $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); &#125; $judge = array_count_values($arr); if(isset($judge[1]))&#123; return $judge[1]; &#125;else&#123; return 0; &#125; &#125;else&#123; $n = -1 * $n; while($n &gt; 0)&#123; $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); &#125; for($i=0;$i &lt; 32;$i++)&#123; if($arr[$i] == 1)&#123; $arr[$i] = 0; &#125;elseif($arr[$i] == 0) &#123; $arr[$i] = 1; &#125;else&#123; $arr[$i] = 1; &#125; &#125; $length = count($arr); for($i = 0;$i &lt; $length;$i++)&#123; if($arr[$i]==0)&#123; $arr[$i] = 1; break; &#125;else&#123; $arr[$i] = 0; &#125; &#125; $judge = array_count_values($arr); if(isset($judge[1]))&#123; return $judge[1]; &#125;else&#123; return 0; &#125; &#125;&#125;?&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里一面凉经]]></title>
    <url>%2F2019%2F03%2F27%2F%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 Incorrect Password! No content to display! U2FsdGVkX185yT74y21ysyvEPDe7LSdi4zDWrTsRsj0oFJ+Tp4tZ5ovL5fi5OkC62zeQahRfU0qKZhi07Vdz5rgm3Gu2cXEBqv4m2e17HsVzaDbaL5rHzUb7+140/kFBxHMd190jVU2yWXK3czdH5heZrnU3OzVSY6gTkg8Q1JDzqexlu5pdh28DDxy/19EWTiEwv7aVbJsL0mTwhrGa5ViCx7DxqONiUUu2huC5OAi705mHLbKCZCKD4m8ZH3AY2W+o/xk84lgPKMfjhrk3RVEw/BWI2Z+rirAvGC9tB7R+HQMllWSst3uQcmu9HWJJfL+445/zEP5aD5yY686sKsFBnH+o0QpRakptL8ES2msI98PqxOr6wu8QkRztbhykkHBoh7cdRWo3hL8clXx8joR3JMHgWzonDiX7MC0lIYgNLXSwsyNufKYtn51IlIj8wNCiZhGu6iL6coaWPnmzv3xRIbQaU61XGHRQxtS15iysgy49wjw/tEZPsmMFmjrZUfjoRnqWeHKBtUkNn0J42K7nYW0NKwI1JdLdnL5QIKVa5xsjtSIUcbInaBnvbDUDqA0OpRd++MTxVIJpG0b0Wl6f//u0DYbIRA3/4mjApIiddI+WOWNwlNj7mtIjZvW+APZr8GtInuaFL4wYO1uHy05PJJE2WUm2CUyXu2MeXbD+sg9gGtIUJQWJsCyFtKH4R8IAxB6VQiPvQ9jq6RIg6he14u+nOnCL0wEFWunMwLrmc8EH8aCazChcbPcA49Jpba5tY7YZWXgwbXddYE4zREW6K2bFlABJdIZiSoFNt4SFjxkt07F0wfSCD13ueVyM1W+b4TDX6XpxB1fvoJGPAupRJXt4wccq39KlqjvmW3t98GH3q8ETX+vg42rGceGRg+XiBQU8tUP50pyFGVEd/IVhMBlPlmnBIMcHVM6Z+kVPtox3ACl1hoHsqu6tg+EObyYpWELHKKFUZrgbjcU0P/xUwfQaJ5f3twNEtLlnUm98TwbMLfuYCaABcviBryMwBx7QTbJpTwwxjInU0E9ZOTQ62a+ehgV9DakkkOia6/2dsOoBqSRwnzrzaw2IE2Jbe1+oo6ZLKSk9V0rzKDur2inR1HOzOGDxQggKE5TZw+LFI2cUeD7rIPC7UbPobk/APFJeHFiAlHxD2vGt/GQn7tVenPy93cqeSaG/jEczxbicZpeC83Lb/reC3TdXBOSZ3KpIFBo0/qoV2UkZ02WujLHntPkMQ4inSCExwX0WRzQFYuUwcmDYjvd6AXgZF84p]]></content>
  </entry>
  <entry>
    <title><![CDATA[php多线程]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展，而要安装 pthread 扩展，必须使用 –enable-maintainer-zts 参数重新编译 PHP，这个参数是指定编译 PHP 时使用线程安全方式。 什么是线程安全?如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找总结]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析： 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ; 当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。 二分查找 说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)； 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》 123456789101112131415161718/二分查找（折半查找），版本1int BinarySearch1(int a[], int value, int n) &#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1; &#125; 1234567891011//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high) &#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high); &#125; 插值查找 在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？ 打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。 同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。 经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下： mid=(low+high)/2, 即mid=low+1/2(high-low); 通过类比，我们可以将查找的点改进为如下： mid=low+(key-a[low])/(a[high]-a[low])(high-low)， 也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。 C++实现源码：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[http协议的状态码 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误）Internal Server Error服务器遇到错误，无法完成请求。 501（尚未实施）Not Implemented服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）Bad Gateway服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）Service Unavailable服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时）Gateway Timeout服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）HTTP Version Not Supported服务器不支持请求中所用的 HTTP 协议版本。1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续）continue请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议）switch protocols请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx（成功）表示成功处理了请求的状态码。 200（成功）OK服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。201（已创建）Created请求成功并且服务器创建了新的资源。 202（已接受）Accepted服务器已接受请求，但尚未处理。 203（非授权信息）Non-Authoriative Information服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）No Content服务器成功处理了请求，但没有返回任何内容。 205（重置内容）Reset Content服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）Partial Content服务器成功处理了部分 GET 请求。 3xx（重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google建议您在每次请求中使用重定向不要超过5次。您可以使用网站管理员工具查看一下 Googlebot在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 300（多种选择）Multiple Choices针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）Moved Permanently请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置）see other请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）Not Modified自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。. 305（使用代理）Use Proxy请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）Temporary Redirect服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）Bad Request服务器不理解请求的语法。 401（未授权）Unauthorized请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）Forbidden服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）File Not Found服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用）Method Not Allowed禁用请求中指定的方法。 406（不接受）Not Acceptable无法使用请求的内容特性响应请求的网页。 407（需要代理授权）Proxy Authentication Required此状态码与 401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）Request Time-out服务器等候请求时发生超时。 409（冲突）conflict服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）Gone如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）Length Required服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）Precondition Failed服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）Request Entity Too Large服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）Request-URL Too Large请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）Unsupported Media Type请求的格式不受请求页面的支持。 416（请求范围不符合要求）Requested range not statifiable如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值）Expectation Failed服务器未满足”期望”请求标头字段的要求。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET与POST区别]]></title>
    <url>%2F2019%2F03%2F27%2FET%E4%B8%8EPOST%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[get post本质：HTTP协议里两种发送请求的方法get向服务器请求资源post 向服务器发送请求 通常情况参数的传送渠道的不同get放在url里面 post放在body里面get请求url有限制（字符串） post没有限制但是http其实没明确规定什么get/post方法要用什么样的方式传输数据 get产生一个TCP数据包 而post产生两个：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。因为POST需要两步，时间上消耗的要多一点，但是在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F03%2F26%2Ftitled%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021&lt;?php //送给心爱的她5201314 $arr = array('5','2','0','1','3','1','4'); function BubbleSort(array $arr) &#123; for ($i=0 ; $i &lt;count($arr) ; $i++) &#123; //设置一个空变量 $data = ''; for ($j=$i ; $j &lt; count($arr)-1 ; $j++) &#123; if ($arr[$i] &gt; $arr[$j+1]) &#123; $data = $arr[$i]; $arr[$i] = $arr[$j+1]; $arr[$j+1] = $data; &#125; &#125; &#125; return $arr; &#125; echo "&lt;pre&gt;"; print_r(BubbleSort($arr));]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223&lt;?php $arr = [2, 3, 1, 6, 4, 7, 5, 9]; var_dump(insertsort($arr)); function insertSort($arr) &#123; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; // 当前值 $key = $arr[$i]; // 当前位置 $pos = $i; // 如是当前位置 &gt;0 &amp;&amp; 当前值的前一个值 &gt; 当前值 选出最值 while ($pos &gt; 0 &amp;&amp; $arr[$pos - 1] &gt; $key) &#123; // 当前值 = 前一个值 $arr[$pos] = $arr[$pos - 1]; // 当前位置后移 $pos = $pos - 1; &#125; // 找到当前值的位置 $arr[$pos] = $key; &#125; return $arr; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F03%2F26%2F%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627&lt;?php//快速排序//待排序数组$arr=array(6,3,8,6,4,2,9,5,1);//函数实现快速排序function quick_sort($arr)&#123; //递归出口:数组长度为1，直接返回数组 $length=count($arr); if($length&lt;=1) return $arr; $left=$right=array(); for($i=1;$i&lt;$length;$i++)&#123; if($arr[$i]&lt;$arr[0])&#123; //第一次排序，left为小于6的所有数 $left[] = $arr[$i]; &#125;else&#123; //right为大于6的所有数 $right[] = $arr[$i]; &#125; &#125; $left = quick_sort($left); $right = quick_sort($right); return array_merge($left,array($arr[0]),$right); &#125; //调用 echo "&lt;pre&gt;"; print_r(quick_sort($arr));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双栈实现队列]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223&lt;?php $pushV = [1,2,3,4,5]; $popV = [4,5,3,2,1]; function IsPopOrder($pushV, $popV) &#123; // $stack = new SplStack(); $stack = []; $len = count($pushV); $j = 0; for($i=0;$i&lt;$len;$i++)&#123; array_push($stack,$pushV[$i]); while($j&lt;$len &amp;&amp; $popV[$j]==end($stack))&#123; array_pop($stack); $j++; &#125; &#125; if($stack)&#123; return false; &#125;else &#123; return true; &#125; &#125; echo IsPopOrder($pushV, $popV);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法时间复杂度空间复杂度]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[注：1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念：1、时间复杂度 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2) 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),2、空间复杂度 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1) 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ax=N，则x=logaN， 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环队列叫号问题]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[有m个猴子，按顺时针方向围成一个圈选大王。从第1号开始报数1，2，……，数到n号时该猴子退出到圈外，如此报数直到圈内只剩下一个猴子时，此猴子便是大王。由键盘输入m，n，打印出猴子大王序号。输入 10 3输出 4 12345678910111213141516171819202122 &lt;?php echo monkey(4,1);//5function monkey($m,$n)&#123; //定义arr猴子数组， $arr=range(1,$m); $i=0; while(count($arr)&gt;1)&#123; //出队 if(($i+1)%$n==0)&#123; //如果猴子序号/猴王号n余数为0，踢走 unset($arr[$i]); &#125;else&#123; //否则将该序号放在猴子数组队尾 $arr[]=$arr[$i]; unset($arr[$i]); &#125; echo $i."\n"; $i++; &#125; //最后key i所对应的就是猴王 return $arr[$i];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务、事务隔离、锁机制]]></title>
    <url>%2F2019%2F03%2F25%2Fmysql%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、什么是事务事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。Atomicity原子性：要不全部成功，要不全部撤销Isolation隔离性：事务之间相互独立，互不干扰Consistency一致性：数据库正确地改变状态后，数据库的一致性约束没有被破坏Durability持久性：事务的提交结果，将持久保存在数据库中 pass：不可重复读与幻读的本质区别不可重复读是读取了其他事务更改的数据，针对update操作解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。passpass:脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 幻读的重点在于新增或者删除. 脏读：数据读错方只读了一次数据库。不可重复读：数据读错方读了两次数据库 幻读是读取了其他事务新增的数据，针对insert操作解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。 2、事务并发会产生什么问题1）第一类丢失更新：在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。例如： 张三的工资为5000，事务A中获取工资为5000，事务B获取工资为5000，汇入100，并提交数据库，工资变为5100， 随后事务A发生异常，回滚了，恢复张三的工资为5000，这样就导致事务B的更新丢失了。2）脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。例如： 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。 与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。 随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。 最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。 3）不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如： 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。 与此同时，事务B把张三的工资改为8000，并提交了事务。 随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 4）第二类丢失更新：不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。例如： 在事务A中，读取到张三的存款为5000，操作没有完成，事务还没提交。 与此同时，事务B，存储1000，把张三的存款改为6000，并提交了事务。 随后，在事务A中，存储500，把张三的存款改为5500，并提交了事务，这样事务A的更新覆盖了事务B的更新。5）幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如： 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。 此时，事务B插入一条工资也为5000的记录。 这时，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 提醒：不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样 3、事务隔离级别，解决什么并发问题，以及存在什么并发问题（1）READ_UNCOMMITTED（读未提交） 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。 解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。（2）READ_COMMITTED（读已提交） 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。 解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题（3）REPEATABLE_READ（重复读） 保证一个事务相同条件下前后两次获取的数据是一致的 解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。（4）SERIALIZABLE（串行化） 事务被处理为顺序执行。 解决所有问题提醒：Mysql默认的事务隔离级别为repeatable_read 4、InnoDB引擎的锁机制（之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁）共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。说明： 1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。共享锁（S）：SELECT FROM table_name WHERE … LOCK IN SHARE MODE。排他锁（X)：SELECT FROM table_name WHERE … FOR UPDATE。3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php垃圾回收机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/u011957758/article/details/76864400 refcount：多少个变量是一样的用了相同的值，这个数值就是多少。is_ref：bool类型，当refcount大于2的时候，其中一个变量用了地址&amp;的形式进行赋值，好了，它就变成1了。 unset并非一定会释放内存，当有两个变量指向的时候，并非会释放变量占用的内存，只是refcount减1. 如果unset（$a） 如果在小于php5.3的版本就会出现一个问题：$a已经不在符号表了，没有变量再指向此zval容器，用户已无法访问，但是由于数组的refcount变为1而不是0，导致此部分内存不能被回收从而产生了内存泄漏。 5.3之后版本处理垃圾判断处理过程1.如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾2.如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾3.如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾 白话文版：就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾 A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。 B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。 C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性） D：遍历zval节点，将C中标记成白色的节点zval释放掉。 &lt;?php $a = [&apos;one&apos;]; --- zval_a（将$a对应的zval，命名为zval_a） $a[] = &amp;$a; --- step1 unset($a); --- step2 为进行unset之前(step1)，进行算法计算，对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样说明zval_a不是一个垃圾不进行回收。 当执行unset的时候(step2)，进行算法计算，由于环形引用，上文得出会有垃圾的结构体，zval_a的refcount是1(zval_a中的索引1指向zval_a)，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就认为zval_a是一个需要回收的垃圾。 算法总的套路:对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。 unsetunset只是断开一个变量到一块内存区域的连接，同时将该内存区域的引用计数-1；内存是否回收主要还是看refount是否到0了，以及gc算法判断。 = null 操作；a=null是直接将a 指向的数据结构置空，同时将其引用计数归0。 脚本执行结束脚本执行结束，该脚本中使用的所有内存都会被释放，不论是否有引用环。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用数组操作]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、数组操作的基本函数 数组的键名和值array_values($arr); 获得数组的值array_keys($arr); 获得数组的键名array_flip($arr); 数组中的值与键名互换（如果有重复前面的会被后面的覆盖）in_array(“apple”,$arr); 在数组中检索applearray_search(“apple”,$arr); 在数组中检索apple ，如果存在返回键名array_key_exists(“apple”,$arr); 检索给定的键名是否存在数组中isset($arr[apple]): 检索给定的键名是否存在数组中 数组的内部指针current($arr); 返回数组中的当前单元pos($arr); 返回数组中的当前单元key($arr); 返回数组中当前单元的键名prev($arr); 将数组中的内部指针倒回一位next($arr); 将数组中的内部指针向前移动一位end($arr); 将数组中的内部指针指向最后一个单元reset($arr; 将数组中的内部指针指向第一个单元each($arr); 将返回数组当前元素的一个键名/值的构造数组，并使数组指针向前移动一位list($key,$value)=each($arr); 获得数组当前元素的键名和值 数组和变量之间的转换extract($arr);用于把数组中的元素转换成变量导入到当前文件中，键名当作变量名，值作为变量值注：（第二个参数很重要，可以看手册使用）使用方法 echo $a;compact(var1,var2,var3);用给定的变量名创建一个数组 二、数组的分段和填充 数组的分段array_slice($arr,0,3); 可以将数组中的一段取出，此函数忽略键名array_splice($arr,0,3，array(“black”,”maroon”)); 可以将数组中的一段取出，与上个函数不同在于返回的序列从原数组中删除 分割多个数组array_chunk($arr,3,TRUE); 可以将一个数组分割成多个，TRUE为保留原数组的键名 数组的填充array_pad($arr,5,’x’); 将一个数组填补到制定长度 三、数组与栈 array_push($arr,”apple”,”pear”); 将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数array_pop($arr); 将数组栈的最后一个元素弹出（出栈） 四、数组与列队 array_shift($arr);数组中的第一个元素移出并作为结果返回（数组长度减1，其他元素向前移动一位，数字键名改为从零技术，文字键名不变）array_unshift($arr,”a”,array(1,2));在数组的开头插入一个或多个元素 五、回调函数 array_walk($arr,’function’,’words’); 使用用户函数对数组中的每个成员进行处理（第三个参数传递给回调函数function）array_mpa(“function”,$arr1,$arr2); 可以处理多个数组（当使用两个或更多数组时，他们的长度应该相同）array_filter($arr,”function”); 使用回调函数过滤数组中的每个元素，如果回调函数为TRUE，数组的当前元素会被包含在返回的结果数组中，数组的键名保留不变array_reduce($arr,”function”,”“); 转化为单值函数（为数组的第一个值） 六、数组的排序 通过元素值对数组排序sort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序rsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序usort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）忽略键名的数组排序asort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序arsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序uasort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）保留键名的数组排序 通过键名对数组排序ksort($arr); 按照键名正序排序krsort($arr); 按照键名逆序排序uksort($arr,”function”); 使用用户自定义的比较函数对数组中的键名进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个） 自然排序法排序natsort($arr); 自然排序（忽略键名）natcasesort($arr); 自然排序（忽略大小写，忽略键名） 七、数组的计算 数组元素的求和array_sum($arr); 对数组内部的所有元素做求和运算 数组的合并array_merge($arr1,$arr2); 合并两个或多个数组（相同的字符串键名，后面的覆盖前面的，相同的数字键名，后面的不会做覆盖操作，而是附加到后面）“+”$arr1+$arr2; 对于相同的键名只保留后一个array_merge_recursive($arr1,$arr2); 递归合并操作，如果数组中有相同的字符串键名，这些值将被合并到一个数组中去。如果一个值本身是一个数组，将按照相应的键名把它合并为另一个数组。当数组 具有相同的数组键名时，后一个值将不会覆盖原来的值，而是附加到后面 数组的差集array_diff($arr1,$arr2); 返回差集结果数组array_diff_assoc($arr1,$arr2,$arr3); 返回差集结果数组，键名也做比较 数组的交集array_intersect($arr1,$arr2); 返回交集结果数组array_intersect_assoc($arr1,$arr2); 返回交集结果数组，键名也做比较 八、其他的数组函数 range(0,12); 创建一个包含指定范围单元的数组array_unique($arr); 移除数组中重复的值，新的数组中会保留原始的键名array_reverse($arr,TRUE); 返回一个单元顺序与原数组相反的数组，如果第二个参数为TRUE保留原来的键名//srand((float)microtime()*10000000); 随机种子触发器array_rand($arr,2); 从数组中随机取出一个或 多个元素shuffle($arr); 将数组的顺序打乱]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用字符串函数]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[strlen($str);//返回字符串长度 mb_strlen($str) 可以返回中文字符长度 strtolower($str);//字母转小写 strtoupper($str);//字母转大写 ucwords($str);//每一个单词的首字母转大写 ucfirst($str);//首字母转大写 str_replace(‘a’,’b’,$str);//b替换$str 中的a 区分大小写 ; str_ireplace(‘a’,’b’,$str);//替换 不区分大小写 htmlspecialchars($str,ENT_NOQUOTES);//字符串转换为html 实体 ENT_COMPT(默认只编译双引号)ENT_QUOTES单引号双引号都编译,ENT_NOQUOTES不编译任何引号 trim($str);//删除字符串前后（左右）空格 ltrim($str);//只删除字符串左侧的空格 rtrim($str);//只删除字符串右侧的空格//trim加第二个参数 就是移除指定的字符集 如ltrim($str,’0..9’) 移除左侧数字开头的字符 strpos($str,’a’);//字符串a 在$str 第一次出现的位置 索引0开始 没有出现返回false 区分大小写 stripos($str,’a’);//同上 但是不区分大小写 strrpos($str,’a’);//字符串a 在$str 最后一次出现的位置 索引0开始 没有出现返回false 区分大小写 strripos($str,’a’);//同上 但是不区分大小写 substr($str,0,3);//截取字符串 $str 的第一个字符 截取长度3 长度不填默认截取到最后 参数为负数则倒数 strstr($str,’a’);//截取字符串 $str 中的第一个字符’a’后的字符串 如 sabc -&gt; abc strrchr($str,’a’);//截取字符串 $str 中最后一一个字符’a’后的字符串 strrev($str);//字符串反转 abcd-&gt;dcba md5($str);//字符串MD5加密 str_shuffle($str);//随机打乱字符串顺序 explode(‘-‘,$str);//指定分隔符分割字符串 返回数组 ‘-’ 分割$str implode(‘-‘,$str);//数组拼接字符串 与explode()相反]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php拷贝机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号）php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引总结]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[mysql索引总结索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。如果我们把SQL语句换成“SELECT * FROM article WHERE id=2000000”，那么你是希望数据库按照顺序读取完200万行数据以后给你结果还是直接在索引中定位呢？上面的两个图片鲜明的用时对比已经给出了答案（注：一般数据库默认都会为主键生成索引）。索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。 普通索引这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。 唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 全文索引（FULLTEXT）MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。 单列索引、多列索引多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：–title,time–title]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
