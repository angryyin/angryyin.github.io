<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>music</title>
    <url>/2019/03/29/new/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2059989167&auto=1&height=66"></iframe>]]></content>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2020/05/05/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>JavaScript执行上下文(context)主要指代码执行环境的抽象概念。执行上下文分为三种：</p>
<p>全局执行上下文<br>函数执行上下文<br>eval执行上下文</p>
<p>每一段js代码执行，都会先创建一个上下文环境。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>js代码执行前会创建上下文环境，这个上下文环境包含了变量、作用域链和this.<br>简单理解就是从当前环境向父级一层一层查找变量的过程称之为作用域链。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'前端未来'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们在函数hello里面打印name的时候，会先在hello作用域中查找，如果没有找到就去hello的父级作用域中查找。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个函数都拥有一个prototype属性，每个函数实例对象都拥有一个<strong>proto</strong>属性，而这个属性指向了函数的prototype，当我们访问实例对象的属性或者方法时，会先从自身构造函数中查找，如果没有就通过<strong>proto</strong>去原型中查找，这个查找的过程我们称之为原型链。（跟作用域链有点像）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义动物 - 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello tom'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义猫 - 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过原型继承动物类</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="comment">// 实例化一个cat对象</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">// 打印返回true</span></span><br><span class="line">cat.__proto__ === Cat.prototype</span><br><span class="line"><span class="comment">// 打印age，会先查找cat，再查找Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.age)</span><br></pre></td></tr></table></figure></p>
<p><img src="\images\pasted-142.png" alt="upload successful"></p>
<p>通过截图，我们可以看到cat实例对象<strong>proto</strong>指向了Animal，当cat没有age的时候，会通过<strong>proto</strong>到原型上查找，如果原型上依然没有，会继续向Object上查找。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>简单理解就是函数中嵌套函数。我们都知道局部变量我们是无法访问的，但是通过闭包可以做到。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常访问</span></span><br><span class="line"><span class="keyword">var</span> lan = <span class="string">'zh'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'前端未来'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)<span class="comment">//很明显'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'前端未来'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name)<span class="comment">//打印：前端未来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>原型继承<br>构造继承<br>实例继承<br>call/apply继承(组合继承)<br>ES6 使用class extends继承</p>
<h2 id="深-浅拷贝"><a href="#深-浅拷贝" class="headerlink" title="深/浅拷贝"></a>深/浅拷贝</h2><p>JS数据类型分别基本数据类型和引用数据类型，基本数据类型保存的是值，引用类型保存的是引用地址(this指针)。浅拷贝共用一个引用地址，深拷贝会创建新的内存地址。</p>
<p>浅拷贝方法</p>
<p>直接对象复制<br>Object.assign<br>深拷贝</p>
<p>JSON.stringify转为字符串再JSON.parse<br>深度递归遍历</p>
<h2 id="判断一个对象是数组"><a href="#判断一个对象是数组" class="headerlink" title="判断一个对象是数组"></a>判断一个对象是数组</h2><p>面试官希望的答案：Object.prototype.toString.call([]) 返回 “[object Array]”</p>
<p>扩展答案</p>
<p>[].slice (能力判断 )<br>[] instanceof Array(类型判断)<br>[].proto === Array.prototype<br>Array.isArray([]) 存在兼容问题<br>数组也是引用类型，通过typeof依然返回object</p>
<h2 id="数组有哪些常用方法"><a href="#数组有哪些常用方法" class="headerlink" title="数组有哪些常用方法"></a>数组有哪些常用方法</h2><p>push 末尾添加<br>pop 末尾删除<br>shift 首部删除<br>unshift 首部添加<br>concat 数组合并<br>join 数组元素 通过连接符 连接<br>reverse 数组反转<br>sort 数组排序<br>map/forEach/filter/indexOf/includes/slice/splice<br>slice表示截取，slice(start,end)不改变原数组，返回新数组。</p>
<p>splice表示删除，splice(start,length,item)，会改变原数组，从某个位置开始删除多个元素，并可以插入新的元素。</p>
<h2 id="DOM节点创建和修改有哪些常用API"><a href="#DOM节点创建和修改有哪些常用API" class="headerlink" title="DOM节点创建和修改有哪些常用API"></a>DOM节点创建和修改有哪些常用API</h2><p>创建节点</p>
<p>createElement<br>createTextNode<br>createDocumentFragment(临时节点)<br>修改节点</p>
<p>appendChildparent.appendChild(child)<br>insertBefore parentNode.insertBefore(newNode,refNode);<br>removeChild parent.removeChild(node)<br>replaceChild</p>
<h2 id="CSS清除浮动有哪些方法"><a href="#CSS清除浮动有哪些方法" class="headerlink" title="CSS清除浮动有哪些方法"></a>CSS清除浮动有哪些方法</h2><p>父级元素设置高度，手动撑开<br>浮动元素结尾增加空标签，设置clear:both<br>父元素设置overflow:hidden<br>父元素添加伪类:after和zoom</p>
<h2 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h2><p>!import &gt; 内联样式(style) &gt; ID选择器 &gt; 类/属性/伪类 &gt; 元素/关系</p>
<h2 id="CSS实现三列布局（左右固定宽度，中间自适应）"><a href="#CSS实现三列布局（左右固定宽度，中间自适应）" class="headerlink" title="CSS实现三列布局（左右固定宽度，中间自适应）"></a>CSS实现三列布局（左右固定宽度，中间自适应）</h2><p>CSS浮动<br>第一个float:left，第二个float:right，第三个设置margin-left和margin-right</p>
<p>绝对定位法<br>第一个定位到left，第二个定位到right，第三个设置margin-left和margin-right</p>
<p>flex布局<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  或者</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  或者</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>阿里圣杯布局（忽略）</p>
<h2 id="谈一下flex布局"><a href="#谈一下flex布局" class="headerlink" title="谈一下flex布局"></a>谈一下flex布局</h2><p>flex是一种弹性布局，包含flex-container和flex-item.</p>
<p>常用的属性包括flex-direction、flex-wrap、justify-content、align-items</p>
<p>水平居中 justify-content:center 水平两头居中 justify-content:space-between 垂直居中 align-items:center</p>
<h2 id="谈一下盒模型"><a href="#谈一下盒模型" class="headerlink" title="谈一下盒模型"></a>谈一下盒模型</h2><p>盒模型包括：content,padding,border,margin</p>
<p>盒模型分为：IE盒模型和标准w3c盒模型</p>
<p>IE盒模型宽度包含了padding和border，w3c盒模型宽度就是内容宽度。</p>
<h2 id="transition动画和animation有什么区别"><a href="#transition动画和animation有什么区别" class="headerlink" title="transition动画和animation有什么区别"></a>transition动画和animation有什么区别</h2><p>他们虽然都可以做出动画效果，但是transition主要做简单的过渡效果，而animation可以做复杂的动画效果，在语法和用法上有非常大的区别。</p>
<h2 id="H5自适应方案"><a href="#H5自适应方案" class="headerlink" title="H5自适应方案"></a>H5自适应方案</h2><p>H5自适应方案大家在网速能找到很多，我个人推荐一种我非常喜欢的方式，就是rem. rem是一种相对单位，它基于html的font-size值来进行调整。</p>
<p>通常我们以750为基准，我们会在header中嵌套一段js脚本，获取手机网页分辨率尺寸除以375，为了方便计算，我们假设750像素下1rem = 100px；所以 我们除以375后需要乘以50.</p>
<h2 id="call-apply-bind作用和区别"><a href="#call-apply-bind作用和区别" class="headerlink" title="call/apply/bind作用和区别"></a>call/apply/bind作用和区别</h2><p>他们都可以改变函数的作用域。</p>
<p>call/apply可以直接执行该函数，而bind不会立刻执行<br>call/apply作用类似，都可以改变指针和执行函数，区别在于传参不同，call需要单个传参，apply通过数组传参<br>观察者和发布订阅者区别<br>他们都属于观察者模式，只不过有不同的实现方法。发布订阅相比于观察者多了一个调度中心，发布者通过调度中心向订阅者发布消息。观察者模式中目标和观察者相互依赖，观察者订阅目标主题，当目标发生变化后，会通知对应观察者。</p>
<p>大家可参考我另一篇公众号文章。</p>
<h2 id="浏览器解析渲染页面过程"><a href="#浏览器解析渲染页面过程" class="headerlink" title="浏览器解析渲染页面过程"></a>浏览器解析渲染页面过程</h2><p><img src="\images\pasted-143.png" alt="upload successful"><br>解析HTML，生成DOM树<br>解析CSS，生成CSSOM树<br>将DOM树和CSSOM树关联，生成渲染树(Render Tree)<br>布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br>绘制render树（paint），绘制页面像素信息<br>将像素发送给GPU，展示在页面上。(Display)</p>
<h2 id="谈一下EventLoop"><a href="#谈一下EventLoop" class="headerlink" title="谈一下EventLoop"></a>谈一下EventLoop</h2><p><img src="\images\pasted-144.png" alt="upload successful"><br>这其中大家需要了解几个概念：调用栈、同步/异步任务、宏任务/微任务</p>
<p>JavaScript本身是单线程，也就是同一时刻只能干一件事，JS任务包含了同步任务和异步任务，遇到执行函数会将其放入调用栈(先进后出)中，遇到setTimeout/setInterval等异步任务时，会把它放入到消息队列中，等主线程的任务执行完成以后，再回过头执行消息队列中的异步任务，如果异步任务中仍然有异步任务，会继续放入消息队列，以此类推，便形成了一个事件循环。</p>
<p>异步任务：</p>
<p>setTimeout<br>setInterval<br>异步任务又分为宏任务和微任务，promise就属于微任务.</p>
<h2 id="GET和POST有什么区别"><a href="#GET和POST有什么区别" class="headerlink" title="GET和POST有什么区别"></a>GET和POST有什么区别</h2><p><em>大小方面<br>GET传输一般2K-8K，IE限制2K，，POST没有大小限制
</em>安全方面<br>GET通过url明文传输，POST通过body传输，本身都不安全，因为HTTP就是明文传输。<br><em>浏览器记录<br>GET请求浏览器会记录，POST不会
</em>浏览器后退<br>GET无害，POST会再次提交<br><em>浏览器收藏<br>GET可以收藏，POST不可以
</em>浏览器缓存<br>GET可以缓存，POST不会<br><em>编码方式<br>GET通过url编码，POST支持多种编码
</em>TCP数据包<br>GET产生一个数据包，POST产生2个数据包<br>*使用方式(习惯上讲)<br>GET主要拉取数据，POST主要提交保存数据</p>
<h2 id="谈一下防抖和节流"><a href="#谈一下防抖和节流" class="headerlink" title="谈一下防抖和节流"></a>谈一下防抖和节流</h2><p>防抖和节流都是希望在同一时间内，不要重复触发请求。一般场景用在搜索和网页滚动事件中。</p>
<p>区别：</p>
<p>防抖主要是在规定时间内只触发一次，如果再次调用，时间从新计算。</p>
<p>节流主要是在固定时间内只触发一次。比如每间隔1秒触发一次。</p>
<h2 id="数组如何去重"><a href="#数组如何去重" class="headerlink" title="数组如何去重"></a>数组如何去重</h2><p>ES6 Set去重<br>利用Object key去重<br>两层循环逐一对比，生成新数组<br>indexOf去重<br>sort排序，再单层循环前后对比</p>
<h2 id="数组如何排序"><a href="#数组如何排序" class="headerlink" title="数组如何排序"></a>数组如何排序</h2><p>数组sort排序<br>冒泡排序（两层循环，两两互换）<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line">function bubbleSort ( <span class="keyword">data</span> ) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="keyword">data</span>.length ; i &gt; <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; i - <span class="number">1</span> ; j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>( <span class="keyword">data</span>[j] &gt; <span class="keyword">data</span>[j + <span class="number">1</span>] )&#123;</span><br><span class="line">               temp = <span class="keyword">data</span>[j];</span><br><span class="line">               <span class="keyword">data</span>[j] = <span class="keyword">data</span> [j+<span class="number">1</span>];</span><br><span class="line">               <span class="keyword">data</span>[j+<span class="number">1</span>] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>选择排序<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">//选择排序</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> selectionSort( <span class="keyword">data</span> ) &#123;</span><br><span class="line">    for( var i = <span class="number">0</span>; i&lt; <span class="keyword">data</span>.length ; i++)&#123;</span><br><span class="line">        var <span class="built_in">min</span> = <span class="keyword">data</span>[i];</span><br><span class="line">        var temp;</span><br><span class="line">        var <span class="built_in">index</span> = i;</span><br><span class="line">        for( var j = i + <span class="number">1</span>; j&lt; <span class="keyword">data</span>.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="keyword">data</span>[j] &lt; <span class="built_in">min</span> )&#123;</span><br><span class="line">                <span class="built_in">min</span> = <span class="keyword">data</span>[j];</span><br><span class="line">                <span class="built_in">index</span> = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        temp = <span class="keyword">data</span>[i];</span><br><span class="line">        <span class="keyword">data</span>[i] = <span class="built_in">min</span>;</span><br><span class="line">        <span class="keyword">data</span>[<span class="built_in">index</span>]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入排序<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">function insertionSort( <span class="keyword">data</span> ) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">data</span>.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">data</span>[i];</span><br><span class="line">        <span class="keyword">var</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">data</span>[j] &gt; key) &#123;</span><br><span class="line">            <span class="keyword">data</span>[j + <span class="number">1</span>] = <span class="keyword">data</span>[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">data</span>[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="谈一下常用设计模式，并选择一个进行场景分析"><a href="#谈一下常用设计模式，并选择一个进行场景分析" class="headerlink" title="谈一下常用设计模式，并选择一个进行场景分析"></a>谈一下常用设计模式，并选择一个进行场景分析</h2><p>单例模式<br>工厂模式<br>观察者模式<br>适配器模式<br>在Vue中通过观察者模式触发视图更新。Vue2.x通过Object.defineProperty劫持data数据，当数据变化后触发setter，setter内部通过订阅器来notify消息，notify会调用watcher更新视图。</p>
<p>当一套前端对接不同后端服务时，会出现数据解构不一致情况，这个时候可以使用适配器模式来兼容不同后端，使他以统一的数据解构对接前端。</p>
<h2 id="谈一下灵活的for…of"><a href="#谈一下灵活的for…of" class="headerlink" title="谈一下灵活的for…of"></a>谈一下灵活的for…of</h2><p>for…of 是ES2015版本引入的语法，它可以遍历数组、类数组、以及Map/set/字符串等</p>
<p>数组迭代<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (const <span class="built_in">number</span> <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>类数组迭代<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>字符串迭代<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">message</span> = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> character <span class="keyword">of</span> <span class="keyword">message</span>) <span class="comment">&#123; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>map迭代<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">"name"</span>, <span class="string">'前端未来'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">"author"</span>, <span class="string">'河畔一角'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item of <span class="built_in">map</span>)&#123; &#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [<span class="built_in">key</span>,val] of <span class="built_in">map</span>)&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>Set迭代<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Lily'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> names) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="前端常见攻击方式"><a href="#前端常见攻击方式" class="headerlink" title="前端常见攻击方式"></a>前端常见攻击方式</h2><p>XSS攻击<br>CSRF攻击<br>Sql注入<br>html脚本注入</p>
<h2 id="前端有哪些跨域方案"><a href="#前端有哪些跨域方案" class="headerlink" title="前端有哪些跨域方案"></a>前端有哪些跨域方案</h2><p>JSONP跨域（本质是JS调用）<br>CORS（后台设置）<br>Nginx反向代理（运维配置）<br>跨域是浏览器做出的安全限制，必须同协议、同域名、同端口否则会被浏览器block</p>
<h2 id="前端网站常规优化方案"><a href="#前端网站常规优化方案" class="headerlink" title="前端网站常规优化方案"></a>前端网站常规优化方案</h2><p>优化策略：减少请求次数、减小资源大小、提高响应和加载速度、优化资源加载时机、优化加载方式</p>
<p>合并、压缩、混淆html/css/js文件（webpack实现，减小资源大小）<br>Nginx开启Gzip，进一步压缩资源（减小资源大小）<br>图片资源使用CDN加速（提高加载速度）<br>符合条件的图标做base64处理（减小资源大小）<br>样式表放首部，JS放尾部（JS单线程，会阻塞页面；资源加载方式）<br>设置缓存（强缓存和协商缓存，提高加载速度）<br>link或者src添加rel属性，设置prefetch或preload可预加载资源。（加载时机）<br>如果使用了UI组件库，采用按需加载（减小资源大小）<br>SPA项目，通过import或者require做路由按需（减小资源大小）<br>服务端渲染SSR，加快首屏渲染，利于SEO<br>页面使用骨架屏，提高首页加载速度（提高加载速度）<br>使用 JPEG 2000, JPEG XR, and WebP 的图片格式来代替现有的jpeg和png，当页面图片较多时，这点作用非常明显<br>使用图片懒加载-lazyload</p>
]]></content>
  </entry>
  <entry>
    <title>笔记本维修避坑记</title>
    <url>/2020/04/30/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%BB%B4%E4%BF%AE%E9%81%BF%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<p>记录一次返厂经历，遇到的坑与解决办法<br>   坐标武汉，简单说就是电脑在保内碰上了闪屏故障，电脑城大世界12018室维修站想坑我的保内维修权让我花钱修，最后跑到对面华师资讯广场4楼33号得到了公平公正的保修服务，这两家都是官网可查的神舟武汉指定维修点，并且都在广埠屯。<br>    型号战神Z7-KP7Z，用了一年不到14天，4.15日上午用电脑时候突然出现闪屏，亮度越高闪的越快，亮度30以下不闪，送修后翻贴吧发现和B站维修厮的一期视频问题一模一样。在这里贴上该维修视频地址：<a href="https://www.bilibili.com/video/BV1Yb411x7Mp/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411x7Mp/</a><br>    问题一出，我当天中午就出发去广埠屯了，我上一个船本浸了咖啡，在电脑大世界这家保外维修花了一千多块钱，结果半年又坏掉了。我是4.15号查官网才注意到有两家维修点的，但是第一反应还是去电脑大世界这家，我心想用了一年不到的本子保修应该没问题，但是到了维修站那哥们直接拆我的后盖，看了不到5秒，指着我的小板说：“【你这里进水了不能保了。修的话要900，需要二十天修好。】”<br>    按神舟保修的条例如果真的进水了，就判人为损坏，那么返厂确实不会给我保，但是我上个电脑就是进液坏的，一朝被蛇咬十年怕井绳，我平时都不会把液体放在电脑旁，所以我很清楚我电脑没有进水，我也不是什么小白，而且那闪屏是正常使用的时候突然出现的。<br>    我跟他说不可能是进水，然后他拿出一张他自己修的进水主板照片让我自己对比故障，又指了指我的U口说那里也进水了，我看了一眼U口根本没有问题。反正他反复跟我强调这是进水故障，不论我闪屏是什么原因造成的，只要有水点，那么在他这里不保，说我自己拆过机器还嘲讽我没有清灰？？我反复跟他确认是不是真的不能保了，我跟他说我上个电脑在你们这里修结果半年就坏了，我已经不是很信任这边的维修站了。他感觉我特别纠结就告知我可以选择返厂，但是他不保证返厂能修，如果返厂判不能保我需要出80运费，他还特别强调说会如实上报所谓的进水点。我气不过就直接走了，如果不能保我还不如找私修。<br>    等我下楼了我想起来好像有两个维修站，地图一查就在对面的华师资讯广场，当时想法是这家要是同样的说辞我就找个便宜地方修算了，这家维修站不大，就一小哥哥，等我到了地说明了故障他没有拆机直接给我开维修单要我返厂，我当时都惊了，这反差实在太大，等我填完了维修单我忍不住直接把之前的遭遇跟他说了，我说对面的说我这机器有水点不给保，你要不看看，他说你这在保的机器返厂人家要是不能免费修给你打电话就可以了，到时候觉得维修价格无法接受返回来只需要我出50元的运费（之前那家说的是80运费）。我问他要是你修的话多少钱，他说看情况吧，大概300-500，不过也不一定（之前那家说的是900不带范围区间），如果修的话一周到两周的时间可以给你修好（之前那家说的是20天，还是我亲自给他送过去不带物流时间）。于是我就把电脑交给他了，官网可查的是一个小时小哥哥就给我把电脑发昆山了，不管怎么样这服务态度可以打满分了。当时我想如果修好了我是一定要发帖的。<br>    时间跨越到13天之后的4.28，在三天前就已经修好了，我估计今天能到但是没有物流信息，于是下午直接打了神舟客服查了京东物流的单号，发现已经到咨询广场维修站了，对方还没检测我就跑去拿。别看人家地方小，桌子上摆着两台正在测试的电脑，而且小哥哥今天很忙还没来得及测我的本子，告知我昆山那边直接修主板。我自己在那里坐着检测了会觉得没问题就搬回来了。没有付维修费用，没有付快递费用。身处疫情中心的武汉，在复工之后依旧能得到这样高效高质量的服务，我给这个小哥哥打满分。如果以后还出现问题我也只会来这家店修：【武汉市盛宏伟信息技术有限公司】地址【湖北省武汉市洪山区珞南街道珞喻路100号资讯广场4楼33号】</p>
]]></content>
  </entry>
  <entry>
    <title>【记录】2020年春</title>
    <url>/2020/04/14/%E8%AE%B0%E5%BD%95%E3%80%912020%E5%B9%B4%E6%98%A5/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX18yY+DjSufVwAHLvmgVNg6ORZASkXZ1NIKXqGhRT6/SIZZcAKuCtZojy9KW8BPNbJSYkt66yGfU6jioqrdPmHKxp2ze6uo6Hd1KlZNxLWeI5viHUG7iReeEezwLxVdVenJypjpbzv325s+cCLkRE6KBB5RcYPlCvNFGFPym2Igh2pNKKd7D/JEJH5hl2acs64t9PujEDE4C/1AOqaWjqN8jEJm7ux6EhJNvRBKmoU3HOWS2RuOwVj1VylFMTHQd0RUSsAOZ3kexFyZ8/DlP62wRTRZFT+GegKzt8C4IpDCh+NNTL4ang3l+hhyEosY8xeZyhs1s27eU7O9HH8lJ03k6yqQdf669KTZcSp23qEtwK7y1LPycobqNfoZpjSueEwzGj0doZs3Xyc5YEWWNDc+wkI9dMSkGKC+ZK2+UJ8WDdmB7oydJjjUmncAinitg7fyViflO2EjRFbbbHeQO3fbxBbAHoyY/zwU2Gw60RVIoO4SWStFRtBGpzHHXbxSboa6b1tLD0fLQQijukON5VqNTgsJYZonidljaMPUhxU+bNojAWYWsEL81PdC5k0EiJzRX0025P62dSAJH+lJ7Iy2T+0LfTmGO4Ksp+f5M2jf5y78jcoErvmUsD5E6wi/UkomdnAG4pJWClvlED3q/0YmkfxKD0sZmk9bN4zuy1Lm8SYbFujK1kW1VnzvLxl9A1vdtXDAPdoeZZgrm/aCk7ZQeTat26GTubmOSzMVCZlaxqcjN0Jx6i8B0lObTYp99OI3bdS94uYYTFuLkFEuHW0Sb27mB11YSTLR12drlHLtMiMWt0PI8gLcJOU6D25wcDvK3f28iCTj9SFVeBs8CPZLYEVxlcnw0YPucnLrbIlpbyN90IwX0S1lsAIABFPBVaO7498lloxmnoEtRcb/9kLn1eUfOWqlY4+nHxS5TpBfqia2uDT9HMRnz39AgJjSe8b/uCFcvHfbNUM4jCnZicoZHIhs2qWbiMv4YY9taHKFtbxVKF6QmLWSqm87wCRCoHHa+03lXgAi1mRnT9t1wHn+OZuB5YDZWc7p8jos/8lViSm4SnHLYWZlmCyJPUSS47JL0zxL2pOIQs6aeDxMiC6OWpOJTtv0KsTLBerAeqNRSe/McVSVxu1Oz0RP4iaTKajBhtrIsb2cFRUxZjaq4/QbmtjadIHHK1SBUA98XVSwlOUewyt7gbwzcI68j4FPrH9qfIE1B5HMi2G1wJGZPE0QXmNVuGWOXCiLpoCIwYCp6efV4/gx2mY3JrEJM7RGpDxlk1gbYmYbx/WMSJmgmOtILEKkVWULDISfBn8l0TrDlcK1q44eBxnDzZ9xFY8kbV0cTZoAA8FOekjJgvwb270ZCIH2pkn+nECVPSxEuT/HCU90adC76OH/OcVcmzkMgNyDjrpRahjkgvfkYzN6vIg43i0sp1C09E0Ua+lu769zITCkZbWQWSPWEkq67AhqLMOimSpeBwRAAlnL/1zYQRUn5smGyCIDvwgt1bPQLBqMPGv4LeKQcuII4uYuHKv0Enf6JXkZDPkr80tSyZT68n3riQQxiRjbKAvJ2b1uR48Y5TPHB6KGxDuFSbBpUHSA7ubYKK1UvJXztnIbRAtKk7cTxFD1TO7KcmLvHLxnfH5KG8NPs0iKeNJRr+HEqIiV3WVKeAwi06TY47yKa7gpYRguzcjRMik9d06VayANdf9NSZIsqIB8lOBO34MViTUWz0fCrRZIQyXFyk+tiT/9n3H7112qNwQV1IUCm17BPtIj9T9HflUYbliX0KysMvyGt9Bgj87ONL/RcyM/VTTOKvyX6wyRcNUlPFTJzZOMRNiUyGkvGDCkzqqFk7vnryNS8t7Qqh9ElRiop25TiHUKWNJ8JNXsLxKdIpYHHMyJutKXHui8EAPhHMPvoLUcsMRKtACdtUzMpDplwrMTzY99BfUWncxTwj3wheIYQx5jC2efUHhOjXzE4eB1ZmkGswhXOjloTBo4Pq9wcnm32hWKtyD5u9bSpQk+2Ua9LOGGEKVVX7K6CcIm1qWzulKHXOu9QNlXdw9nIkUIwmRdPyXr6H06gQrVvnB0Olyi4pfE46dsg9vuMvw3WNuHWGJgM3M9r2uH7ZKn674z7kXAWzHuq4LJ1/NsudOrtbRcMb7AryE2f05Lp51RsGsXfdtINdzTZMKq8Rzq4Y6qzi785U80FnlzSu2m/GKKKojewEdLOAcoHw7HBzU5olgfWTiuMv0lI8GnJY9M7PAKcYeNvMHmJmSZGz6LaV/Cl0afGfwwt/R3HozhqsmRjO0sM1yp/Dcf125vzu6+S8LxYemJpIGXfolkXq30SoJXjpXAQvAndqZeKAqonvGBK3elqwctmAOO0zgu+zBOp6pcruray4jtEjSV0/A64DNhpuzOw/NsZNhYvkO8VYefVRCy/NUTxgXNAIP4CoC5ScjeMKa2shox0wna+D4QpkJhKBvuVi68wLZ1TMrloprVj7FSTwbqswntXa4xGsx5jGEYBN/MyqzmGNdUdV9tC8Ogcv9PuyyfjVFPjf8jeHoqIsi8haXf9W66yE9TOcI9OtrXH1yVITsRbBNMW1BzZJsTfNuaKAyJs3JqMWlS1mSg/Rt8V8KzQLIb/uV+8xP3KhUGWTceHJdzFVMv+f+581MNaLcziQq+QYghkIFoTUdaLyNfnWV/eJEhFk5zYzA7JRUkxZfxOv/vBFG6jt8Yb4o7tM4U6qrZRNRZl7WObzd092u0aOKMtOuCFUayYKzrcbSbk04BZiSGGk+aFUHnCENehWyPmul/+nVB4s8Sw0XHuf7ntxSscYopRT4tontvdC3T3JZbzW+L8zWbHy8PrwYLq65Ioc2F1SypKAYTdNzTDtkb5DKRpDLgbA+fcLKR9bGOpP/oSjD0D9ofiTFAQX+eyQzTqmb5XLQ8Z5HIUN5FvCg4hdNdKi6ELgJeyP75EAWOAFWJj2JpUgr3nSrPDHLa0N0OeX2PPQuD7nak7I0UseSp+i8teBU22jQU1T3RZUC2pE1Wlwx4ODc+m2atPkeU1hy5vAtkEZs10r+1Ubuig2Rg7JIAzeESxVZs+fOhNPj9CYu/nV9oSKGaI9v4sNXYfjYckmn4IiP0FYjjgpJflKAn37I86K+LPdnX0t97xUQgAuyFeypt/xWtCfTbxVSZ3IcSDWDYTrwGcq/1WDWU/2WzypyC9NIt8W2Jv+Ln41xdcTytAyeoemWYFTEykesmWGCvTDTUVI7VOEzEIAIN5j5glDRwlgSqzgyU0PBBaKKagie08dn7350uhcXPQwGLkwP6r0Aq5MOUWr/1uFd71tAntA3gAkGuEH8XIh6q9HTXTquaUbdWx+xCaFBRFYty8PatTFAb6OuN2E743Hwo9cTA7eyPS5izS6aJ2KKjaYp3M+KeTZceyXMzA7t0uT2sUxk7V9/7fKsox+DAtD1TAEZV1pr0tIuKawh20u8glL6mRzwqbm5BnveeOveooHHY3dtghCQrHWv6/5GZe5a6fi4upn6vN25hC0ll/HHgsc2pMWJIlAXZ+cFj950FMeyAuLUT9aZN88TnZainYRCjqmog5Vskh28LbnLQBBD6Fdro+UIHJXJ4Z2x/8k+6N8BXyk9khRuc9pCwlc4EY3Hbr/Hd/CBONGRN9f+iXC5Mj1K00sq3HQwiDaTdEgWJajas0tM2ItN9LvnPZbuDi+8ZFZdcXGlVbJjDYtqvzpvnw82W9TNGdQm9LukHf6BPoNdSlZqc1BX0nylXFcEDDBS0o0osTBh/rq0S2YpABHqO48eqD70ZDUl15fZ3gQKcTWl4Ffm3MfzblaY3NaD7H1RhD5ZTphhc4FTjAR/g9ZDdjSe3U6op8GEItGfCSia4Pa09O6Skhb5VoJeh2AvKzxCzPgQLvlXTYunZ+TCHkxQM2TfrdkxC694Yob7b3nxHnaRBR+wgyP/KuFX+UAeZnNmU70CRgwgKR41iZIXqHYTK3VV57/7c0ut7IKaSHcizCZA/RwZsE795YbagGNVuSQe6GYsoKu0ygYCHLEdB8/OeJtBvt8+xzlnHA0mpTkhIyewh6nir/WF2akbPj5s+3pkOG2QEKRJENHAplPX/x3cuDiYw4q/i2yliPcx7TEoSi317A5bZ1kCoIkyNTBebwOhN8hWLMa55SLGuijkbL9IJJ0q2DOm6SX1LtVEr0PEZkeM0GRXdPA1YgEg8njKAA/20JUdWR+lOx1gBKXnPPNvGe8s0B+W9YKgBkv8TvLrPK3FruYUNvKSC+4K1iX17eePH6+k7upkhRo6AJGY6/6zxjOyyTmUsbbL16ixys8wZgbywETbpuFbDNU0fyOu4yIC8IP07b2KHLxBu18TJNqT75LHygEHAvP3atG3rkRORq/NtFx1JHCFbJJr2CMDsLadI5hSK4aJLwEeDRE/MzGZJZDW/vEQh+/AUwKl9eJSAPL7Anda6lwHne3Md5LoxB0/5iDNi/K9jl/60ymZLCV8GPm7sePLHqoeYuK+iqfnLmeILlPFZgPJx1wiAirlmzeZR34AZjjhQfqzhMsM0IvhYFa8ucVKKkMOcIPc+Zc+9xb9sFG1DE3nSG3ByrUc/1NsV0GqLOiH5/NqHSDgfsVhqUztrMsn1zYoClxuaTgvLYbi07f99y4STbC9u0SIHj4YEv2z7MGF3xdcVvz0achMVWAzQ5xXcFUeA49Gi+ww9HFhAAGa/OmtLpxK5w3tsN5PlJzUMp/IRR65jmfv1TUykbl/TwecrEsKZ0wyfP445dxDKM/LWE+QD2omFtdP5IJsBV/Rd/rAmUiCWjjDSZFDYbe5f0QShsHuAXI6oUj+yNxwYir1Do1jtm44XPMPcych/gSdw4ndCNcZ4DTkZJ1y9uLr77E5zRbjgZuAo+jNXgLCEJnnaNxNlQyumilr+rQhiojaEE+iDJXF9VOUwA1ziuiVRbcPksIIUhaJ0OH7LpJeQaEHDFgPpxTgFs7dbHVrF1+wLu231+xz8gqokPCcu+Dva2LEJ/NWOqp47BC/3ftvT2GBNmDVO9olOJkw/bkf4VMxzzM9OH+d170hUF14oz4Cx9rcvp6U1ZHFz8j8wX74tRs3zWBu44k0wwQMTiM7J4NvYvYMZ7q7j7KIZFqiUuVIRQOWltt4T3uLDaQbIBTmuTxfQoh5tfLoFcbtiuUVZct9J59aJrYPLT1w8Tb8jU/uNX8vqmw0vFXhh+qBPkVpRlvivEvglj49t1BUcy6M3IeLpZzo5/qEtdXRD2vkjfYc2O4R6dV+A731z9QhinOuM0EtazSbTyJZUbp7sU513DNI49ho9Kh5yHDM2g7H+x/0pk3a8uJMUfyGrQdQUlOsYGGkiy6XApIJUi52a8dRwenvE5e4RBgASUpzLJiiVRgGcYNlEK+bOJl2HGSN9idBWD5i7cvdzAgZ+kuyMXfNaV9kIbtttYA7JCWcUZInJCPwqXOg3T5QRhQN5CPjg8hxTMtcSiQ1fmVk3SSj+2BtJ4riaNUXSFKvCB1N9Zl1EEezBLTAfsAF0cZVB89fIZb0NM78ruVmdbpGCmfDjRbNT/h2lT9UubMADUV0FaeFgKPegOPEO33owZcdk9qCcI4AkOfkZ9SLAV2Jsrx2cy7lICNrjeNGnRy9cW10CM9/WcxBeAgfbSUgsAK/DJsMbfbk/Zl7Ype+yE5t4Uz2qNsAjNs846jhzEoPf6F+cdYvLzLkyAyrS4PwqEvMhr5bggNJW1VNQtSBz8JmDWzopETIzE+SoLL7R4I0DSO1k+oQ2YnAGzui3kS3+2xZ+hpuzZtwHn+LBJ/c1GiNwt4/CTm7UQpK3vlmgFmvBje1RDaEp8Eqi50TjcXWNhJRettgp1oJEkIXGmND6NT0BzoKEYP92zAzq6N15ZjWwNnInU9ObJBUGwmVpoAdQHZOJJNkV9CQ7t4OlEeEzplqmtQBzjxicZuoQu/a2bTzVExuHxuMCX0ADaESIofX/ipRfxE5XR8aX8QaHzQrgNj6STtvTQlMsPqhdupMCxYPLqg80zt9ayAo67T14uCuZ55l0YCaGloGpHLtmrx0CYDVoNyvC34TF3MC3G
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>【积累】JavaScript</title>
    <url>/2020/04/14/%E3%80%90%E7%A7%AF%E7%B4%AF%E3%80%91JavaScript/</url>
    <content><![CDATA[<p><img src="\images\pasted-140.png" alt="upload successful"><br>链接：<a href="https://www.nowcoder.com/questionTerminal/25c5ed98b19b4df4aecfedcc11bee913" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/25c5ed98b19b4df4aecfedcc11bee913</a><br>来源：牛客网</p>
<p>1.getColor()  var getColor = test4399.getColor;</p>
<p>即var getColor = function(){var color = “red”;alert(this.color);};</p>
<p>执行getColor()函数时this指向的window，因为window.color为green，所以弹出green</p>
<p>2.test4399.getColor(),此时this指向的是test4399，test4399.color为blue，所以弹出blue</p>
<p>来自<a href="https://m.jb51.net/article/24101.htm" target="_blank" rel="noopener">https://m.jb51.net/article/24101.htm</a></p>
<p>javascript深入理解js闭包</p>
<p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<h2 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<p>Js代码<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">　　　　alert(n);</span></span></span><br><span class="line"><span class="function"><span class="comment">　　&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">f1</span><span class="params">()</span>;</span> <span class="comment">// 999</span></span><br></pre></td></tr></table></figure></p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<p>Js代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<p>Js代码<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">　　　　n=999;</span></span></span><br><span class="line"><span class="function"><span class="comment">　　&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">f1</span><span class="params">()</span>;</span></span><br><span class="line"></span><br><span class="line">　　alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h2><p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<p>Js代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　　　　　alert(n); <span class="comment">// 999</span></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），</p>
<p>子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<p>Js代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h2><p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h2><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<p>Js代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个</p>
<p>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h2 id="五、使用闭包的注意点"><a href="#五、使用闭包的注意点" class="headerlink" title="五、使用闭包的注意点"></a>五、使用闭包的注意点</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便</p>
<p>改变父函数内部变量的值。</p>
<hr>
<h2 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h2><p>如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。</p>
<p>Js代码<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">var</span> name = <span class="string">"The Window"</span>;   </span><br><span class="line">　　<span class="keyword">var</span> object = &#123;   </span><br><span class="line">　　　　name : <span class="string">"My Object"</span>,   </span><br><span class="line">　　　　getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;   </span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;   </span><br><span class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;   </span><br><span class="line">　　　　　&#125;;   </span><br><span class="line">　　　　&#125;   </span><br><span class="line">&#125;;   </span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">//The Window</span></span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">JavaScript闭包例子</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   a++;</span><br><span class="line">   alert(a);</span><br><span class="line">  &#125;    </span><br><span class="line"> &#125;</span><br><span class="line">innerFun()</span><br></pre></td></tr></table></figure>
<p>上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的.</p>
<p>改成如下,也就是闭包:</p>
<p>Js代码</p>
<p>function outerFun()<br>{<br> var a=0;<br> function innerFun()<br> {<br>  a++;<br>  alert(a);<br> }<br> return innerFun;  //注意这里<br>}<br>var obj=outerFun();<br>obj();  //结果为1<br>obj();  //结果为2<br>var obj2=outerFun();<br>obj2();  //结果为1<br>obj2();  //结果为2</p>
<p>什么是闭包:</p>
<p>当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们.</p>
<hr>
<p>再来看一个例子</p>
<p>Js代码<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">function outerFun()</span><br><span class="line">&#123;</span><br><span class="line"> var a =<span class="number">0</span><span class="comment">;</span></span><br><span class="line"> alert(a)<span class="comment">;  </span></span><br><span class="line">&#125;</span><br><span class="line">var a=<span class="number">4</span><span class="comment">;</span></span><br><span class="line">outerFun()<span class="comment">;</span></span><br><span class="line">alert(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>结果是 0,4 .  因为在函数内部使用了var关键字 维护a的作用域在outFun()内部.</p>
<p>再看下面的代码:</p>
<p>Js代码<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">function outerFun()</span><br><span class="line">&#123;</span><br><span class="line"> //没有var </span><br><span class="line"> a =<span class="number">0</span><span class="comment">;</span></span><br><span class="line"> alert(a)<span class="comment">;  </span></span><br><span class="line">&#125;</span><br><span class="line">var a=<span class="number">4</span><span class="comment">;</span></span><br><span class="line">outerFun()<span class="comment">;</span></span><br><span class="line">alert(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>结果为 0,0 真是奇怪,为什么呢?</p>
<p>作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4;  并改变其值.</p>
<hr>
<p>如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:<a href="http://www.felixwoo.com/archives/247" target="_blank" rel="noopener">http://www.felixwoo.com/archives/247</a>)</p>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：</p>
<p>function a() {<br> var i = 0;<br> function b() { alert(++i); }<br> return b;<br>}<br>var c = a();<br>c();<br>这段代码有两个特点：</p>
<p>1、函数b嵌套在函数a内部；</p>
<p>2、函数a返回函数b。</p>
<p>引用关系如图：</p>
<p>　　这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：</p>
<p>　　当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</p>
<p>　　让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。</p>
<h2 id="闭包有什么作用？"><a href="#闭包有什么作用？" class="headerlink" title="闭包有什么作用？"></a>闭包有什么作用？</h2><p>　　简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。</p>
<p>在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。</p>
<p>　　那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍)</p>
<h2 id="闭包内的微观世界"><a href="#闭包内的微观世界" class="headerlink" title="闭包内的微观世界"></a>闭包内的微观世界</h2><p>　　如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。</p>
<p>当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。<br>当执行函数a的时候，a会进入相应的执行环境(excution context)。<br>在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。<br>然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。<br>下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。<br>最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。<br>到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。</p>
<p>当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：</p>
<p>如图所示，当在函数b中访问一个变量的时候，搜索顺序是：</p>
<p>先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。<br>如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。<br>如果整个作用域链上都无法找到，则返回undefined。<br>小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> h = f(<span class="number">1</span>);</span><br><span class="line">alert(h());</span><br></pre></td></tr></table></figure></p>
<p>这段代码中变量h指向了f中的那个匿名函数(由g返回)。</p>
<p>假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。<br>假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。<br>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。</p>
<p>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p>
<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><p>保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。</p>
<p>在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。<br>通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）<br>私有属性和方法在Constructor外是无法被访问的<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function <span class="type">Constructor</span>(...) &#123;  </span><br><span class="line">  <span class="keyword">var</span> that = this;  </span><br><span class="line">  <span class="keyword">var</span> membername = value; </span><br><span class="line">  function membername(...) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上3点是闭包最基本的应用场景，很多经典案例都源于此。</p>
<h2 id="Javascript的垃圾回收机制"><a href="#Javascript的垃圾回收机制" class="headerlink" title="Javascript的垃圾回收机制"></a>Javascript的垃圾回收机制</h2><p>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><a href="https://blog.csdn.net/qq_36996271/article/details/82527256" target="_blank" rel="noopener">https://blog.csdn.net/qq_36996271/article/details/82527256</a></p>
<p>Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。<br>prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。</p>
<p>prototype就是调用构造函数所创建的那个实例对象的原型（proto）。</p>
<p>prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。</p>
<p><img src="\images\pasted-141.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】Redis</title>
    <url>/2020/04/14/%E7%B4%AF%E3%80%91Redis/</url>
    <content><![CDATA[<h2 id="Redis实际应用场景"><a href="#Redis实际应用场景" class="headerlink" title="Redis实际应用场景"></a>Redis实际应用场景</h2><p><img src="\images\pasted-30.png" alt="upload successful"><br><a id="more"></a></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。<br>string类型是Redis最基本的数据类型，一个键最大能存储512MB，string类型是二进制安全的。所以redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>应用场景：<br>string 类型是 Redis 中最基本的数据类型，最常用的数据类型，甚至被很多玩家当成 redis 唯一的数据类型去使用。string 类型在 redis 中是二进制安全(binary safe)的,这意味着 string 值关心二进制的字符串，不关心具体格式，你可以用它存储 json 格式或 JPEG 图片格式的字符串。 </p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>1、Redis hash是一个键值(key =&gt; value)对集合,是一个string类型的field和value的映射表<br>2、hash特别适合用于存储对象。<br>3、存储部分变更的数据，如用户信息等。<br>应用场景：如要存储一个用户信息对象数据，包含以下信息：<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p>
<p>应用场景：<br>hash 类型十分适合存储对象类数据，相对于在 string 中介绍的把对象转化为 json 字符串存储，hash 的结构可以任意添加或删除‘字段名’，更加高效灵活。<br>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。<br><img src="\images\pasted-27.png" alt="upload successful"></p>
<p>第二种方法是这个用户信息对象有多少成员就存成多少个key-value，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。<br><img src="\images\pasted-28.png" alt="upload successful"><br>Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图：</p>
<p><img src="\images\pasted-29.png" alt="upload successful"><br>Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题，很好的解决了问题。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。</p>
<p>消息队列：可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。使用sorted set甚至可以构建有优先级的队列系统。 </p>
<p>Redis提供了操作List中某一段的api，可以直接查询，删除List中某一段的元素。 </p>
<p>例子：将Redis用作日志收集器，实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。</p>
<p>取最新N个数据的操作<br><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">//把当前登录人添加到链表里</span><br><span class="line">ret = r.lpush(<span class="string">"login:last_login_times"</span>, uid)</span><br><span class="line">//保持链表只有N位</span><br><span class="line">ret = redis.ltrim(<span class="string">"login:last_login_times"</span>, <span class="number">0</span>, N<span class="number">-1</span>)</span><br><span class="line">//获得前N个最新登陆的用户Id列表</span><br><span class="line">last_login_list = r.<span class="keyword">lrange</span>(<span class="string">"login:last_login_times"</span>, <span class="number">0</span>, N<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<p>比如sina微博:<br>在Redis中最新微博ID使用了常驻缓存，这是一直更新的。但是做了限制不能超过5000个ID，因此获取ID的函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。<br>系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p>
<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>集合，集合的概念就是一堆不重复值的组合。set中的元素是没有顺序的。<br>案例：<br>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。<br>交集，并集，差集</p>
<p>//book表存储book名称<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> book:1:name <span class="comment">"The Ruby Programming Language"</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">book:2:name</span> <span class="comment">"Ruby on rail"</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">book:3:name</span> <span class="comment">"Programming Erlang"</span></span><br><span class="line"><span class="comment">//tag表使用集合来存储数据，因为集合擅长求交集、并集</span></span><br><span class="line">sadd <span class="comment">tag:ruby 1</span></span><br><span class="line">sadd <span class="comment">tag:ruby 2</span></span><br><span class="line">sadd <span class="comment">tag:web 2</span></span><br><span class="line">sadd <span class="comment">tag:erlang 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即属于ruby又属于web的书？</span></span><br><span class="line"> inter_list <span class="comment">= redis.sinter(</span><span class="comment">"tag:web"</span><span class="comment">,</span> <span class="comment">"tag:ruby"</span><span class="comment">)</span></span><br><span class="line"><span class="comment">//即属于ruby，但不属于web的书？</span></span><br><span class="line"> diff_list <span class="comment">= redis.sdiff(</span><span class="comment">"tag:ruby"</span><span class="comment">,</span> <span class="comment">"tag:web"</span><span class="comment">)</span></span><br><span class="line"><span class="comment">//属于ruby和属于web的书的合集？</span></span><br><span class="line"> union_list <span class="comment">= redis.sunion(</span><span class="comment">"tag:ruby"</span><span class="comment">,</span> <span class="comment">"tag:web"</span><span class="comment">)</span></span><br></pre></td></tr></table></figure></p>
<p>获取某段时间所有数据去重值<br>只需要不断地将数据往set中扔就行了，set为集合，所以会自动排重。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。<br>排行榜应用，取TOP N操作<br>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将登录次数和用户统一存储在一个sorted set里</span></span><br><span class="line">zadd <span class="string">login:</span>login_times <span class="number">5</span> <span class="number">1</span></span><br><span class="line">zadd <span class="string">login:</span>login_times <span class="number">1</span> <span class="number">2</span></span><br><span class="line">zadd <span class="string">login:</span>login_times <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当用户登录时，对该用户的登录次数自增1</span></span><br><span class="line">ret = r.zincrby(<span class="string">"login:login_times"</span>, <span class="number">1</span>, uid)</span><br><span class="line"><span class="comment">//那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户</span></span><br><span class="line">ret = r.zrevrange(<span class="string">"login:login_times"</span>, <span class="number">0</span>, N<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<p>比如在线游戏的排行榜，根据得分你通常想要：</p>
<ul>
<li>列出前100名高分选手</li>
<li>列出某用户当前的全球排名</li>
</ul>
<p>这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。<br>模式是这样的，每次获得新得分时，我们用这样的代码：<br>ZADD leaderboard <score> <username></username></score></p>
<p>你可能用userID来取代username，这取决于你是怎么设计的。<br>得到前100名高分用户很简单：<br>ZREVRANGE leaderboard 0 99</p>
<p>用户的全球排名也相似，只需要：<br>ZRANK leaderboard <username></username></p>
<p>需要精准设定过期时间的应用 </p>
<p>比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。<br>范围查找<br>来自Redis在Google Group上的一个问题，有一位同学发贴求助，说要解决如下的一个问题：他有一个IP范围对应地址的列表，现在需要给出一个IP的情况下，迅速的查找到这个IP在哪个范围，也就是要判断此IP的所有地。</p>
<h2 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h2><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。<br>使用场景<br>Pub/Sub构建实时消息系统<br>Redis的Pub/Sub系统可以构建实时的消息系统<br>比如很多用Pub/Sub构建的实时聊天系统的例子。</p>
<h2 id="redis单机架构模式"><a href="#redis单机架构模式" class="headerlink" title="redis单机架构模式"></a>redis单机架构模式</h2><p>特点：简单<br>问题：<br>1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<h2 id="redis主从复制架构模式"><a href="#redis主从复制架构模式" class="headerlink" title="redis主从复制架构模式"></a>redis主从复制架构模式</h2><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：<br>1、master/slave 角色<br>2、master/slave 数据相同<br>3、降低 master 读压力在转交从库</p>
<p>问题：<br>无法保证高可用<br>没有解决 master 写的压力</p>
<h2 id="哨兵架构模式"><a href="#哨兵架构模式" class="headerlink" title="哨兵架构模式"></a>哨兵架构模式</h2><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：<br>1、监控（Monitoring）：Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。<br>2、提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br>3、自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
<p>特点：<br>1、保证高可用<br>2、监控各个节点<br>3、自动故障迁移<br>缺点：主从模式，切换需要时间丢数据<br>没有解决 master 写的压力</p>
<h2 id="集群（proxy-型）架构模式"><a href="#集群（proxy-型）架构模式" class="headerlink" title="集群（proxy 型）架构模式"></a>集群（proxy 型）架构模式</h2><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。<br>特点：<br>1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins<br>2、支持失败节点自动删除<br>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致<br>缺点：增加了新的 proxy，需要维护其高可用。<br>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p>
<h2 id="集群（直连型）架构模式"><a href="#集群（直连型）架构模式" class="headerlink" title="集群（直连型）架构模式"></a>集群（直连型）架构模式</h2><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：<br>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。<br>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。<br>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。<br>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本<br>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：<br>1、资源隔离性较差，容易出现相互影响的情况。<br>2、数据通过异步复制,不保证数据的强一致性</p>
<h2 id="什么是Redis？简述它的优缺点？"><a href="#什么是Redis？简述它的优缺点？" class="headerlink" title="什么是Redis？简述它的优缺点？"></a>什么是Redis？简述它的优缺点？</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。<br>两种持久化方式:RDB（默认） 和AOF<br>RDB：<br>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br>AOF:<br>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<p>RDB存在哪些优势呢？<br>1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。<br>2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。<br>3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。<br>4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。<br>RDB又存在哪些劣势呢？<br>1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。<br>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>AOF的优势有哪些呢？<br>1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。<br>2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。<br>3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。<br>4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。<br>AOF的劣势有哪些呢？<br>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。<br>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构:"></a>存储结构:</h2><p>内容是redis通讯协议(RESP )格式的命令文本存储。<br>比较：<br>1、aof文件比rdb更新频率高，优先使用aof还原数据。<br>2、aof比rdb更安全也更大<br>3、rdb性能比aof好<br>4、如果两个都配了优先加载AOF</p>
<h2 id="resp"><a href="#resp" class="headerlink" title="resp"></a>resp</h2><p><a href="https://www.cnblogs.com/tommy-huang/p/6051577.html" target="_blank" rel="noopener">https://www.cnblogs.com/tommy-huang/p/6051577.html</a><br>RESP 是redis客户端和服务端之间使用的一种通讯协议；<br>RESP 的特点：实现简单、快速解析、可读性好<br>For Simple Strings the first byte of the reply is “+” 回复<br>For Errors the first byte of the reply is “-“ 错误<br>For Integers the first byte of the reply is “:” 整数<br>For Bulk Strings the first byte of the reply is “$” 字符串<br>For Arrays the first byte of the reply is “*” 数组</p>
<h2 id="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h2><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。<br>缺点：<br>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<h2 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h2><p>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>如何避免？<br>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期<br>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<h2 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h2><p>（1）会话缓存（Session Cache）<br>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p>
<p>（2）全页缓存（FPC）<br>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>（3）队列<br>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p>
<p>（4）排行榜/计数器<br>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORESAgora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p>
<p>（5）发布/订阅<br>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p>
<h2 id="Redis如何设置密码及验证密码？"><a href="#Redis如何设置密码及验证密码？" class="headerlink" title="Redis如何设置密码及验证密码？"></a>Redis如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456</p>
<p>授权密码：auth 123456</p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？<br>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h2 id="怎么测试Redis的连通性？"><a href="#怎么测试Redis的连通性？" class="headerlink" title="怎么测试Redis的连通性？"></a>怎么测试Redis的连通性？</h2><p>ping</p>
<h2 id="Redis中的管道有什么用？"><a href="#Redis中的管道有什么用？" class="headerlink" title="Redis中的管道有什么用？"></a>Redis中的管道有什么用？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<h2 id="怎么理解Redis事务？"><a href="#怎么理解Redis事务？" class="headerlink" title="怎么理解Redis事务？"></a>怎么理解Redis事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h2 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h2><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h2 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h2><p>一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h2><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h2 id="Redis集群方案什么情况下会导致整个集群不可用？"><a href="#Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis集群方案什么情况下会导致整个集群不可用？"></a>Redis集群方案什么情况下会导致整个集群不可用？</h2><p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<h2 id="Redis集群方案应该怎么做？"><a href="#Redis集群方案应该怎么做？" class="headerlink" title="Redis集群方案应该怎么做？"></a>Redis集群方案应该怎么做？</h2><p>都有哪些方案？1.codis。目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<h2 id="Redis有哪几种数据淘汰策略？"><a href="#Redis有哪几种数据淘汰策略？" class="headerlink" title="Redis有哪几种数据淘汰策略？"></a>Redis有哪几种数据淘汰策略？</h2><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。allkeys-random: 回收随机的键使得新添加的数据有空间存放。volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】数据结构</title>
    <url>/2020/04/14/%E7%B4%AF%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="排序算法时间复杂度空间复杂度"><a href="#排序算法时间复杂度空间复杂度" class="headerlink" title="排序算法时间复杂度空间复杂度"></a>排序算法时间复杂度空间复杂度</h2><p><img src="/images/pasted-2.png" alt><br>注：<br>1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，<br>2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。</p>
<p>相关概念：<br>1、时间复杂度<br>     时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>     常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)<br>     时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),<br>2、空间复杂度<br>    空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数<br>    空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)<br>    空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)<br>                                 ax=N，则x=logaN，<br>    空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ol>
<li><p>顺序查找<br>　　说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。<br>　　基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。<br>　　复杂度分析：　<br>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);<br>　　所以，顺序查找的时间复杂度为O(n)。</p>
</li>
<li><p>二分查找<br>　　说明：元素必须是有序的，如果是无序的则要先进行排序操作。<br>　　基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。<br>　　复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；<br>　　注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/二分查找（折半查找），版本<span class="number">1</span></span><br><span class="line">int BinarySearch1(int a[], int value, int n)</span><br><span class="line">   &#123;</span><br><span class="line">     int low, high, mid;</span><br><span class="line">     low = <span class="number">0</span>;</span><br><span class="line">     high = n<span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">     &#123;</span><br><span class="line">       mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">         high = mid<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">         low = mid+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line">int BinarySearch2(int a[], int value, int low, int high)</span><br><span class="line">  &#123;</span><br><span class="line">     int mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">     <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>插值查找<br>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？<br>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。<br>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。<br>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：<br>　　mid=(low+high)/2, 即mid=low+1/2<em>(high-low);<br>　　通过类比，我们可以将查找的点改进为如下：<br>　　mid=low+(key-a[low])/(a[high]-a[low])</em>(high-low)，<br>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。<br>　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br>　　注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。<br>　　复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。<br>　　C++实现源码：<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2>来自二叉排序树的旋转<br>为了保证树不至于台倾斜，尽量保证两边平衡。<br>1、平衡二叉树要么是一棵空树<br>2、要么保证左右子树的高度之差不大于 1<br>3、子树也必须是一颗平衡二叉树<br>平衡二叉树在添加和删除时需要进行旋转保证整个树的平衡，使用平衡二叉树时，插入、查找时间复杂度都是O(logn)<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2>完全二叉树：对于一个树高为h的二叉树，如果其第0层至第h-1层的节点都满。如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。这样的二叉树就是一棵完全二叉树。<br>完全二叉树最重要的性质：如果n个节点的完全二叉树的节点按照层次并按从左到右的顺序从0开始编号，对于人一个绩点都有：</li>
</ol>
<p>·序号为0的节点是根<br>·对于i&gt;0，其父节点的编号为(i-1)/2。<br>·若2i+1&lt;n，其左子节点的序号为2i+1，否则没有左子节点。<br>·若2i+2&lt;n，其右子节点的序号为2i+2，否则没有右子节点。</p>
<p><img src="\images\pasted-39.png" alt="upload successful"></p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树：树中每个分支结点（非叶结点）都有两棵非空子树</p>
<p><img src="\images\pasted-40.png" alt="upload successful"><br>使二叉树可以方便的存入表或者数组，直接根绝元素下标就可以找到一个节点的子节点或者父节点(也就是可以完全确定二叉树的结构)，无须用额外的形式记录树结构信息。<br>使其可以方便地存入一系列连续位置，一般二叉树不能方便地映射到线性结构，完全二叉树到线性结构有定义非常自然的双向映射，可以方便地从其线性结构恢复完全二叉树。</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；</p>
<p><img src="\images\pasted-41.png" alt="upload successful"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>为什么说B+树比B树更适合数据库索引？<br>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<p><img src="\images\pasted-42.png" alt="upload successful"><br>节点中有重复元素，而且叶子节点还用指针连在一起<br>每一个父节点的元素都出现在子节点中，是子节点的最大（或最小元素）</p>
<p><img src="\images\pasted-43.png" alt="upload successful"><br>根节点元素8是子节点2,5,8的最大元素，也是子节点6,8的最大元素<br>根节点15是11,15的最大元素，也是叶子节点13,15的最大元素</p>
<p>根节点的最大元素（15），以后无论插入删除多少元素，始终保持最大元素在根节点当中。<br>B+树的叶子节点包含了根节点的全部元素信息</p>
<p><img src="\images\pasted-44.png" alt="upload successful"><br>并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。</p>
<p>卫星数据，指的是索引元素锁指向的数据记录，不如数据库中的某一行。B-树中，无论中间节点还是叶子节点都带有卫星数据。<br><img src="\images\pasted-45.png" alt="upload successful"><br>B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联<br>在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p>
<p>B+树的查询速度为什么快<br>单元素查询中，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。<br>找3，第一次磁盘IO：</p>
<p><img src="\images\pasted-46.png" alt="upload successful"><br>第二次磁盘IO：</p>
<p><img src="\images\pasted-47.png" alt="upload successful"><br>第三次磁盘IO：</p>
<p><img src="\images\pasted-48.png" alt="upload successful"><br>B+树比B-树更加矮胖（中间节点不存卫星可以容纳更多数据），查询IO更小，更加稳定</p>
<p>B+树范围查找 只需要在链表上遍历即可，以下为查找3-11</p>
<p>自顶向下，查找到范围的下限（3）：<br><img src="\images\pasted-49.png" alt="upload successful"><br>通过链表指针，遍历到元素6, 8：</p>
<p><img src="\images\pasted-50.png" alt="upload successful"><br>通过链表指针，遍历到元素9, 11，遍历结束：</p>
<p><img src="\images\pasted-51.png" alt="upload successful"></p>
<p>B+树的特征：<br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。<br>B+树的优势：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树<br>红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。<br>二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度<br>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。</p>
<p>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p><img src="\images\pasted-52.png" alt="upload successful"></p>
<p>由于父节点22是红色节点，因此这种情况打破了红黑树的规则4，必须作出调整，两种方式：变色，旋转<br><img src="\images\pasted-53.png" alt="upload successful"></p>
<p>1、变色</p>
<p>为了符合红黑树的规则，会把节点红变黑，或者黑变红。下图节点25并非根节点，因为21和22连接出现红色，不符合规则4，所以把22红变黑<br>例子：<br><img src="\images\pasted-55.png" alt="upload successful"><br>但是这样还是不符合规则5，所以需要把25黑变红：</p>
<p><img src="\images\pasted-56.png" alt="upload successful"><br>25和27又是两个连续的红色节点（规则4），所以需要将27红变黑</p>
<p><img src="\images\pasted-57.png" alt="upload successful"><br>结束</p>
<p>左旋转</p>
<p>逆时针旋转两个节点，使父节点被自己的右孩子取代，而自己成为自己的左孩子：<br><img src="\images\pasted-58.png" alt="upload successful"></p>
<p>右旋转</p>
<p>顺时针旋转两个节点，使自己的父节点被左孩子取代，而自己成为自己的右孩子：</p>
<p><img src="\images\pasted-59.png" alt="upload successful"></p>
<p>还是以刚才的例子为例</p>
<p><img src="\images\pasted-60.png" alt="upload successful"><br>首先开始变色，把节点25及以下的节点变色</p>
<p><img src="\images\pasted-61.png" alt="upload successful"><br>由于17和25是连续的两个红色节点，那么把节点17变黑吗？这样会与规则4冲突，根据规则2也不能将13变成红色，变色已经不能解决问题了，所以只能进行旋转。13当成X，17当成Y，左旋转试试：</p>
<p><img src="\images\pasted-62.png" alt="upload successful"></p>
<p><img src="\images\pasted-63.png" alt="upload successful"></p>
<p><img src="\images\pasted-64.png" alt="upload successful"></p>
<p>由于根节点必须是黑色，所以需要变色</p>
<p><img src="\images\pasted-65.png" alt="upload successful"><br>其中有两条路径（17-6-null）的黑色节点个数不是3，不符合规则，这时需要把13当做X，8当做Y，进行右旋转；</p>
<p><img src="\images\pasted-66.png" alt="upload successful"></p>
<p><img src="\images\pasted-67.png" alt="upload successful"></p>
<p><img src="\images\pasted-68.png" alt="upload successful"><br>最后根据规则变色</p>
<p><img src="\images\pasted-69.png" alt="upload successful"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line">/**</span><br><span class="line"> * author:zhongjin</span><br><span class="line"> * time:2016/10/20 11:53</span><br><span class="line"> * description: 红黑树</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="comment">//结点</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $key;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $parent;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $left;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $right;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $IsRed;  <span class="comment">//分辨红节点或黑节点</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($key, $IsRed = TRUE)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;key = $key;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;parent = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;left = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;right = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        <span class="comment">//插入结点默认是红色</span></span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;IsRed = $IsRed;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//红黑树</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Rbt</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $root;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 初始化树结构</span><br><span class="line">     * @param $arr 初始化树结构的数组</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">($arr)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//根节点必须是黑色</span></span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;root = <span class="keyword">new</span> Node($arr[<span class="number">0</span>], <span class="keyword">FALSE</span>);</span></span><br><span class="line"><span class="php">        <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; count($arr); $i++) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;Insert($arr[$i]);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * （对内）中序遍历</span><br><span class="line">     * @param $root （树或子树的）根节点</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">mid_order</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($root != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;mid_order($root-&gt;left);</span></span><br><span class="line"><span class="php">            <span class="keyword">echo</span> $root-&gt;key . <span class="string">"-"</span> . ($root-&gt;IsRed ? <span class="string">'r'</span> : <span class="string">'b'</span>) . <span class="string">'  '</span>;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;mid_order($root-&gt;right);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * （对外）中序遍历</span><br><span class="line">     * @param null</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MidOrder</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;mid_order(<span class="keyword">$this</span>-&gt;root);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 查找树中是否存在$key对应的节点</span><br><span class="line">     * @param $key 待搜索数字</span><br><span class="line">     * @return $key对应的节点</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">($key)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $current = <span class="keyword">$this</span>-&gt;root;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($current != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> ($current-&gt;key == $key) &#123;</span></span><br><span class="line"><span class="php">                <span class="keyword">return</span> $current;</span></span><br><span class="line"><span class="php">            &#125; <span class="keyword">elseif</span> ($current-&gt;key &gt; $key) &#123;</span></span><br><span class="line"><span class="php">                $current = $current-&gt;left;</span></span><br><span class="line"><span class="php">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                $current = $current-&gt;right;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="comment">//结点不存在</span></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $current;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 将以$root为根节点的最小不平衡二叉树做右旋处理</span><br><span class="line">     * @param $root（树或子树）根节点</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">R_Rotate</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $L = $root-&gt;left;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!is_null($root-&gt;parent)) &#123;</span></span><br><span class="line"><span class="php">            $P = $root-&gt;parent;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($root == $P-&gt;left)&#123;</span></span><br><span class="line"><span class="php">                $P-&gt;left = $L;</span></span><br><span class="line"><span class="php">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">                $P-&gt;right = $L;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">            $L-&gt;parent = $P;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">            $L-&gt;parent = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $root-&gt;parent = $L;</span></span><br><span class="line"><span class="php">        $root-&gt;left = $L-&gt;right;</span></span><br><span class="line"><span class="php">        $L-&gt;right = $root;</span></span><br><span class="line"><span class="php">        <span class="comment">//这句必须啊！</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($L-&gt;parent == <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root = $L;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 将以$root为根节点的最小不平衡二叉树做左旋处理</span><br><span class="line">     * @param $root（树或子树）根节点</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">L_Rotate</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $R = $root-&gt;right;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!is_null($root-&gt;parent)) &#123;</span></span><br><span class="line"><span class="php">            $P = $root-&gt;parent;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($root == $P-&gt;right)&#123;</span></span><br><span class="line"><span class="php">                $P-&gt;right = $R;</span></span><br><span class="line"><span class="php">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">                $P-&gt;left = $R;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">            $R-&gt;parent = $P;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">            $R-&gt;parent = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $root-&gt;parent = $R;</span></span><br><span class="line"><span class="php">        $root-&gt;right = $R-&gt;left;</span></span><br><span class="line"><span class="php">        $R-&gt;left = $root;</span></span><br><span class="line"><span class="php">        <span class="comment">//这句必须啊！</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($R-&gt;parent == <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root = $R;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 查找树中的最小关键字</span><br><span class="line">     * @param $root 根节点</span><br><span class="line">     * @return 最小关键字对应的节点</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">search_min</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $current = $root;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($current-&gt;left != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            $current = $current-&gt;left;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $current;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 查找树中的最大关键字</span><br><span class="line">     * @param $root 根节点</span><br><span class="line">     * @return 最大关键字对应的节点</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">search_max</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $current = $root;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($current-&gt;right != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            $current = $current-&gt;right;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $current;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 查找某个$key在中序遍历时的直接前驱节点</span><br><span class="line">     * @param $x 待查找前驱节点的节点引用</span><br><span class="line">     * @return 前驱节点引用</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">predecessor</span><span class="params">($x)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//左子节点存在，直接返回左子节点的最右子节点</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($x-&gt;left != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;search_max($x-&gt;left);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="comment">//否则查找其父节点，直到当前结点位于父节点的右边</span></span></span><br><span class="line"><span class="php">        $p = $x-&gt;parent;</span></span><br><span class="line"><span class="php">        <span class="comment">//如果x是p的左孩子，说明p是x的后继，我们需要找的是p是x的前驱</span></span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($p != <span class="keyword">NULL</span> &amp;&amp; $x == $p-&gt;left) &#123;</span></span><br><span class="line"><span class="php">            $x = $p;</span></span><br><span class="line"><span class="php">            $p = $p-&gt;parent;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $p;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 查找某个$key在中序遍历时的直接后继节点</span><br><span class="line">     * @param $x 待查找后继节点的节点引用</span><br><span class="line">     * @return 后继节点引用</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">successor</span><span class="params">($x)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($x-&gt;left != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;search_min($x-&gt;right);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $p = $x-&gt;parent;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($p != <span class="keyword">NULL</span> &amp;&amp; $x == $p-&gt;right) &#123;</span></span><br><span class="line"><span class="php">            $x = $p;</span></span><br><span class="line"><span class="php">            $p = $p-&gt;parent;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $p;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 将$key插入树中</span><br><span class="line">     * @param $key 待插入树的数字</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Insert</span><span class="params">($key)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!is_null(<span class="keyword">$this</span>-&gt;search($key))) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'结点'</span> . $key . <span class="string">'已存在，不可插入！'</span>);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $root = <span class="keyword">$this</span>-&gt;root;</span></span><br><span class="line"><span class="php">        $inode = <span class="keyword">new</span> Node($key);</span></span><br><span class="line"><span class="php">        $current = $root;</span></span><br><span class="line"><span class="php">        $prenode = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">        <span class="comment">//为$inode找到合适的插入位置</span></span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($current != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            $prenode = $current;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> ($current-&gt;key &gt; $inode-&gt;key) &#123;</span></span><br><span class="line"><span class="php">                $current = $current-&gt;left;</span></span><br><span class="line"><span class="php">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                $current = $current-&gt;right;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        $inode-&gt;parent = $prenode;</span></span><br><span class="line"><span class="php">        <span class="comment">//如果$prenode == NULL， 则证明树是空树</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($prenode == <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root = $inode;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> ($inode-&gt;key &lt; $prenode-&gt;key) &#123;</span></span><br><span class="line"><span class="php">                $prenode-&gt;left = $inode;</span></span><br><span class="line"><span class="php">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                $prenode-&gt;right = $inode;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//将它重新修正为一颗红黑树</span></span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;InsertFixUp($inode);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 对插入节点的位置及往上的位置进行颜色调整</span><br><span class="line">     * @param $inode 插入的节点</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">InsertFixUp</span><span class="params">($inode)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//情况一：需要调整条件，父节点存在且父节点的颜色是红色</span></span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> (($parent = $inode-&gt;parent) != <span class="keyword">NULL</span> &amp;&amp; $parent-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="comment">//祖父结点：</span></span></span><br><span class="line"><span class="php">            $gparent = $parent-&gt;parent;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">            <span class="comment">//如果父节点是祖父结点的左子结点，下面的else与此相反</span></span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> ($parent == $gparent-&gt;left) &#123;</span></span><br><span class="line"><span class="php">                <span class="comment">//叔叔结点</span></span></span><br><span class="line"><span class="php">                $uncle = $gparent-&gt;right;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case1:叔叔结点也是红色</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($uncle != <span class="keyword">NULL</span> &amp;&amp; $uncle-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//将父节点和叔叔结点都涂黑，将祖父结点涂红</span></span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $uncle-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $gparent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    <span class="comment">//将新节点指向祖父节点（现在祖父结点变红，可以看作新节点存在）</span></span></span><br><span class="line"><span class="php">                    $inode = $gparent;</span></span><br><span class="line"><span class="php">                    <span class="comment">//继续while循环，重新判断</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">continue</span>;   <span class="comment">//经过这一步之后，组父节点作为新节点存在（跳到case2）</span></span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case2:叔叔结点是黑色，且当前结点是右子节点</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($inode == $parent-&gt;right) &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//以父节点作为旋转结点做左旋转处理</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;L_Rotate($parent);</span></span><br><span class="line"><span class="php">                    <span class="comment">//在树中实际上已经转换，但是这里的变量的指向还没交换，</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将父节点和字节调换一下，为下面右旋做准备</span></span></span><br><span class="line"><span class="php">                    $temp = $parent;</span></span><br><span class="line"><span class="php">                    $parent = $inode;</span></span><br><span class="line"><span class="php">                    $inode = $temp;</span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case3:叔叔结点是黑色，而且当前结点是父节点的左子节点</span></span></span><br><span class="line"><span class="php">                $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                $gparent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                <span class="keyword">$this</span>-&gt;R_Rotate($gparent);</span></span><br><span class="line"><span class="php">            &#125; <span class="comment">//如果父节点是祖父结点的右子结点，与上面完全相反</span></span></span><br><span class="line"><span class="php">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                <span class="comment">//叔叔结点</span></span></span><br><span class="line"><span class="php">                $uncle = $gparent-&gt;left;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case1:叔叔结点也是红色</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($uncle != <span class="keyword">NULL</span> &amp;&amp; $uncle-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//将父节点和叔叔结点都涂黑，将祖父结点涂红</span></span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $uncle-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $gparent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    <span class="comment">//将新节点指向祖父节点（现在祖父结点变红，可以看作新节点存在）</span></span></span><br><span class="line"><span class="php">                    $inode = $gparent;</span></span><br><span class="line"><span class="php">                    <span class="comment">//继续while循环，重新判断</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">continue</span>;   <span class="comment">//经过这一步之后，组父节点作为新节点存在（跳到case2）</span></span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case2:叔叔结点是黑色，且当前结点是左子节点</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($inode == $parent-&gt;left) &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//以父节点作为旋转结点做右旋转处理</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;R_Rotate($parent);</span></span><br><span class="line"><span class="php">                    <span class="comment">//在树中实际上已经转换，但是这里的变量的指向还没交换，</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将父节点和字节调换一下，为下面右旋做准备</span></span></span><br><span class="line"><span class="php">                    $temp = $parent;</span></span><br><span class="line"><span class="php">                    $parent = $inode;</span></span><br><span class="line"><span class="php">                    $inode = $temp;</span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case3:叔叔结点是黑色，而且当前结点是父节点的右子节点</span></span></span><br><span class="line"><span class="php">                $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                $gparent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                <span class="keyword">$this</span>-&gt;L_Rotate($gparent);</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="comment">//情况二：原树是根节点（父节点为空），则只需将根节点涂黑</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($inode == <span class="keyword">$this</span>-&gt;root) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//情况三：插入节点的父节点是黑色，则什么也不用做</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($inode-&gt;parent != <span class="keyword">NULL</span> &amp;&amp; $inode-&gt;parent-&gt;IsRed == <span class="keyword">FALSE</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * （对外）删除指定节点</span><br><span class="line">     * @param $key 删除节点的key值</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">Delete</span><span class="params">($key)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;search($key))) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'结点'</span> . $key . <span class="string">"不存在，删除失败！"</span>);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $dnode = <span class="keyword">$this</span>-&gt;search($key);</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($dnode-&gt;left == <span class="keyword">NULL</span> || $dnode-&gt;right == <span class="keyword">NULL</span>) &#123; <span class="comment">#如果待删除结点无子节点或只有一个子节点，则c = dnode</span></span></span><br><span class="line"><span class="php">            $c = $dnode;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123; <span class="comment">#如果待删除结点有两个子节点，c置为dnode的直接后继，以待最后将待删除结点的值换为其后继的值</span></span></span><br><span class="line"><span class="php">            $c = <span class="keyword">$this</span>-&gt;successor($dnode);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//为了后面颜色处理做准备</span></span></span><br><span class="line"><span class="php">        $parent = $c-&gt;parent;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//无论前面情况如何，到最后c只剩下一边子结点</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($c-&gt;left != <span class="keyword">NULL</span>) &#123;    <span class="comment">//这里不会出现，除非选择的是删除结点的前驱</span></span></span><br><span class="line"><span class="php">            $s = $c-&gt;left;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">            $s = $c-&gt;right;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($s != <span class="keyword">NULL</span>) &#123; <span class="comment">#将c的子节点的父母结点置为c的父母结点，此处c只可能有1个子节点，因为如果c有两个子节点，则c不可能是dnode的直接后继</span></span></span><br><span class="line"><span class="php">            $s-&gt;parent = $c-&gt;parent;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($c-&gt;parent == <span class="keyword">NULL</span>) &#123; <span class="comment">#如果c的父母为空，说明c=dnode是根节点，删除根节点后直接将根节点置为根节点的子节点，此处dnode是根节点，且拥有两个子节点，则c是dnode的后继结点，c的父母就不会为空，就不会进入这个if</span></span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root = $s;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($c == $c-&gt;parent-&gt;left) &#123; <span class="comment">#如果c是其父节点的左右子节点，则将c父母的左右子节点置为c的左右子节点</span></span></span><br><span class="line"><span class="php">            $c-&gt;parent-&gt;left = $s;</span></span><br><span class="line"><span class="php">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">            $c-&gt;parent-&gt;right = $s;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        $dnode-&gt;key = $c-&gt;key;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        $node = $s;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//c的结点颜色是黑色，那么会影响路径上的黑色结点的数量，必须进行调整</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($c-&gt;IsRed == <span class="keyword">FALSE</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;DeleteFixUp($node,$parent);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 删除节点后对接点周围的其他节点进行调整</span><br><span class="line">     * @param $key 删除节点的子节点和父节点</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">DeleteFixUp</span><span class="params">($node,$parent)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//如果待删结点的子节点为红色，直接将子节点涂黑</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($node != <span class="keyword">NULL</span> &amp;&amp; $node-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">            $node-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">//如果是根节点，那就直接将根节点置为黑色即可</span></span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> (($node == <span class="keyword">NULL</span> || $node-&gt;IsRed == <span class="keyword">FALSE</span>) &amp;&amp; ($node != <span class="keyword">$this</span>-&gt;root)) &#123;</span></span><br><span class="line"><span class="php">            <span class="comment">//node是父节点的左子节点，下面else与这里相反</span></span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> ($node == $parent-&gt;left) &#123;</span></span><br><span class="line"><span class="php">                $brother = $parent-&gt;right;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case1:兄弟结点颜色是红色（父节点和兄弟孩子结点都是黑色）</span></span></span><br><span class="line"><span class="php">                <span class="comment">//将父节点涂红，将兄弟结点涂黑，然后对父节点进行左旋处理（经过这一步，情况转换为兄弟结点颜色为黑色的情况）</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($brother-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;L_Rotate($parent);</span></span><br><span class="line"><span class="php">                    <span class="comment">//将情况转化为其他的情况</span></span></span><br><span class="line"><span class="php">                    $brother = $parent-&gt;right;  <span class="comment">//在左旋处理后，$parent-&gt;right指向的是原来兄弟结点的左子节点</span></span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//以下是兄弟结点为黑色的情况</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case2:兄弟结点是黑色，且兄弟结点的两个子节点都是黑色</span></span></span><br><span class="line"><span class="php">                <span class="comment">//将兄弟结点涂红，将当前结点指向其父节点，将其父节点指向当前结点的祖父结点。</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> (($brother-&gt;left == <span class="keyword">NULL</span> || $brother-&gt;left-&gt;IsRed == <span class="keyword">FALSE</span>) &amp;&amp; ($brother-&gt;right == <span class="keyword">NULL</span> || $brother-&gt;right-&gt;IsRed == <span class="keyword">FALSE</span>)) &#123;</span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    $node = $parent;</span></span><br><span class="line"><span class="php">                    $parent = $node-&gt;parent;</span></span><br><span class="line"><span class="php">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//case3:兄弟结点是黑色，兄弟结点的左子节点是红色，右子节点为黑色</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将兄弟结点涂红，将兄弟节点的左子节点涂黑，然后对兄弟结点做右旋处理（经过这一步，情况转换为兄弟结点颜色为黑色，右子节点为红色的情况）</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">if</span> ($brother-&gt;right == <span class="keyword">NULL</span> || $brother-&gt;right-&gt;IsRed == <span class="keyword">FALSE</span>) &#123;</span></span><br><span class="line"><span class="php">                        $brother-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                        $brother-&gt;left-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                        <span class="keyword">$this</span>-&gt;R_Rotate($brother);</span></span><br><span class="line"><span class="php">                        <span class="comment">//将情况转换为其他情况</span></span></span><br><span class="line"><span class="php">                        $brother = $parent-&gt;right;</span></span><br><span class="line"><span class="php">                    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                    <span class="comment">//case4:兄弟结点是黑色，且兄弟结点的右子节点为红色，左子节点为任意颜色</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将兄弟节点涂成父节点的颜色，再把父节点涂黑，将兄弟结点的右子节点涂黑，然后对父节点做左旋处理</span></span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = $parent-&gt;IsRed;</span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                    $brother-&gt;right-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;L_Rotate($parent);</span></span><br><span class="line"><span class="php">                    <span class="comment">//到了第四种情况，已经是最基本的情况了，可以直接退出了</span></span></span><br><span class="line"><span class="php">                    $node = <span class="keyword">$this</span>-&gt;root;</span></span><br><span class="line"><span class="php">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php">            &#125; <span class="comment">//node是父节点的右子节点</span></span></span><br><span class="line"><span class="php">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                $brother = $parent-&gt;left;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case1:兄弟结点颜色是红色（父节点和兄弟孩子结点都是黑色）</span></span></span><br><span class="line"><span class="php">                <span class="comment">//将父节点涂红，将兄弟结点涂黑，然后对父节点进行右旋处理（经过这一步，情况转换为兄弟结点颜色为黑色的情况）</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> ($brother-&gt;IsRed == <span class="keyword">TRUE</span>) &#123;</span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;R_Rotate($parent);</span></span><br><span class="line"><span class="php">                    <span class="comment">//将情况转化为其他的情况</span></span></span><br><span class="line"><span class="php">                    $brother = $parent-&gt;left;  <span class="comment">//在右旋处理后，$parent-&gt;left指向的是原来兄弟结点的右子节点</span></span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//以下是兄弟结点为黑色的情况</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                <span class="comment">//case2:兄弟结点是黑色，且兄弟结点的两个子节点都是黑色</span></span></span><br><span class="line"><span class="php">                <span class="comment">//将兄弟结点涂红，将当前结点指向其父节点，将其父节点指向当前结点的祖父结点。</span></span></span><br><span class="line"><span class="php">                <span class="keyword">if</span> (($brother-&gt;left == <span class="keyword">NULL</span> || $brother-&gt;left-&gt;IsRed == <span class="keyword">FALSE</span>) &amp;&amp; ($brother-&gt;right == <span class="keyword">NULL</span> || $brother-&gt;right-&gt;IsRed == <span class="keyword">FALSE</span>)) &#123;</span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                    $node = $parent;</span></span><br><span class="line"><span class="php">                    $parent = $node-&gt;parent;</span></span><br><span class="line"><span class="php">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">                    <span class="comment">//case3:兄弟结点是黑色，兄弟结点的右子节点是红色，左子节点为黑色</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将兄弟结点涂红，将兄弟节点的左子节点涂黑，然后对兄弟结点做左旋处理（经过这一步，情况转换为兄弟结点颜色为黑色，右子节点为红色的情况）</span></span></span><br><span class="line"><span class="php">                    <span class="keyword">if</span> ($brother-&gt;left == <span class="keyword">NULL</span> || $brother-&gt;left-&gt;IsRed == <span class="keyword">FALSE</span>) &#123;</span></span><br><span class="line"><span class="php">                        $brother-&gt;IsRed = <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">                        $brother-&gt;right = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                        <span class="keyword">$this</span>-&gt;L_Rotate($brother);</span></span><br><span class="line"><span class="php">                        <span class="comment">//将情况转换为其他情况</span></span></span><br><span class="line"><span class="php">                        $brother = $parent-&gt;left;</span></span><br><span class="line"><span class="php">                    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">                    <span class="comment">//case4:兄弟结点是黑色，且兄弟结点的左子节点为红色，右子节点为任意颜色</span></span></span><br><span class="line"><span class="php">                    <span class="comment">//将兄弟节点涂成父节点的颜色，再把父节点涂黑，将兄弟结点的右子节点涂黑，然后对父节点左左旋处理</span></span></span><br><span class="line"><span class="php">                    $brother-&gt;IsRed = $parent-&gt;IsRed;</span></span><br><span class="line"><span class="php">                    $parent-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    $brother-&gt;left-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">                    <span class="keyword">$this</span>-&gt;R_Rotate($parent);</span></span><br><span class="line"><span class="php">                    $node = <span class="keyword">$this</span>-&gt;root;</span></span><br><span class="line"><span class="php">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="php">                &#125;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($node != <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;root-&gt;IsRed = <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * （对内）获取树的深度</span><br><span class="line">     * @param $root 根节点</span><br><span class="line">     * @return 树的深度</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getdepth</span><span class="params">($root)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($root == <span class="keyword">NULL</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $dl = <span class="keyword">$this</span>-&gt;getdepth($root-&gt;left);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        $dr = <span class="keyword">$this</span>-&gt;getdepth($root-&gt;right);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> ($dl &gt; $dr ? $dl : $dr) + <span class="number">1</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * （对外）获取树的深度</span><br><span class="line">     * @param null</span><br><span class="line">     * @return null</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Depth</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getdepth(<span class="keyword">$this</span>-&gt;root);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】计算机网络</title>
    <url>/2020/04/14/%E7%B4%AF%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="http协议的状态码"><a href="#http协议的状态码" class="headerlink" title="http协议的状态码"></a>http协议的状态码</h2><p>5xx（服务器错误）<br>这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p>500（服务器内部错误）Internal Server Error<br>服务器遇到错误，无法完成请求。</p>
<p>501（尚未实施）Not Implemented<br>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p>502（错误网关）Bad Gateway<br>服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>503（服务不可用）Service Unavailable<br>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
<p>504（网关超时）Gateway Timeout<br>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>
<p>505（HTTP 版本不受支持）HTTP Version Not Supported<br>服务器不支持请求中所用的 HTTP 协议版本。<br>1xx（临时响应）<br>表示临时响应并需要请求者继续执行操作的状态码。</p>
<p>100（继续）continue<br>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101（切换协议）switch protocols<br>请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<p>2xx（成功）<br>表示成功处理了请求的状态码。</p>
<p>200（成功）OK<br>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br>201（已创建）Created<br>请求成功并且服务器创建了新的资源。</p>
<p>202（已接受）Accepted<br>服务器已接受请求，但尚未处理。</p>
<p>203（非授权信息）Non-Authoriative Information<br>服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>
<p>204（无内容）No Content<br>服务器成功处理了请求，但没有返回任何内容。</p>
<p>205（重置内容）Reset Content<br>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。</p>
<p>206（部分内容）Partial Content<br>服务器成功处理了部分 GET 请求。</p>
<p>3xx（重定向）<br>要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google建议您在每次请求中使用重定向不要超过5次。您可以使用网站管理员工具查看一下 Googlebot在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</p>
<p>300（多种选择）Multiple Choices<br>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>
<p>301（永久移动）Moved Permanently<br>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</p>
<p>302（临时移动）<br>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>
<p>303（查看其他位置）see other<br>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。</p>
<p>304（未修改）Not Modified<br>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br>如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>.</p>
<p>305（使用代理）Use Proxy<br>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</p>
<p>307（临时重定向）Temporary Redirect<br>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href="answer.py?answer=">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>
<p>4xx（请求错误）<br>这些状态码表示请求可能出错，妨碍了服务器的处理。</p>
<p>400（错误请求）Bad Request<br>服务器不理解请求的语法。</p>
<p>401（未授权）Unauthorized<br>请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</p>
<p>403（禁止）Forbidden<br>服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</p>
<p>404（未找到）File Not Found<br>服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。<br>如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。<br>如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。</p>
<p>405（方法禁用）Method Not Allowed<br>禁用请求中指定的方法。</p>
<p>406（不接受）Not Acceptable<br>无法使用请求的内容特性响应请求的网页。</p>
<p>407（需要代理授权）Proxy Authentication Required<br>此状态码与 <a href="answer.py?answer=35128">401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。</p>
<p>408（请求超时）Request Time-out<br>服务器等候请求时发生超时。</p>
<p>409（冲突）conflict<br>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。</p>
<p>410（已删除）Gone<br>如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。</p>
<p>411（需要有效长度）Length Required<br>服务器不接受不含有效内容长度标头字段的请求。</p>
<p>412（未满足前提条件）Precondition Failed<br>服务器未满足请求者在请求中设置的其中一个前提条件。</p>
<p>413（请求实体过大）Request Entity Too Large<br>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>
<p>414（请求的 URI 过长）Request-URL Too Large<br>请求的 URI（通常为网址）过长，服务器无法处理。</p>
<p>415（不支持的媒体类型）Unsupported Media Type<br>请求的格式不受请求页面的支持。</p>
<p>416（请求范围不符合要求）Requested range not statifiable<br>如果页面无法提供请求的范围，则服务器会返回此状态码。</p>
<p>417（未满足期望值）Expectation Failed<br>服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="get与post"><a href="#get与post" class="headerlink" title="get与post"></a>get与post</h2><p>本质：HTTP协议里两种发送请求的方法<br>1、get放在url里面 post放在body里面不可见<br>2、get请求url有限制（字符串，2k-4k） post根据php.ini设定，可以无限大<br>3、get 方式是可以缓存的，post 方式不可以缓存<br>4、后退页面反应：get无影响，post需要返回重新提交数据</p>
<p>get产生一个TCP数据包 而post产生两个：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>两次包的TCP在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
<p>建议：<br>1、get式安全性较Post式要差些包含机密信息建议用Post数据提交式；<br>2、做数据查询建议用Get式；做数据添加、修改或删除建议用Post方式；<br>百度使用的get方式，因为可以从它的URL中看出</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。<br>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。<br><a id="more"></a><br><img src="\images\pasted-12.png" alt="upload successful"></p>
<h2 id="三次握手（细）"><a href="#三次握手（细）" class="headerlink" title="三次握手（细）"></a>三次握手（细）</h2><p>1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。<br>2、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。<br>3、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。<br>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</p>
<h2 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h2><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<p><img src="\images\pasted-13.png" alt="upload successful"></p>
<h2 id="四次挥手（细）"><a href="#四次挥手（细）" class="headerlink" title="四次挥手（细）"></a>四次挥手（细）</h2><p>1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗      *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h2 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h2><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h2 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h2><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="面向连接与无连接"><a href="#面向连接与无连接" class="headerlink" title="面向连接与无连接"></a>面向连接与无连接</h2><p>TCP面向连接（如打电话要先拨号建立连接）;<br>UDP是无连接的，即发送数据之前不需要建立连接</p>
<h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h2><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
<h2 id="tcp连接一对一"><a href="#tcp连接一对一" class="headerlink" title="tcp连接一对一"></a>tcp连接一对一</h2><p>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<h2 id="占用资源"><a href="#占用资源" class="headerlink" title="占用资源"></a>占用资源</h2><p>TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<p>TCP与UDP区别总结：<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p>
<h2 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h2><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。<br>（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。<br>（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。<br>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<h2 id="TCP与UDP的适用场景"><a href="#TCP与UDP的适用场景" class="headerlink" title="TCP与UDP的适用场景"></a>TCP与UDP的适用场景</h2><p>TCP：<br>对数据传输的质量有较高要求，但对实时性要求不高。比如HTTP，HTTPS，FTP等传输文件的协议以及POP，SMTP等邮件传输的协议，应选用TCP协议。</p>
<p>UDP：<br>只对数据传输的实时性要求较高，但不对传输质量有要求。比如视频传输、实时通信等，应选用UDP协议。</p>
<h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>物理层<br>数据链路层<br>网络层<br>传输层<br>会话层<br>表示层<br>应用层</p>
<p><img src="\images\pasted-31.png" alt="upload successful"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>   OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。<br>   网际控制报文协议DHCP处于应用层</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>   表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>   会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 </p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>   传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>   本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层 "></a>数据链路层 </h2><p>   将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。<br>   交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层     "></a>物理层     </h2><p>   实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p>TCP/IP模型<br><img src="\images\pasted-32.png" alt="upload successful"></p>
<p><img src="\images\pasted-33.png" alt="upload successful"></p>
<p>地址解析协议ARP<br>完成IP地址到MAC地址的映射 即询问目标IP对应的MAC地址</p>
<p>逆地址解析协议RARP<br>完成MAC地址到IP地址的映射</p>
<p>域名解析DNS<br>完成域名到ip地址映射，使用udp传输</p>
<p>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a><br>1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。<br>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。<br>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
<h2 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h2><h2 id="缓存新特性"><a href="#缓存新特性" class="headerlink" title="缓存新特性"></a>缓存新特性</h2><p>当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活</p>
<h2 id="节约带宽-100status"><a href="#节约带宽-100status" class="headerlink" title="节约带宽(100status)"></a>节约带宽(100status)</h2><p>1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。<br>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。<br>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础</p>
<h2 id="新增错误状态响应码"><a href="#新增错误状态响应码" class="headerlink" title="新增错误状态响应码"></a>新增错误状态响应码</h2><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<h2 id="host字段"><a href="#host字段" class="headerlink" title="host字段"></a>host字段</h2><p>一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，但是HTTP1.0认为每台服务器都绑定一个唯一的IP地址。<br>web server上的多个虚拟站点可以共享同一个ip和端口。<br>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。<br>HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段)。</p>
<h2 id="请求流水线"><a href="#请求流水线" class="headerlink" title="请求流水线"></a>请求流水线</h2><p>请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。<br>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。</p>
<h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。<br>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。<br>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。<br><img src="\images\pasted-15.png" alt="upload successful"></p>
<h2 id="https不是绝对安全的"><a href="#https不是绝对安全的" class="headerlink" title="https不是绝对安全的"></a>https不是绝对安全的</h2><p>HTTPS能保证的是连接的安全<br>但https保护不了中间人攻击，这个是由不可信的用户在客户机器与服务器之间伪造一个假的站点。</p>
<h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：<br>1、多路复用，通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。<br>2、请求优先级。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。如浏览器加载首页，首页的html-静态资源文件-脚本文件等加载第一时间看到网页内容。<br>3、HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。<br>4、基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。<br>5、服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</p>
<p><img src="\images\pasted-16.png" alt="upload successful"></p>
<p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p>基于SPDY协议<br>1、采用二进制格式而非文本格式（二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少）<br>2、是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行<br>3、使用报头压缩，HTTP/2降低了开销<br>4、2.0让服务器可以将响应主动“推送”到客户端缓存中</p>
<h2 id="HTTP2-0与SPDY"><a href="#HTTP2-0与SPDY" class="headerlink" title="HTTP2.0与SPDY"></a>HTTP2.0与SPDY</h2><p>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS<br>HTTP2.0 消息头的压缩算法采用 HPACK 而非 SPDY 采用的 DEFLATE </p>
<h2 id="为什么-HTTP2-0-需要多路传输"><a href="#为什么-HTTP2-0-需要多路传输" class="headerlink" title="为什么 HTTP2.0 需要多路传输?"></a>为什么 HTTP2.0 需要多路传输?</h2><p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p>
<p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</p>
<p>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<h2 id="消息头为什么需要压缩"><a href="#消息头为什么需要压缩" class="headerlink" title="消息头为什么需要压缩?"></a>消息头为什么需要压缩?</h2><p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p>
<h2 id="多路复用与长连接复用区别"><a href="#多路复用与长连接复用区别" class="headerlink" title="多路复用与长连接复用区别"></a>多路复用与长连接复用区别</h2><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br>具体如图：</p>
<p><img src="\images\pasted-17.png" alt="upload successful"></p>
<h2 id="服务器推送到底是什么？"><a href="#服务器推送到底是什么？" class="headerlink" title="服务器推送到底是什么？"></a>服务器推送到底是什么？</h2><p>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：<br>普通的客户端请求过程：<br> <img src="\images\pasted-18.png" alt="upload successful"><br>服务端推送的过程：</p>
<p><img src="\images\pasted-19.png" alt="upload successful"></p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="\images\pasted-88.png" alt="upload successful"><br>①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持GET和POST，Spring 3.0提供了一个HiddenHttpMethodFilter，允许你通过“_method”的表单参数指定这些特殊的HTTP方法（实际上还是通过POST提交表单）。服务端配置了HiddenHttpMethodFilter后，Spring会根据_method参数指定的值模拟出相应的HTTP方法，这样，就可以使用这些HTTP方法对处理方法进行映射了。 </p>
<p>②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL，③是协议名称及版本号。 </p>
<p>④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。 </p>
<p>⑤是报文体，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。 </p>
<p>对照上面的请求报文，我们把它进一步分解，你可以看到一幅更详细的结构图： </p>
<p><img src="\images\pasted-89.png" alt="upload successful"></p>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>Accept </p>
<p>请求报文可通过一个“Accept”报文头属性告诉服务端 客户端接受什么类型的响应。 </p>
<p>如下报文头相当于告诉服务端，俺客户端能够接受的响应类型仅为纯文本数据啊，你丫别发其它什么图片啊，视频啊过来，那样我会歇菜的~~~： </p>
<p>Cookie </p>
<p>客户端的Cookie就是通过这个报文头属性传给服务端的哦！如下所示：<br>Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C  </p>
<p>服务端是怎么知道客户端的多个请求是隶属于一个Session呢？注意到后台的那个jsessionid=5F4771183629C9834F8382E23BE13C4C木有？原来就是通过HTTP请求报文头的Cookie属性的jsessionid的值关联起来的！（当然也可以通过重写URL的方式将会话ID附带在每个URL的后面哦）。</p>
<p>Referer </p>
<p>表示这个请求是从哪个URL过来的，假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是<a href="http://www.google.com。" target="_blank" rel="noopener">http://www.google.com。</a> </p>
<p>Cache-Control </p>
<p>对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。 </p>
<h2 id="HTTP响应报文解剖"><a href="#HTTP响应报文解剖" class="headerlink" title="HTTP响应报文解剖 "></a>HTTP响应报文解剖 </h2><p>HTTP的响应报文也由三部分组成（响应行+响应头+响应体）： </p>
<p><img src="\images\pasted-90.png" alt="upload successful"></p>
<p>响应状态码 </p>
<p>和请求报文相比，响应报文多了一个“响应状态码”，它以“清晰明确”的语言告诉客户端本次请求的处理结果。 </p>
<p>HTTP的响应状态码由5段组成： </p>
<p>1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急…<br>2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.<br>3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。<br>4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。<br>5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。</p>
<h2 id="常见的HTTP响应报文头属性"><a href="#常见的HTTP响应报文头属性" class="headerlink" title="常见的HTTP响应报文头属性 "></a>常见的HTTP响应报文头属性 </h2><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control "></a>Cache-Control </h2><p>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 </p>
<p>下面，的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。 </p>
<h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag "></a>ETag </h2><p>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。 </p>
<p>关于ETag的说明，你可以参见：<a href="http://en.wikipedia.org/wiki/HTTP_ETag。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/HTTP_ETag。</a><br>Spring 3.0还专门为此提供了一个org.springframework.web.filter.ShallowEtagHeaderFilter（实现原理很简单，对JSP输出的内容MD5，这样内容有变化ETag就相应变化了），用于生成响应的ETag，因为这东东确实可以帮助减少请求和响应的交互。 </p>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location "></a>Location </h2><p>我们在JSP中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中： </p>
<h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie "></a>Set-Cookie </h2><p>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的：</p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】代码</title>
    <url>/2020/04/14/%E7%A7%AF%E7%B4%AF%E3%80%91%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="环队列叫号问题"><a href="#环队列叫号问题" class="headerlink" title="环队列叫号问题"></a>环队列叫号问题</h2><p>有m个猴子，按顺时针方向围成一个圈选大王。从第1号开始报数1，2，……，数到n号时该猴子退出到圈外，如此报数直到圈内只剩下一个猴子时，此猴子便是大王。由键盘输入m，n，打印出猴子大王序号。<br>输入 10 3<br>输出 4</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> monkey(<span class="number">4</span>,<span class="number">1</span>);<span class="comment">//5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">monkey</span><span class="params">($m,$n)</span></span>&#123;</span><br><span class="line">   <span class="comment">//定义arr猴子数组，</span></span><br><span class="line">   $arr=range(<span class="number">1</span>,$m);</span><br><span class="line">   $i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(count($arr)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">   	  <span class="comment">//出队</span></span><br><span class="line">       <span class="keyword">if</span>(($i+<span class="number">1</span>)%$n==<span class="number">0</span>)&#123;</span><br><span class="line">       	  <span class="comment">//如果猴子序号/猴王号n余数为0，踢走</span></span><br><span class="line">           <span class="keyword">unset</span>($arr[$i]);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//否则将该序号放在猴子数组队尾</span></span><br><span class="line">           $arr[]=$arr[$i];</span><br><span class="line">           <span class="keyword">unset</span>($arr[$i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">echo</span> $i.<span class="string">"\n"</span>;</span><br><span class="line">       $i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//最后key i所对应的就是猴王</span></span><br><span class="line">   <span class="keyword">return</span> $arr[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算加法"><a href="#位运算加法" class="headerlink" title="位运算加法"></a>位运算加法</h2>  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span><span class="params">($num1, $num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">while</span>($num2)&#123;</span><br><span class="line">        <span class="comment">//相加之后的进位</span></span><br><span class="line">        $tmp = $num1 ^ $num2;</span><br><span class="line">        <span class="comment">//相加之后没有进位</span></span><br><span class="line">        $num2 = ($num1 &amp; $num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        $num1 = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p>
<p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p>
<p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p>
<p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p>
<p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p>
<h2 id="php十进制二进制算法题"><a href="#php十进制二进制算法题" class="headerlink" title="php十进制二进制算法题"></a>php十进制二进制算法题</h2><p>负数需要先置反为反码，然后再加1，并且循环需要32位<br> floor()舍去法取整<br> ceil – 进一法取整<br> round – 对浮点数进行四舍五入<br> %取余数<br> array_count_values()表示$v出现次数<br>     <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">NumberOf1</span><span class="params">($n)</span></span>&#123;</span></span><br><span class="line"><span class="php">    $arr = <span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> ($n &gt; <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span>($n != <span class="number">0</span>)</span></span><br><span class="line"><span class="php">        &#123;</span></span><br><span class="line"><span class="php">            $temp = $n % <span class="number">2</span>;</span></span><br><span class="line"><span class="php">            $n = floor($n/<span class="number">2</span>);</span></span><br><span class="line"><span class="php">            array_push($arr,$temp);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $judge = array_count_values($arr);</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span>(<span class="keyword">isset</span>($judge[<span class="number">1</span>]))&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> $judge[<span class="number">1</span>];</span></span><br><span class="line"><span class="php">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">        $n = <span class="number">-1</span> * $n;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span>($n &gt; <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="php">            $temp = $n % <span class="number">2</span>;</span></span><br><span class="line"><span class="php">            $n = floor($n/<span class="number">2</span>);</span></span><br><span class="line"><span class="php">            array_push($arr,$temp);</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">for</span>($i=<span class="number">0</span>;$i &lt; <span class="number">32</span>;$i++)&#123;</span></span><br><span class="line"><span class="php">           <span class="keyword">if</span>($arr[$i] == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="php">               $arr[$i] = <span class="number">0</span>;</span></span><br><span class="line"><span class="php">           &#125;<span class="keyword">elseif</span>($arr[$i] == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="php">               $arr[$i] = <span class="number">1</span>;</span></span><br><span class="line"><span class="php">           &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">               $arr[$i] = <span class="number">1</span>;</span></span><br><span class="line"><span class="php">           &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $length = count($arr);</span></span><br><span class="line"><span class="php">        <span class="keyword">for</span>($i = <span class="number">0</span>;$i &lt; $length;$i++)&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($arr[$i]==<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="php">                $arr[$i] = <span class="number">1</span>;</span></span><br><span class="line"><span class="php">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="php">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">                $arr[$i] = <span class="number">0</span>;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $judge = array_count_values($arr);</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span>(<span class="keyword">isset</span>($judge[<span class="number">1</span>]))&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> $judge[<span class="number">1</span>];</span></span><br><span class="line"><span class="php">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="前序与中序还原树"><a href="#前序与中序还原树" class="headerlink" title="前序与中序还原树"></a>前序与中序还原树</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $val;</span><br><span class="line">        <span class="keyword">var</span> $left = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">var</span> $right = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span><span class="params">($pre, $vin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>($pre &amp;&amp; $vin)&#123;</span><br><span class="line">            <span class="comment">//前序遍历的第一个节点一定是根节点</span></span><br><span class="line">            $treeRoot = <span class="keyword">new</span> TreeNode($pre[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//index判断根节点在中序中是否存在,并返回根节点在vin中的键名</span></span><br><span class="line">            $index = array_search($pre[<span class="number">0</span>],$vin);</span><br><span class="line">            $treeRoot-&gt;left=reConstructBinaryTree(array_slice($pre,<span class="number">1</span>,$index),array_slice($vin,<span class="number">0</span>,$index));</span><br><span class="line">            $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+<span class="number">1</span>),array_slice($vin,$index+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> $treeRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">$pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line">$vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line">$re = reConstructBinaryTree($pre, $vin);</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历与中序遍历与后续遍历的php实现"><a href="#前序遍历与中序遍历与后续遍历的php实现" class="headerlink" title="前序遍历与中序遍历与后续遍历的php实现"></a>前序遍历与中序遍历与后续遍历的php实现</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> $value;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> $left;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> $right;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//先序遍历 根节点 ---&gt; 左子树 ---&gt; 右子树</span></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">preorder</span><span class="params">($root)</span></span>&#123;</span></span><br><span class="line"><span class="php">        $stack=<span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">        array_push($stack,$root);</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span>(!<span class="keyword">empty</span>($stack))&#123;</span></span><br><span class="line"><span class="php">            $center_node=array_pop($stack);</span></span><br><span class="line"><span class="php">            <span class="keyword">echo</span> $center_node-&gt;value.<span class="string">' '</span>;<span class="comment">//先输出根节点</span></span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($center_node-&gt;right!=<span class="keyword">null</span>)&#123;</span></span><br><span class="line"><span class="php">                array_push($stack,$center_node-&gt;right);<span class="comment">//压入左子树</span></span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($center_node-&gt;left!=<span class="keyword">null</span>)&#123;</span></span><br><span class="line"><span class="php">                array_push($stack,$center_node-&gt;left);</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//中序遍历，左子树---&gt; 根节点 ---&gt; 右子树</span></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">inorder</span><span class="params">($root)</span></span>&#123;</span></span><br><span class="line"><span class="php">        $stack = <span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">        $center_node = $root;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> (!<span class="keyword">empty</span>($stack) || $center_node != <span class="keyword">null</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">while</span> ($center_node != <span class="keyword">null</span>) &#123;</span></span><br><span class="line"><span class="php">                array_push($stack, $center_node);</span></span><br><span class="line"><span class="php">                $center_node = $center_node-&gt;left;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">            $center_node = array_pop($stack);</span></span><br><span class="line"><span class="php">            <span class="keyword">echo</span> $center_node-&gt;value . <span class="string">" "</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">            $center_node = $center_node-&gt;right;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//后序遍历，左子树 ---&gt; 右子树 ---&gt; 根节点</span></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">tailorder</span><span class="params">($root)</span></span>&#123;</span></span><br><span class="line"><span class="php">        $stack=<span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">        $outstack=<span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">        array_push($stack,$root);</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span>(!<span class="keyword">empty</span>($stack))&#123;</span></span><br><span class="line"><span class="php">            $center_node=array_pop($stack);</span></span><br><span class="line"><span class="php">            array_push($outstack,$center_node);<span class="comment">//最先压入根节点，最后输出</span></span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($center_node-&gt;left!=<span class="keyword">null</span>)&#123;</span></span><br><span class="line"><span class="php">                array_push($stack,$center_node-&gt;left);</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($center_node-&gt;right!=<span class="keyword">null</span>)&#123;</span></span><br><span class="line"><span class="php">                array_push($stack,$center_node-&gt;right);</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">while</span>(!<span class="keyword">empty</span>($outstack))&#123;</span></span><br><span class="line"><span class="php">            $center_node=array_pop($outstack);</span></span><br><span class="line"><span class="php">            <span class="keyword">echo</span> $center_node-&gt;value.<span class="string">' '</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    $a=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $b=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $c=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $d=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $e=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $f=<span class="keyword">new</span> Node();</span></span><br><span class="line"><span class="php">    $a-&gt;value=<span class="string">'A'</span>;</span></span><br><span class="line"><span class="php">    $b-&gt;value=<span class="string">'B'</span>;</span></span><br><span class="line"><span class="php">    $c-&gt;value=<span class="string">'C'</span>;</span></span><br><span class="line"><span class="php">    $d-&gt;value=<span class="string">'D'</span>;</span></span><br><span class="line"><span class="php">    $e-&gt;value=<span class="string">'E'</span>;</span></span><br><span class="line"><span class="php">    $f-&gt;value=<span class="string">'F'</span>;</span></span><br><span class="line"><span class="php">    $a-&gt;left=$b;</span></span><br><span class="line"><span class="php">    $a-&gt;right=$c;</span></span><br><span class="line"><span class="php">    $b-&gt;left=$d;</span></span><br><span class="line"><span class="php">    $c-&gt;left=$e;</span></span><br><span class="line"><span class="php">    $c-&gt;right=$f;</span></span><br><span class="line"><span class="php">    preorder($a);<span class="comment">//A B D C E F</span></span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="string">'&lt;hr/&gt;'</span>;</span></span><br><span class="line"><span class="php">    inorder($a);<span class="comment">//D B A E C F</span></span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="string">'&lt;hr/&gt;'</span>;</span></span><br><span class="line"><span class="php">    tailorder($a);<span class="comment">//D B E F C A</span></span></span><br></pre></td></tr></table></figure>
<h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*class ListNode&#123;</span></span><br><span class="line"><span class="comment">    var $val;</span></span><br><span class="line"><span class="comment">    var $next = NULL;</span></span><br><span class="line"><span class="comment">    function __construct($x)&#123;</span></span><br><span class="line"><span class="comment">        $this-&gt;val = $x;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseList</span><span class="params">($pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>($pHead==<span class="keyword">NULL</span>||$pHead-&gt;next==<span class="keyword">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> $pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原链表的元素一个个插入到新链表的头部</span></span><br><span class="line">    $pPre = <span class="keyword">NULL</span>;</span><br><span class="line">    $pCur = $pHead;</span><br><span class="line">    <span class="keyword">while</span> ($pCur-&gt;next != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        $pNext = $pCur-&gt;next;</span><br><span class="line">        $pCur-&gt;next = $pPre;</span><br><span class="line">        $pPre = $pCur;</span><br><span class="line">        $pCur = $pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    $pCur-&gt;next = $pPre;</span><br><span class="line">    <span class="keyword">return</span> $pCur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><p><img src="\images\pasted-10.png" alt="upload successful"></p>
<p>1、把根节点A放入队列，此时队列为：A，队列头指针指向A，也就是队列第一个元素<br>2、把当前队列头指针所指元素的左右儿子放入队列，即将B C放入队列，此时队列为A B C ，队列头指针向下移一格，此时指向B<br>3、不断重复2步骤。此时把B的左右儿子取出来放入队尾，队列变为A B C D E，队列头指针后移，指向c，c没有子节点，队列不再延长；<br>4、结束条件，队列头指针和为指针重合时，输出最后一个元素，算法结束！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $val;</span><br><span class="line">    <span class="keyword">var</span> $left = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">var</span> $right = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span><span class="params">($pre, $vin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>($pre &amp;&amp; $vin)&#123;</span><br><span class="line">        $treeRoot  = <span class="keyword">new</span> TreeNode($pre[<span class="number">0</span>]);</span><br><span class="line">        $index = array_search($pre[<span class="number">0</span>],$vin);</span><br><span class="line">        $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,<span class="number">1</span>,$index),array_slice($vin,<span class="number">0</span>,$index));</span><br><span class="line">        $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+<span class="number">1</span>),array_slice($vin,$index+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> $treeRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line">$vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line">$re = reConstructBinaryTree($pre, $vin);</span><br><span class="line">PrintFromTopToBottom($re);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintFromTopToBottom</span><span class="params">($re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $quene=<span class="keyword">array</span>();</span><br><span class="line">    $res=<span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">if</span>($re==<span class="keyword">null</span>) <span class="keyword">return</span> $res;</span><br><span class="line">    array_push($quene,$re);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">empty</span>($quene))&#123;</span><br><span class="line">        <span class="comment">// quene出队，队头值赋值给tmp，最后打印tmp的val</span></span><br><span class="line">        <span class="comment">//这里使队列出队是为了将quene的指针右移，使tmp成为quene右移指针之后的树，如ABC，下一步要将B的孩子DE入队，那么就需要使tmp指向B</span></span><br><span class="line">        $tmp=array_shift($quene);</span><br><span class="line">        <span class="comment">//左右节点依次入队</span></span><br><span class="line">        <span class="keyword">if</span>($tmp-&gt;left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            array_push($quene,$tmp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($tmp-&gt;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            array_push($quene,$tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将tmp的val入队</span></span><br><span class="line">        array_push($res,$tmp-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    print_r($res) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="comment">//二路快排</span></span></span><br><span class="line"><span class="php">$ar = [<span class="number">34</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">555</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">54</span>];</span></span><br><span class="line"><span class="php">print_r(json_encode($ar));</span></span><br><span class="line"><span class="php">quick($ar);</span></span><br><span class="line"><span class="php">print_r(json_encode($ar));</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">quick</span><span class="params">(array &amp; $ar, $left = <span class="number">0</span>, $right = null)</span></span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> ($right === <span class="keyword">null</span>) &#123;</span></span><br><span class="line"><span class="php">        $right = sizeof($ar) - <span class="number">1</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> ($left &gt;= $right) &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//not need to sort</span></span></span><br><span class="line"><span class="php"><span class="comment">//        echo "finish";</span></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    $first_index = $left;</span></span><br><span class="line"><span class="php">    $last_index = $right;</span></span><br><span class="line"><span class="php">    $key = $ar[$left];</span></span><br><span class="line"><span class="php">    <span class="keyword">while</span> ($left != $right) &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($ar[$right] &gt;= $key &amp;&amp; $left &lt; $right) &#123;</span></span><br><span class="line"><span class="php">            $right--;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">while</span> ($ar[$left] &lt;= $key &amp;&amp; $left &lt; $right) &#123;</span></span><br><span class="line"><span class="php">            $left++;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($left &lt; $right) &#123;</span></span><br><span class="line"><span class="php">            <span class="comment">//swap</span></span></span><br><span class="line"><span class="php">            $t = $ar[$left]; $ar[$left] = $ar[$right]; $ar[$right] = $t; &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> ($first_index != $left) &#123;</span></span><br><span class="line"><span class="php">        $ar[$first_index] = $ar[$left];</span></span><br><span class="line"><span class="php">        $ar [$left] = $key;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//left == right == mid</span></span></span><br><span class="line"><span class="php">    quick($ar, $first_index, $left - <span class="number">1</span>);</span></span><br><span class="line"><span class="php">    quick($ar, $left + <span class="number">1</span>, $last_index);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="插排"><a href="#插排" class="headerlink" title="插排"></a>插排</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="comment">//直接插入排序</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(array &amp;$arr,$a,$b)</span></span>&#123;</span></span><br><span class="line"><span class="php">  $temp = $arr[$a];</span></span><br><span class="line"><span class="php">  $arr[$a] = $arr[$b];</span></span><br><span class="line"><span class="php">  $arr[$b] = $temp;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">InsertSort</span><span class="params">(array &amp;$arr)</span></span>&#123;</span></span><br><span class="line"><span class="php">  $count = count($arr);</span></span><br><span class="line"><span class="php">  <span class="comment">//数组中第一个元素作为一个已经存在的有序表</span></span></span><br><span class="line"><span class="php">  <span class="keyword">for</span>($i = <span class="number">1</span>;$i &lt; $count;$i ++)&#123;</span></span><br><span class="line"><span class="php">    $temp = $arr[$i];   <span class="comment">//设置哨兵</span></span></span><br><span class="line"><span class="php">    <span class="keyword">for</span>($j = $i - <span class="number">1</span>;$j &gt;= <span class="number">0</span> &amp;&amp; $arr[$j] &gt; $temp;$j --)&#123;</span></span><br><span class="line"><span class="php">      $arr[$j + <span class="number">1</span>] = $arr[$j];    <span class="comment">//记录后移</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    $arr[$j + <span class="number">1</span>] = $temp;   <span class="comment">//插入到正确的位置</span></span></span><br><span class="line"><span class="php">  &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php">$arr = <span class="keyword">array</span>(<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="php">InsertSort($arr);</span></span><br><span class="line"><span class="php">var_dump($arr);</span></span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="comment">// 冒泡排序</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">PrintMinNumber</span><span class="params">($numbers)</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    $length = count($numbers);</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span>($length == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="string">''</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i &lt; $length<span class="number">-1</span>;$i++)&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">for</span>($j = $i;$j &lt; $length;$j++)&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span>($numbers[$i].$numbers[$j] &gt; $numbers[$j].$numbers[$i])&#123;</span></span><br><span class="line"><span class="php">                $temp = $numbers[$i];</span></span><br><span class="line"><span class="php">                $numbers[$i] = $numbers[$j];</span></span><br><span class="line"><span class="php">                $numbers[$j] = $temp;</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    $a = implode(<span class="string">''</span>,$numbers);</span></span><br><span class="line"><span class="php">    <span class="keyword">return</span> $a;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php">$arr = [<span class="number">32</span>,<span class="number">3</span>,<span class="number">321</span>];</span></span><br><span class="line"><span class="php">PrintMinNumber($arr);</span></span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* mergeSort 归并排序</span></span><br><span class="line"><span class="comment">* 是开始递归函数的一个驱动函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &amp;$arr array 待排序的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span><span class="params">(&amp;$arr)</span> </span>&#123;</span><br><span class="line">  $len = count($arr);<span class="comment">//求得数组长度</span></span><br><span class="line"> </span><br><span class="line">  mSort($arr, <span class="number">0</span>, $len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实际实现归并排序的程序</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &amp;$arr array 需要排序的数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $left int 子序列的左下标值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $right int 子序列的右下标值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mSort</span><span class="params">(&amp;$arr, $left, $right)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>($left &lt; $right) &#123;</span><br><span class="line">    <span class="comment">//说明子序列内存在多余1个的元素，那么需要拆分，分别排序，合并</span></span><br><span class="line">    <span class="comment">//计算拆分的位置，长度/2 去整</span></span><br><span class="line">    $center = floor(($left+$right) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//递归调用对左边进行再次排序：</span></span><br><span class="line">    mSort($arr, $left, $center);</span><br><span class="line">    <span class="comment">//递归调用对右边进行再次排序</span></span><br><span class="line">    mSort($arr, $center+<span class="number">1</span>, $right);</span><br><span class="line">    <span class="comment">//合并排序结果</span></span><br><span class="line">    mergeArray($arr, $left, $center, $right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将两个有序数组合并成一个有序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &amp;$arr, 待排序的所有元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $left, 排序子数组A的开始下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $center, 排序子数组A与排序子数组B的中间下标，也就是数组A的结束下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $right, 排序子数组B的结束下标（开始为$center+1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArray</span><span class="params">(&amp;$arr, $left, $center, $right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置两个起始位置标记</span></span><br><span class="line">  $a_i = $left;</span><br><span class="line">  $b_i = $center+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>($a_i&lt;=$center &amp;&amp; $b_i&lt;=$right) &#123;</span><br><span class="line">    <span class="comment">//当数组A和数组B都没有越界时</span></span><br><span class="line">    <span class="keyword">if</span>($arr[$a_i] &lt; $arr[$b_i]) &#123;</span><br><span class="line">      $temp[] = $arr[$a_i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $temp[] = $arr[$b_i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内：</span></span><br><span class="line">  <span class="keyword">while</span>($a_i &lt;= $center) &#123;</span><br><span class="line">    $temp[] = $arr[$a_i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内：</span></span><br><span class="line">  <span class="keyword">while</span>($b_i &lt;= $right) &#123;</span><br><span class="line">    $temp[] = $arr[$b_i++];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//将$arrC内排序好的部分，写入到$arr内：</span></span><br><span class="line">  <span class="keyword">for</span>($i=<span class="number">0</span>, $len=count($temp); $i&lt;$len; $i++) &#123;</span><br><span class="line">    $arr[$left+$i] = $temp[$i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//do some test:</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">mergeSort($arr);</span><br><span class="line">print_r($arr);</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr=<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">587</span>,<span class="number">93</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">83</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">65</span>,<span class="number">2</span>,<span class="number">18</span>,<span class="number">7</span>);</span><br><span class="line">printArr($arr);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge_sort</span><span class="params">(&amp;$arr)</span></span>&#123;</span><br><span class="line">    $len=count($arr);</span><br><span class="line">    <span class="keyword">if</span>($len==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    $middle=intval($len/<span class="number">2</span>);</span><br><span class="line">    $left=array_slice($arr,<span class="number">0</span>,$middle);</span><br><span class="line">    $right=array_slice($arr,$middle);</span><br><span class="line">    merge_sort($left);</span><br><span class="line">    merge_sort($right);</span><br><span class="line">    $arr=merge($left,$right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">($leftarr,$rightarr)</span></span>&#123;</span><br><span class="line">    $arrmerge=<span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">while</span>(count($leftarr) &amp;&amp; count($rightarr))</span><br><span class="line">        $arrmerge[]=$leftarr[<span class="number">0</span>]&lt;$rightarr[<span class="number">0</span>]?array_shift($leftarr):array_shift($rightarr);</span><br><span class="line">    <span class="keyword">return</span> array_merge($arrmerge,$leftarr,$rightarr);</span><br><span class="line">&#125;</span><br><span class="line">merge_sort($arr);</span><br><span class="line">printArr($arr);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">($arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($arr);$i++)</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">' '</span>.$arr[$i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的遍历与对比"><a href="#树的遍历与对比" class="headerlink" title="树的遍历与对比"></a>树的遍历与对比</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $val;</span><br><span class="line">    <span class="keyword">var</span> $left = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">var</span> $right = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span><span class="params">($pre, $vin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>($pre &amp;&amp; $vin)&#123;</span><br><span class="line">        $treeRoot  = <span class="keyword">new</span> TreeNode($pre[<span class="number">0</span>]);</span><br><span class="line">        $index = array_search($pre[<span class="number">0</span>],$vin);</span><br><span class="line">        $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,<span class="number">1</span>,$index),array_slice($vin,<span class="number">0</span>,$index));</span><br><span class="line">        $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+<span class="number">1</span>),array_slice($vin,$index+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> $treeRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line">$vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line">$pre1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>];</span><br><span class="line">$vin1 = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">$pRoot1 = reConstructBinaryTree($pre, $vin);</span><br><span class="line">$pRoot2 = reConstructBinaryTree($pre1,$vin1);</span><br><span class="line"><span class="keyword">echo</span> HasSubtree($pRoot1, $pRoot2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span><span class="params">($pRoot1, $pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $re = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>($pRoot1!=<span class="keyword">NULL</span>&amp;&amp;$pRoot2!=<span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span>($pRoot1-&gt;val==$pRoot2-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                $re = judge($pRoot1,$pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!$re)&#123;</span><br><span class="line">                <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">                $re = HasSubtree($pRoot1-&gt;left,$pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!$re)&#123;</span><br><span class="line">                <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">                $re = HasSubtree($pRoot1-&gt;right,$pRoot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>($re == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judge</span><span class="params">($pRoot1, $pRoot2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">    <span class="keyword">if</span>($pRoot2 == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">    <span class="keyword">if</span>($pRoot1 == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">    <span class="keyword">if</span>($pRoot1-&gt;val != $pRoot2-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">    <span class="keyword">return</span> judge($pRoot1-&gt;left,$pRoot2-&gt;left)&amp;&amp;judge($pRoot1-&gt;right,$pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】Mysql</title>
    <url>/2020/04/14/%E7%A7%AF%E7%B4%AF%E3%80%91Mysql/</url>
    <content><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。</p>
<p><img src="\images\pasted-118.png" alt="upload successful"></p>
<p>pass:脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 幻读的重点在于新增或者删除. 脏读：数据读错方只读了一次数据库。<br>不可重复读：数据读错方读了两次数据库</p>
<p>pass：不可重复读与幻读的本质区别<br>不可重复读是读取了其他事务更改的数据，针对update操作<br>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</p>
<p>幻读是读取了其他事务新增的数据，针对insert操作<br>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。<br><a id="more"></a></p>
<h2 id="事务并发会产生什么问题"><a href="#事务并发会产生什么问题" class="headerlink" title="事务并发会产生什么问题"></a>事务并发会产生什么问题</h2><p><img src="\images\pasted-119.png" alt="upload successful"></p>
<p>提醒：<br>不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了<br>幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样</p>
<h2 id="事务隔离级别，解决什么并发问题，以及存在什么并发问题"><a href="#事务隔离级别，解决什么并发问题，以及存在什么并发问题" class="headerlink" title="事务隔离级别，解决什么并发问题，以及存在什么并发问题"></a>事务隔离级别，解决什么并发问题，以及存在什么并发问题</h2><p>（1）READ_UNCOMMITTED（读未提交）<br>　　这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。<br>　　解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。<br>（2）READ_COMMITTED（读已提交）<br>　　保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。<br>　　解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题<br>（3）REPEATABLE_READ（重复读）<br>　　保证一个事务相同条件下前后两次获取的数据是一致的<br>    解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。<br>（4）SERIALIZABLE（串行化）<br>　　事务被处理为顺序执行。<br>　　解决所有问题<br>提醒：<br>Mysql默认的事务隔离级别为repeatable_read</p>
<h2 id="mysql面试题"><a href="#mysql面试题" class="headerlink" title="mysql面试题"></a>mysql面试题</h2><p>在数据库题目中，由于现在大部分公司都是使用MySql作为数据库，因此笔者及其朋友所遇到的问题也都是MySql相关的知识点。<br>1）MySql中索引的基本定义，优劣势，以及索引优化。<br>索引是帮助Mysql高效获取数据的数据结构，因此，索引的本质就是数据结构，索引的目的在于提高查询效率，可类比字典。<br>索引：排好序的快速查找的数据结构。<br>用途：排序 + 快速查找。注意，是两种功能。<br>数据库除了存储数据本身之外，还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。<br>MySql索引通常是指B+树索引。<br>索引优势：<br>类似书籍的目录，提高数据检索的效率，降低数据库的 IO 成本（因为数据最终是存储在磁盘上的）。<br>通过索引列对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗（因为排好序，查询速度增加）。<br>索引劣势：<br>索引也是一张表，保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用磁盘空间的。<br>虽然提高了查询速度，但是会降低更新速度（因为数据更新后，需要重新对索引排序），如 INSERT、UPDATE、DELETE 操作。<br>哪些情况适合建索引：<br>①主键自动建立唯一索引。<br>②频繁作为查询条件的字段应该创建索引。<br>③查询中与其它表关联的字段，外键关系建立索引。<br>④查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。<br>⑤查询中统计或者分组字段。<br>哪些情况不适合建索引：<br>①频繁更新的字段。<br>②Where 条件中用不到的字段。<br>③表记录太少。<br>④经常增删改的表。<br>⑤散列太小的字段，如性别、国籍。<br>索引优化就是为了尽可能的利用索引来提高查询的效率，所以保证索引不失效，并且创建正确的索引与高效的sql语句，就是对索引的优化，因此关于优化直接看下个题目：索引的失效。<br>2）哪些情况下索引失效。<br>索引优化和索引失效是相对应的，我们优化索引的目的就是为了让索引不失效，发生下列情况索引会失效：<br>①对于使用NOT NULL修饰的字段，使用IS NULL和 IS NOT NULL，会导致索引失效，进行全表扫描。<br>②键值较少的列。因为键值较少，如果加上索引，还需要对索引进行维护，本来记录就少，所以直接查询效率更高。<br>③LIKE以%开头会导致索引失效。如果右边加上%，索引不会失效，但是在实际生产环境中，如果只在右边加%，对于模糊查询不够用。解决方式：使用索引覆盖：查询字段和条件字段都在索引列上时，索引才会生效。<br>④使用范围后（如字段&gt;1）会使索引失效（存储引擎不能使用索引中范围条件右边的列）。所以如果存在范围查询的字段，就不要建立索引。<br>⑤对于两张表，如果基于主键的查询，是可以用索引的，因为主键本身就有索引，对于左右连接来说，左连接，左表肯定是All，本来就要查询出左表的结果，所以右表建立索引，而右连接相反，左表建立索引。<br>⑥不要在索引列上做任何操作（计算、函数和类型转换），会导致索引失效，另外在字符串查询不加单引号，也会导致索引失效。<br>⑦最左前缀法则：查询从索引列的最左开始（头部），如果没有头部，则会使用全表扫描，并且中间不能间断，如只有头部和尾部，则只使用头部索引。火车头不能少，中间车厢不能断。<br>⑧使用不等于的时候会使索引失效，导致全表扫描。<br>⑨尽量使用覆盖索引：索引列和查询列一致。<br>⑩OR连接会使索引失效，导致全表扫描。<br>⑪Order By 要尽量使用 Index 排序，避免 Filesort 排序。<br>3）MySql调优项目经历或者相关策略。<br>是否需要添加索引，在哪些字段上添加索引，在sql语句中，索引列是否用上，主要使用Explain对sql语句进行分析。<br>这里对Explain进行简单介绍：<br>使用 Explain 关键字可以模拟优化器执行 Sql 查询语句，从而知道 Mysql 是如何处理 Sql 的。<br>执行Explain会产生一个信息表，表中有如下关键字：</p>
<p>①id：select查询的序列号，表示查询中执行select子句或操作表的顺序。值越大越先执行，值相同，从上到下依次执行。<br>②select_type:有6种取值SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT，其值具体解释，参考：<a href="https://yq.aliyun.com/articles/61934" target="_blank" rel="noopener">https://yq.aliyun.com/articles/61934</a><br>③table:显示当前行sql是对哪张表进行操作的。<br>④type：指访问类型，非常重要，根据type可推断sql语句的优劣。其取值从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all，通常需保证到range级别，最好能达到ref级别。</p>
<p>#1.const：表示通过索引一次就找到了，用于比较主键索引或者唯一性索引。如将主键置于 Where 条件中，Mysql 就能将该查询转换为一个常量。</p>
<p>#2.system：表示只有一行数据，是const的特例，生产中基本不会出现，可忽略。</p>
<p>#3.eq_ref：唯一性索引扫描。对于每个索引表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p>
<p>#4.ref：非唯一性索引扫描，返回匹配某个单独值的所有行。对于 eq_ref &amp; ref 的总结：都会使用索引，但使用索引进行检索后的结果不同，前者的结果是唯一的，而后者的结果不唯一。所以，前者通常用于主键或唯一性索引扫描，而后者通常用于非唯一性索引扫描（有多行记录）。</p>
<p>#5.range：只检索给定范围的行，使用一个索引来选择行；Key 列显示使用了哪个索引；一般就是在 Where 条件中出现了 between, &lt;, &gt;, in 等查询；它比全索引扫描要好，因为它开始于索引的某一点、且结束于另一点，而不用全索引扫描.</p>
<p>#6.index：全索引扫描，只遍历索引树，index和all 都是全表扫描，但是 index 是从索引中读取，而 All 是从磁盘中读取。</p>
<p>#7.All：全表扫描，磁盘扫描。<br>⑤possible_keys：显示理论上有可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被实际使用。<br>⑥key：实际使用的索引。如果为 Null，则未使用索引。查询中若使用了覆盖索引，则该索引只出现在 Key 列表中（即不会出现在 possible_keys 列中）。<br>⑦key_len：表示索引中使用的字节数，可通过该值计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。<br>⑧ref：显示索引的哪一列被使用了，如果索引被使用则是一个常数。表示哪些列或常量被用于查找索引列上的值。<br>⑨rows：根据表统计信息及索引选用情况，大致估算出查询到结果时所需要读取的行数（要跑多少行）。值越小越好（值越小说明查询越精准）。<br>⑩Extra<br>会出现的值包括：</p>
<p>#1.Using filesort：说明 Mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行排序；Mysql 中无法利用索引完成的排序操作称为“文件排序”。因此出现该值，表示sql语句比较“烂”了，则需要进行sql语句的优化。</p>
<p>#2.Using Temporary：使用了临时表保存中间结果，Mysql 在查询结果排序时使用临时表，常见于 ORDER BY 和 GROUP BY。出现该值，则表明sql非常“烂”了，急需优化。</p>
<p>#3.Using Where：表明索引被用来执行索引键值的查找。</p>
<p>#4.Using Index：表示相应的 SELECT 操作中使用了覆盖索引，避免访问了表的数据行，效率可以。<br>总结：<br>type、key、ref、Extra，这四个字段比较重要，sql语句的“烂”的程度，通过这几个字段体现。<br>type：取值从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all，查询时至少保证在range，最好达到ref。<br>key：实际使用的索引，如果为NULL，则表示未使用索引。<br>ref：显示那一列索引被使用了。<br>Extra：最好是Using Index、Using Where，一定不能是Using Temporary、Using filesort。<br>5）MySql的事务隔离级别，不可重复读、脏读、幻读。<br>MySql的事务隔离级别有4个，隔离等级从低到高依次为Read uncommitted （读取未提交内容）、Read committed（读取提交内容） 、Repeatable read（可重复读） 、Serializable （串行），这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题，其中Repeatable read是MySql事务的默认隔离级别。</p>
<p>从表中可以看出Serializable隔离等级最高，可以避免一切并发问题，但是效率低。<br>脏读：A事务更新一份数据，但事务未提交，B事务在此时读取了同一份数据，由于某些原因，A事务发生了回滚操作，则B事务拿着失效的数据去做操作就会发生错误。脏读通俗来说就是读错了，读错了。<br>不可重复读：对于不可重复读的解释很多资料说得非常模糊，这里给出一个比较清晰的解释。A事务两次读取同一数据，在A事务还没有结束时，B事务也访问该同一数据，并进行了修改。那么在A事务中的两次读数据之间，由于B事务的修改，A事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即在重复对数据进行读取的时候，不能得到相同的数据内容，感觉这个不可重复读翻译很不好理解，个人的理解方式：不可重复读，那重复读会出现什么情况呢，重复读出现数据不一致的情况，所以还是不要重复读——&gt;不可重复读）<br>例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改，则编辑第二次读取的文档与第一次就不一致了。<br>幻读：通俗来讲读取到的数据像产生幻觉一样。是指当事务不是独立执行时发生的一种现象。事务A在两次查询的过程中（比如查询结果8列），事务B对该表进行了插入、删除操作（增加或减少了2列），从而事务A第二次查询的结果发生了变化，两次查询的数据不一样，感觉产生了“幻觉”一样。<br>虚读：通俗来讲读取的数据不同。A事务在两次查询的过程中（查询结果一列），B事务对数据进行了修改，从而使A事务第二次查询的结果不一样。<br>脏读的事务未提交，虚读与幻读事务已经提交。<br>Read uncommitted（读未提交内容）<br>在该级别下，A事务对一行数据修改的过程中，不允许B事务对该行数据进行修改，但允许B事务对该行数据进行读操作。 因此本级别下，不会出现更新丢失（i++问题），但会出现脏读（A修改时，发生了回滚）、不可重复读（B两次读取时，A修改了数据），幻读（幻读是不可重复读的一种情况）。<br>Read committed（读提交内容）<br>在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。A读取数据，B紧接着A更改了数据，并提交了事务，A再次读取数据时，发现数据已经改变。出现不可重复读和幻读想象。<br>Repeatable read（可重复读）<br>在该级别下，读事务时禁止写事务（读写互斥），A在读取数据时数据为100，事务提交后，紧接着B对数据修改为200，当A再次读取时，发现数据不一样，出现幻读。<br>Serialiazble read（串行）<br>隔离级别最高，避免一切并发问题，但效率低，生产中基本不用。<br>6）delete 与 truncate 区别，分别适用于哪种场景。<br>delete与truncate都是做删除操作，但是两者间还是有一定区别：<br>①truncate删除速度快，没有日志记录，数据不可恢复。释放表或索引的空间<br>②delete删除速度慢，因为删除中会产生日志记录，数据可恢复。不会释放表或索引的空间。<br>③应用场景这个不好说，delete可恢复，truncate不可恢复，只有根据具体需求进行选择了。<br>7）MySql中主从复制，集群。<br>MySql提供主从复制的功能，基础是二进制日志文件。<br>关于集群方面，功力不深，需要更进一步的了解，才能很好的回答该问题。<br>参考：<br><a href="https://www.cnblogs.com/gl-developer/p/6170423.html" target="_blank" rel="noopener">https://www.cnblogs.com/gl-developer/p/6170423.html</a><br>8）B+树、为什么使用 B+树、B+树优缺点<br>关于B+树，笔者并不是特别的了解。放上一链接：<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md" target="_blank" rel="noopener">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md</a><br>为什么使用B+树？<br>①B+树支持区间查询，而B树不支持。<br>②B+树方便扫库，它直接从叶子节点出发，就可以进行扫描，而B树需进行中序遍历（LDR）。<br>③B+树磁盘读写代价更低。<br>缺点：<br>①当查找数据在非叶子节点时，B+树会走一条根到叶子节点的路径。<br>参考：<br><a href="https://www.cnblogs.com/tiancai/p/9024351.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiancai/p/9024351.html</a><br><a href="http://darrenzhu.iteye.com/blog/2050082" target="_blank" rel="noopener">http://darrenzhu.iteye.com/blog/2050082</a><br>9）MySql存储引擎MyISAM和InnoDB的区别。<br>①MyISAM不支持外键，InnoDB支持外键。<br>②MyISAM不支持事务，InnoDB支持事务。<br>③MyISAM是表锁，InnoDB是行锁。<br>④MyISAM支持全文索引，InnoDB不支持。<br>⑤MyISAM的查询速度比InnoDB快。</p>
<p>1.隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误.<br> 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效.<br> 错误的例子：select <em> from test where tu_mdn=13333333333;<br> 正确的例子：select </em> from test where tu_mdn=’13333333333’;</p>
<p>2.对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，<em>，/，! 等)<br> 错误的例子：select </em> from test where id-1=9;<br> 正确的例子：select * from test where id=10;</p>
<p>3.使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引.<br> 错误的例子：select <em> from test where round(id)=10; 说明，此时id的索引已经不起作用了<br> 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select </em> from test where round(id)=10; 这时函数索引起作用了</p>
<p>4.以下使用会使索引失效，应避免使用；<br> a. 使用 &lt;&gt; 、not in 、not exist、!=<br> b. like “%_” 百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理）<br> c. 单独引用复合索引里非第一位置的索引列.应总是使用索引的第一个列，如果索引是建立在多个列上, 只有在它的第一个列被where子句引用时，优化器才会选择使用该索引。<br> d. 字符型字段为数字时在where条件里不添加引号.<br> e. 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。</p>
<p>5.不要将空的变量值直接与比较运算符（符号）比较。<br> 如果变量可能为空，应使用 IS NULL 或 IS NOT NULL 进行比较，或者使用 ISNULL 函数。</p>
<p>6.不要在 SQL 代码中使用双引号。<br> 因为字符常量使用单引号。如果没有必要限定对象名称，可以使用（非 ANSI SQL 标准）括号将名称括起来。</p>
<p>7.将索引所在表空间和数据所在表空间分别设于不同的磁盘chunk上，有助于提高索引查询的效率。</p>
<ol start="8">
<li><p>Oracle默认使用的基于代价的SQL优化器（CBO）非常依赖于统计信息，一旦统计信息不正常，会导致数据库查询时不使用索引或使用错误的索引。<br>一般来说，Oracle的自动任务里面会包含更新统计信息的语句，但如果表数据发生了比较大的变化（超过20%）,可以考虑立即手动更新统计信息，例如：analyze table abc compute statistics，但注意，更新   统计信息比较耗费系统资源，建议在系统空闲时执行。</p>
</li>
<li><p>Oracle在进行一次查询时，一般对一个表只会使用一个索引.<br>因此，有时候过多的索引可能导致Oracle使用错误的索引，降低查询效率。例如某表有索引1（Policyno）和索引2（classcode），如果查询条件为policyno = ‘xx’ and classcode = ‘xx’，则系统有可能会使用索   引2，相较于使用索引1，查询效率明显降低。</p>
</li>
<li><p>优先且尽可能使用分区索引。</p>
</li>
</ol>
<h2 id="如何进行SQL优化？"><a href="#如何进行SQL优化？" class="headerlink" title="如何进行SQL优化？"></a>如何进行SQL优化？</h2><p>（1）选择正确的存储引擎<br>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。<br>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<p>（2）优化字段的数据类型<br>记住一个原则，越小的列会越快。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。</p>
<p>（3）为搜索字段添加索引<br>索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。</p>
<p>（4）避免使用Select <em>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。即使你要查询数据表的所有字段，也尽量不要用</em>通配符，善用内置提供的字段排除定义也许能给带来更多的便利。</p>
<p>（5）使用 ENUM 而不是 VARCHAR<br>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。例如，性别、民族、部门和状态之类的这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p>
<p>（6）尽可能的使用 NOT NULL<br>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。 NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。</p>
<p>（7）固定长度的表会更快<br>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p>
<p>固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。<br>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>优点<br>①类似大学图书馆的书目索引，提高数据的检索效率，降低数据库的IO成本。<br>②通过索引列对数据进行排序，降低数据的排序成本，从而降低CPU的消耗。<br>缺点<br>①索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间。<br>②虽然索引大大提高了查询效率，但是降低了更新表的速度，如insert、update和delete操作。因为更新表时，MySQL不仅要保存数据，还要保存索引文件每次更新的索引列字段，并且在更新操作后，会更新相应字段索引的信息。<br>③索引只是提高查询效率的一个因素，如果你的MySQL有大量的数据表，就需要花时间研究建立最优秀的索引或优化查询语句。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>索引主要分为以下三类：<br>①单值索引：一个索引只包含单个列，一个表可以有多个单值索引。<br>②唯一索引：索引列的值必须唯一，但允许有空值，主键就是唯一索引。<br>③复合索引：一个索引包含多个列<br>索引的结构：<br>①BTREE索引；②Hash索引；③Full-Text索引；④R-Tree索引。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>①创建索引<br>create [unique] index indexname on tablename(columnname(length));</p>
<p>alter table tablename add index indexname (columnname(length));<br>注：如果是char、varchar类型的字段，length可以小于字段实际长度；如果是blob、text类型，必须指定length。<br>②删除索引<br>drop index indexname on tablename;<br>③查看索引<br>show index from tablename;<br>④其他创建索引的方式</p>
<p>1.添加主键索引<br>ALTER TABLE <code>table_name</code> ADD PRIMARY KEY (<code>column</code>) </p>
<p>2.添加唯一索引<br>ALTER TABLE <code>table_name</code> ADD UNIQUE (<code>column</code>) </p>
<p>3.添加全文索引<br>ALTER TABLE <code>table_name</code> ADD FULLTEXT (<code>column</code>) </p>
<p>4.添加普通索引<br>ALTER TABLE <code>table_name</code> ADD INDEX index_name (<code>column</code> ) </p>
<p>5.添加组合索引<br>ALTER TABLE <code>table_name</code> ADD INDEX index_name (<code>column1</code>, <code>column2</code>, <code>column3</code>)</p>
<h2 id="建立索引与否的具体情况"><a href="#建立索引与否的具体情况" class="headerlink" title="建立索引与否的具体情况"></a>建立索引与否的具体情况</h2><p>①需建立索引的情况</p>
<p>#1.主键自动建立唯一索引。</p>
<p>#2.频繁作为查询条件的字段。</p>
<p>#3.查询中与其他表关联的字段，外键关系建立索引。</p>
<p>#4.高并发下趋向创建组合索引。</p>
<p>#5.查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</p>
<p>#6.查询中统计或分组字段。<br>②不需要创建索引的情况</p>
<p>#1.表记录太少。（数据量太少MySQL自己就可以搞定了）</p>
<p>#2.经常增删改的表。</p>
<p>#3.数据重复且平均分配的字段，如国籍、性别，不适合创建索引。</p>
<p>#4.频繁更新的字段不适合建立索引。</p>
<p>#5.Where条件里用不到的字段不创建索引。</p>
<h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><p>①MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。<br>②order by满足两种情况会使用Using index。</p>
<p>#1.order by语句使用索引最左前列。</p>
<p>#2.使用where子句与order by子句条件列组合满足索引最左前列。<br>③尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最佳左前缀法则。<br>④如果order by的条件不在索引列上，就会产生Using filesort。<br>⑤提升order by速度的方式：</p>
<p>#1.在使用order by时，不要用select *，只查询所需的字段。<br>因为当查询字段过多时，会导致sort_buffer不够，从而使用多路排序或进行多次I/O操作。</p>
<p>#2.尝试提高sort_buffer_size。</p>
<p>#3.尝试提高max_length_for_sort_data。</p>
<p><img src="\images\pasted-114.png" alt="upload successful"><br>⑦group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最佳左前缀法则。当无法使用索引列的时候，也要对sort_buffer_size和max_length_for_sort_data参数进行调整。注意where高于having，能写在where中的限定条件就不要去having限定了。</p>
<h2 id="何时使用聚簇索引与非聚簇索引"><a href="#何时使用聚簇索引与非聚簇索引" class="headerlink" title="何时使用聚簇索引与非聚簇索引"></a>何时使用聚簇索引与非聚簇索引</h2><p><img src="\images\pasted-115.png" alt="upload successful"></p>
<p><img src="\images\pasted-116.png" alt="upload successful"></p>
<p><img src="\images\pasted-117.png" alt="upload successful"><br>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。<br>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</p>
<p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<h2 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h2><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？</p>
<p>由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
<p>辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。<br>聚簇索引适合用在排序的场合，非聚簇索引不适合<br>取出一定范围数据的时候，使用用聚簇索引<br>二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据<br>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</p>
<h2 id="聚簇索引的劣势"><a href="#聚簇索引的劣势" class="headerlink" title="聚簇索引的劣势"></a>聚簇索引的劣势</h2><p>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片<br>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，</p>
<p>主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）</p>
<p>如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</p>
<h2 id="mysql中聚簇索引的设定"><a href="#mysql中聚簇索引的设定" class="headerlink" title="mysql中聚簇索引的设定"></a>mysql中聚簇索引的设定</h2><p>聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。</p>
<h2 id="垂直拆分-专库专用"><a href="#垂直拆分-专库专用" class="headerlink" title="垂直拆分-专库专用"></a>垂直拆分-专库专用</h2><p>一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：</p>
<p><img src="\images\pasted-20.png" alt="upload successful"></p>
<p>优点：</p>
<pre><code>1. 拆分后业务清晰，拆分规则明确。
2. 系统之间整合或扩展容易。
3. 数据维护简单。
</code></pre><p>缺点：</p>
<pre><code>1. 部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。
2. 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。
3. 事务处理复杂。
</code></pre><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。</p>
<p>相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式，如图：</p>
<p><img src="\images\pasted-21.png" alt="upload successful"></p>
<p><img src="\images\pasted-22.png" alt="upload successful"><br>优点：</p>
<pre><code>1. 不存在单库大数据，高并发的性能瓶颈。
2. 对应用透明，应用端改造较少。     
3. 按照合理拆分规则拆分，join操作基本避免跨库。
4. 提高了系统的稳定性跟负载能力。
</code></pre><p>缺点：</p>
<pre><code>1. 拆分规则难以抽象。
2. 分片事务一致性难以解决。
3. 数据多次扩展难度跟维护量极大。
4. 跨库join性能较差。
</code></pre><p>垂直拆分：<br>　　解决问题：<br>　　表与表之间的io竞争<br>　　不解决问题：<br>　　单表中数据量增长出现的压力<br>　　方案：<br>　　把产品表和用户表放到一个server上<br>　　订单表单独放到一个server上<br>水平拆分：<br>　　解决问题：<br>　　单表中数据量增长出现的压力<br>　　不解决问题：<br>　　表与表之间的io争夺<br>　　方案：<br>　　用户表通过性别拆分为男用户表和女用户表<br>　　订单表通过已完成和完成中拆分为已完成订单和未完成订单<br>　　产品表 未完成订单放一个server上<br>　　已完成订单表盒男用户表放一个server上<br>　　女用户表放一个server上(女的爱购物)</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>第一种：php程序上自己做逻辑判断，写php代码的时候，自己在程序上做逻辑判读写匹配。select，insert、update、delete做正则匹配，根据结果选择写服务器（主服务器）。如果是select操作则选择读服务器（从服务器器） mysql_connect(‘读写的区分’)</p>
<p>第二种：MySQL- Proxy是实现”读写分离(Read/Write Splitting)”的一个软件（MySQL官方提供 ，也叫中间件）<br>基本的原理<br>让主数据库处理写操作（insert、update、delete），<br>而从数据库处理查询操作（select）。<br>而数据库的一致性则通过主从复制来实现。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>在一主多从的数据库体系中，多个从服务器采用异步的方式更新主数据库的变化，<br>业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，<br>读操作则是在各从服务器上进行。</p>
<p><img src="\images\pasted-70.png" alt="upload successful"><br>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p>
<h2 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h2><p>加锁可以实现数据库并发控制。<br>事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
<h2 id="mysql有哪几种锁？"><a href="#mysql有哪几种锁？" class="headerlink" title="mysql有哪几种锁？"></a>mysql有哪几种锁？</h2><p>Myisam支持表锁，innodb支持行锁与表锁，默认为行锁（需要索引）</p>
<h2 id="表锁行锁区别？"><a href="#表锁行锁区别？" class="headerlink" title="表锁行锁区别？"></a>表锁行锁区别？</h2><p>表锁：开销小，加锁快，不会出现死锁，锁粒度大，发送锁冲突概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p>
<h2 id="Mysql数据库表类型？"><a href="#Mysql数据库表类型？" class="headerlink" title="Mysql数据库表类型？"></a>Mysql数据库表类型？</h2><p>MyISAM（MySQL的默认数据表类型 事务不安全 不支持外键 假如忽略事务以及访问并发性的话，并且需要执行大量的SELECT检索语句的话，MyISAM将是最好的选择）<br>Heap（MySQL中存取数据最快的表。这是因为他们使用存储在动态内存中的一个散列索引，不过如果MySQL或服务器崩溃，这些内存数据将会丢失。）<br>Merge（MERGE表实际上是又一个MyISAM表的集合）<br>INNODB（事务安全，支持外键）<br>ISAM（早期MySQL版本的缺省表类型，直到MyIASM开发出来。建议不要再使用它）<br>DBD（支持事务处理的表）</p>
<p>MyISAM是Mysql的默认存储引擎。</p>
<h2 id="简述在MySQL数据库中MyISAM和InnoDB的区别"><a href="#简述在MySQL数据库中MyISAM和InnoDB的区别" class="headerlink" title="简述在MySQL数据库中MyISAM和InnoDB的区别"></a>简述在MySQL数据库中MyISAM和InnoDB的区别</h2><p>存储引擎是基于表的，而不是数据库。<br>InnoDB存储引擎: 行锁设计、支持外键,支持事务，支持并发，锁粒度是支持mvcc的行级锁；<br>MyISAM存储引擎: MySQL官方存储引擎，主要面向在线分析处理方面的应用，不支持事务，锁粒度是支持并发插入得表级锁，支持表锁和全文索引。操作速度快，不能读写操作太频繁。</p>
<h2 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h2><p>read uncommited ：读到未提交数据<br>read committed：脏读，不可重复读<br>repeatable read：可重读<br>serializable ：串行事物</p>
<h2 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h2><p>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。<br>（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。<br>（2）一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>（3）隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，<br>（4）持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p>
<p>要将组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。</p>
<h2 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h2><p>1、CHAR（M）定长，M取值0-255<br>2、当保存char值时，在它们的右边填充空格以达到指定的长度<br>3、当检索到char值时，尾部的空格被删除掉，char字段上的索引效率很高。<br>4、varchar的数据类型长度支持到了65535。起始位和结束位占去了3个字节，所以其整体最大长度为65532字节<br>5、varchar值保存时只保存需要的字符数，另加一个字节来记录长度（长度超过255时需要2个字节）</p>
<h2 id="LIKE声明中的％和-是什么意思？"><a href="#LIKE声明中的％和-是什么意思？" class="headerlink" title="LIKE声明中的％和_是什么意思？"></a>LIKE声明中的％和_是什么意思？</h2><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
<h2 id="如何在Unix和Mysql时间戳之间进行转换？"><a href="#如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="如何在Unix和Mysql时间戳之间进行转换？"></a>如何在Unix和Mysql时间戳之间进行转换？</h2><p>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令<br>FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</p>
<h2 id="列对比运算符是什么？"><a href="#列对比运算符是什么？" class="headerlink" title="列对比运算符是什么？"></a>列对比运算符是什么？</h2><p>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</p>
<h2 id="BLOB和TEXT有什么区别？"><a href="#BLOB和TEXT有什么区别？" class="headerlink" title="BLOB和TEXT有什么区别？"></a>BLOB和TEXT有什么区别？</h2><p>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。<br>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p>
<h2 id="mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>mysql_fetch_array和mysql_fetch_object的区别是什么？</h2><p>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。<br>mysql_fetch_object – 从数据库返回结果行作为对象。</p>
<h2 id="MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>MyISAM表格将在哪里存储，并且还提供其存储格式？</h2><p>每个MyISAM表格以三种格式存储在磁盘上：<br>·“.frm”文件存储表定义<br>·数据文件具有“.MYD”（MYData）扩展名<br>·索引文件具有“.MYI”（MYIndex）扩展名</p>
<h2 id="可以使用多少列创建索引？"><a href="#可以使用多少列创建索引？" class="headerlink" title="可以使用多少列创建索引？"></a>可以使用多少列创建索引？</h2><p>任何标准表最多可以创建16个索引列。</p>
<h2 id="如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>如果一个表有一列定义为TIMESTAMP，将发生什么？</h2><p>每当行被更改时，时间戳字段将获取当前时间戳。</p>
<h2 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h2><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p>
<h2 id="为表中得字段选择合适得数据类型"><a href="#为表中得字段选择合适得数据类型" class="headerlink" title="为表中得字段选择合适得数据类型"></a>为表中得字段选择合适得数据类型</h2><p>字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text<br>优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型</p>
<h2 id="NOW（）和CURRENT-DATE（）有什么区别？"><a href="#NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="NOW（）和CURRENT_DATE（）有什么区别？"></a>NOW（）和CURRENT_DATE（）有什么区别？</h2><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。</p>
<h2 id="MySQL数据库作发布系统的存储，数据量增大的情况，怎么优化？"><a href="#MySQL数据库作发布系统的存储，数据量增大的情况，怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，数据量增大的情况，怎么优化？"></a>MySQL数据库作发布系统的存储，数据量增大的情况，怎么优化？</h2><ol>
<li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li>
<li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li>
<li>mysql库主从读写分离。</li>
<li>找规律分表，减少单表中的数据量提高查询速度。</li>
<li>添加缓存机制，比如memcached，apc等。</li>
<li>不经常改动的页面，生成静态页面。</li>
<li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</li>
</ol>
<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><ol>
<li>读写分离</li>
<li>分段加锁</li>
<li>减少锁持有的时间</li>
<li>多个线程尽量以相同的顺序去获取资源<br>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</li>
</ol>
<h2 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h2><p>1.以“%”开头的LIKE语句，模糊匹配</p>
<ol start="2">
<li><p>OR语句前后没有同时使用索引</p>
</li>
<li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</p>
</li>
</ol>
<h2 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h2><p><a href="https://www.toutiao.com/i6599796228886626829/?group_id=6599796228886626829" target="_blank" rel="noopener">https://www.toutiao.com/i6599796228886626829/?group_id=6599796228886626829</a><br>最好是按照以下顺序优化：</p>
<p>1.SQL语句及索引的优化<br>2.数据库表结构的优化<br>3.系统配置的优化<br>4.硬件的优化</p>
<h2 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h2><p>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM<br>使用连接(JOIN)来代替子查询<br>适用联合(UNION)来代替手动创建的临时表<br>事务处理<br>锁定表、优化事务处理<br>适用外键，优化锁定表<br>建立索引<br>优化查询语句</p>
<h2 id="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"><a href="#简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）" class="headerlink" title="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"></a>简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）</h2><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。</p>
<p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</p>
<p>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</p>
<p>索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。</p>
<p>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p>
<h2 id="SQL注入漏洞产生的原因？如何防止？"><a href="#SQL注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL注入漏洞产生的原因？如何防止？"></a>SQL注入漏洞产生的原因？如何防止？</h2><p>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。<br>防止SQL注入的方式：<br>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置<br>执行sql语句时使用addslashes进行sql语句转换<br>Sql语句书写尽量不要省略双引号和单引号。<br>过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
<h2 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h2><p>B+树，经过优化的B+树<br>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</p>
<h2 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h2><p>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>1普通索引<br>是最基本的索引，它没有任何限制。</p>
<p>2唯一索引<br>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>3组合索引<br>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。</p>
<p>4主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</p>
<p>5全文索引<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引<br>尽量使用短索引，如果可以，应该制定一个前缀长度<br>对于经常在where子句使用的列，最好设置索引，这样会加快查找速度<br>对于有多个列where或者order by子句的，应该建立复合索引<br>对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引<br>尽量不要在列上进行运算（函数操作和表达式操作）<br>尽量不要使用not in和&lt;&gt;操作</p>
<h2 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h2><p>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
<h2 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h2><p>1、对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>2、对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p>
<h2 id="Mysql中的事务回滚机制概述"><a href="#Mysql中的事务回滚机制概述" class="headerlink" title="Mysql中的事务回滚机制概述"></a>Mysql中的事务回滚机制概述</h2><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p>
<p>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</p>
<h2 id="SQL语言包括哪几部分？每部分都有哪些操作关键字？"><a href="#SQL语言包括哪几部分？每部分都有哪些操作关键字？" class="headerlink" title="SQL语言包括哪几部分？每部分都有哪些操作关键字？"></a>SQL语言包括哪几部分？每部分都有哪些操作关键字？</h2><p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。<br>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等<br>数据操纵：Select ,insert,update,delete,<br>数据控制：grant,revoke<br>数据查询：select</p>
<h2 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h2><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p>
<p>分为以下四类：</p>
<p>1) 实体完整性：规定表的每一行在表中是惟一的实体。<br>2) 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。<br>3) 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。<br>4) 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</p>
<p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p>
<h2 id="什么叫视图？游标是什么？"><a href="#什么叫视图？游标是什么？" class="headerlink" title="什么叫视图？游标是什么？"></a>什么叫视图？游标是什么？</h2><p>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。</p>
<h2 id="如何通俗地理解三个范式？"><a href="#如何通俗地理解三个范式？" class="headerlink" title="如何通俗地理解三个范式？"></a>如何通俗地理解三个范式？</h2><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。</p>
<h2 id="范式化设计优缺点"><a href="#范式化设计优缺点" class="headerlink" title="范式化设计优缺点:"></a>范式化设计优缺点:</h2><p>优点:<br>可以尽量得减少数据冗余，使得更新快，体积小<br>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</p>
<p>反范式化:<br>优点:可以减少表得关联，可以更好得进行索引优化<br>缺点:数据冗余以及数据异常，数据得修改需要更多的成本</p>
<h2 id="什么是基本表？什么是视图？"><a href="#什么是基本表？什么是视图？" class="headerlink" title="什么是基本表？什么是视图？"></a>什么是基本表？什么是视图？</h2><p>答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</p>
<h2 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h2><p>答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； (3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。</p>
<h2 id="NULL是什么意思"><a href="#NULL是什么意思" class="headerlink" title="NULL是什么意思"></a>NULL是什么意思</h2><p>答：NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。</p>
<p>使用IS NULL来进行NULL判断</p>
<h2 id="主键、外键和索引的区别？"><a href="#主键、外键和索引的区别？" class="headerlink" title="主键、外键和索引的区别？"></a>主键、外键和索引的区别？</h2><p>定义：<br>主键–唯一标识一条记录，不能有重复的，不允许为空<br>外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值<br>索引–该字段没有重复值，但可以有一个空值</p>
<p>作用：<br>主键–用来保证数据完整性<br>外键–用来和其他表建立联系用的<br>索引–是提高查询排序的速度</p>
<p>个数：<br>主键–主键只能有一个<br>外键–一个表可以有多个外键<br>索引–一个表可以有多个唯一索引</p>
<h2 id="你可以用什么来确保表格里的字段只接受特定范围里的值"><a href="#你可以用什么来确保表格里的字段只接受特定范围里的值" class="headerlink" title="你可以用什么来确保表格里的字段只接受特定范围里的值?"></a>你可以用什么来确保表格里的字段只接受特定范围里的值?</h2><p>Check限制，它在数据库表格里被定义，用来限制输入该列的值。</p>
<h2 id="MVCC基本特征"><a href="#MVCC基本特征" class="headerlink" title="MVCC基本特征"></a>MVCC基本特征</h2><p>每行数据都存在一个版本，每次数据更新时都更新该版本。<br>修改时Copy出当前版本随意修改，各个事务之间无干扰。<br>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</p>
<p>InnoDB存储引擎MVCC的实现策略<br>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p>
<p>每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</p>
<h2 id="MVCC优缺点"><a href="#MVCC优缺点" class="headerlink" title="MVCC优缺点"></a>MVCC优缺点</h2><p>MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。</p>
<h2 id="mvcc如何解决幻读"><a href="#mvcc如何解决幻读" class="headerlink" title="mvcc如何解决幻读"></a>mvcc如何解决幻读</h2><p>保证一个事务<br>读不了在它之后插入的数据，读不了在它之前删除的数据<br>读的了在它之前插入的数据，读的了在它之后删除的数据</p>
<p>查询条件<br>1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)。不能读取&lt;=当前事务版本号的被删除数据</p>
<p>2) 创建版本号&lt;=当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。 不能读取在当前事务之后创建的数据</p>
<p>当前事务版本号为100，能够读取：数据的删除版本号&gt;100且创建版本号&lt;=100</p>
<p>多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号+1。<br>在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号&lt;=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。<br>例如：<br>此时books表中有5条数据，版本号为1<br>事务A，系统版本号2：select <em> from books；因为1&lt;=2所以此时会读取5条数据。<br>事务B，系统版本号3：insert into books …，插入一条数据，新插入的数据版本号为3，而其他的数据的版本号仍然是2，插入完成之后commit，事务结束。<br>事务A，系统版本号2：再次select </em> from books；只能读取&lt;=2的数据，事务B新插入的那条数据版本号为3，因此读不出来，解决了幻读的问题。</p>
<p>1：当前读:给改条数据加锁(悲观锁),即读取的时候就加锁，防止其他事务读取该数据().它能保证读取的都是最新数据<br>2：快照读:mvcc，多版本并发控制，详细的原理就不说了，它使得读写不冲突，由于读的都是事务的当前版本的数据，因此重复读也不会发现数据被修改</p>
<p>DELETE<br>InnoDB会为删除的每一行保存当前事务的ID作为删除标识.</p>
<p>UPDATE<br>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】PHP</title>
    <url>/2020/04/14/%E6%80%BB%E7%BB%93%E3%80%91php%E7%9F%A5%E8%AF%86%E7%B4%AF%E8%AE%A1%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="php常用字符串函数"><a href="#php常用字符串函数" class="headerlink" title="php常用字符串函数"></a>php常用字符串函数</h2><p>strlen($str);//返回字符串长度 mb_strlen($str) 可以返回中文字符长度</p>
<p>strtolower($str);//字母转小写</p>
<p>strtoupper($str);//字母转大写</p>
<p>ucwords($str);//每一个单词的首字母转大写</p>
<p>ucfirst($str);//首字母转大写</p>
<p>str_replace(‘a’,’b’,$str);//b替换$str 中的a 区分大小写  ;</p>
<p>str_ireplace(‘a’,’b’,$str);//替换 不区分大小写</p>
<p>htmlspecialchars($str,ENT_NOQUOTES);//字符串转换为html 实体 ENT_COMPT(默认只编译双引号)ENT_QUOTES单引号双引号都编译,ENT_NOQUOTES不编译任何引号</p>
<p>trim($str);//删除字符串前后（左右）空格</p>
<p>ltrim($str);//只删除字符串左侧的空格</p>
<p>rtrim($str);//只删除字符串右侧的空格<br>//trim加第二个参数 就是移除指定的字符集 如ltrim($str,’0..9’) 移除左侧数字开头的字符</p>
<p>strpos($str,’a’);//字符串a 在$str 第一次出现的位置 索引0开始 没有出现返回false 区分大小写</p>
<p>stripos($str,’a’);//同上 但是不区分大小写</p>
<p>strrpos($str,’a’);//字符串a 在$str 最后一次出现的位置 索引0开始 没有出现返回false 区分大小写</p>
<p>strripos($str,’a’);//同上 但是不区分大小写</p>
<p>substr($str,0,3);//截取字符串 $str 的第一个字符 截取长度3 长度不填默认截取到最后  参数为负数则倒数</p>
<p>strstr($str,’a’);//截取字符串 $str 中的第一个字符’a’后的字符串 如 sabc -&gt; abc</p>
<p>strrchr($str,’a’);//截取字符串 $str 中最后一一个字符’a’后的字符串</p>
<p>strrev($str);//字符串反转 abcd-&gt;dcba</p>
<p>md5($str);//字符串MD5加密</p>
<p>str_shuffle($str);//随机打乱字符串顺序</p>
<p>explode(‘-‘,$str);//指定分隔符分割字符串 返回数组 ‘-’ 分割$str</p>
<p>implode(‘-‘,$str);//数组拼接字符串 与explode()相反</p>
<h2 id="php常用数组操作"><a href="#php常用数组操作" class="headerlink" title="php常用数组操作"></a>php常用数组操作</h2><p>一、数组操作的基本函数</p>
<p>数组的键名和值<br>array_values($arr);  获得数组的值<br>array_keys($arr);  获得数组的键名<br>array_flip($arr);  数组中的值与键名互换（如果有重复前面的会被后面的覆盖）<br>in_array(“apple”,$arr);  在数组中检索apple<br>array_search(“apple”,$arr);  在数组中检索apple ，如果存在返回键名<br>array_key_exists(“apple”,$arr);  检索给定的键名是否存在数组中<br>isset($arr[apple]):   检索给定的键名是否存在数组中</p>
<p>数组的内部指针<br>current($arr);  返回数组中的当前单元<br>pos($arr);  返回数组中的当前单元<br>key($arr);  返回数组中当前单元的键名<br>prev($arr);  将数组中的内部指针倒回一位<br>next($arr);  将数组中的内部指针向前移动一位<br>end($arr);  将数组中的内部指针指向最后一个单元<br>reset($arr;  将数组中的内部指针指向第一个单元<br>each($arr);  将返回数组当前元素的一个键名/值的构造数组，并使数组指针向前移动一位<br>list($key,$value)=each($arr);  获得数组当前元素的键名和值</p>
<p>数组和变量之间的转换<br>extract($arr);用于把数组中的元素转换成变量导入到当前文件中，键名当作变量名，值作为变量值<br>注：（第二个参数很重要，可以看手册使用）使用方法 echo $a;<br>compact(var1,var2,var3);用给定的变量名创建一个数组</p>
<p>二、数组的分段和填充</p>
<p>数组的分段<br>array_slice($arr,0,3);  可以将数组中的一段取出，此函数忽略键名<br>array_splice($arr,0,3，array(“black”,”maroon”));  可以将数组中的一段取出，与上个函数不同在于返回的序列从原数组中删除</p>
<p>分割多个数组<br>array_chunk($arr,3,TRUE);  可以将一个数组分割成多个，TRUE为保留原数组的键名</p>
<p>数组的填充<br>array_pad($arr,5,’x’);  将一个数组填补到制定长度</p>
<p>三、数组与栈</p>
<p>array_push($arr,”apple”,”pear”);  将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数<br>array_pop($arr);  将数组栈的最后一个元素弹出（出栈）</p>
<p>四、数组与列队</p>
<p>array_shift($arr);数组中的第一个元素移出并作为结果返回（数组长度减1，其他元素向前移动一位，数字键名改为从零技术，文字键名不变）<br>array_unshift($arr,”a”,array(1,2));在数组的开头插入一个或多个元素</p>
<p>五、回调函数</p>
<p>array_walk($arr,’function’,’words’);  使用用户函数对数组中的每个成员进行处理（第三个参数传递给回调函数function）<br>array_mpa(“function”,$arr1,$arr2);  可以处理多个数组（当使用两个或更多数组时，他们的长度应该相同）<br>array_filter($arr,”function”);  使用回调函数过滤数组中的每个元素，如果回调函数为TRUE，数组的当前元素会被包含在返回的结果数组中，数组的键名保留不变<br>array_reduce($arr,”function”,”<em>“);  转化为单值函数（</em>为数组的第一个值）</p>
<p>六、数组的排序</p>
<p>通过元素值对数组排序<br>sort($arr);  由小到大的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序<br>rsort($arr);  由大到小的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序<br>usort($arr,”function”);  使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）忽略键名的数组排序<br>asort($arr);  由小到大的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序<br>arsort($arr);  由大到小的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序<br>uasort($arr,”function”);  使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）保留键名的数组排序</p>
<p>通过键名对数组排序<br>ksort($arr);  按照键名正序排序<br>krsort($arr);  按照键名逆序排序<br>uksort($arr,”function”);  使用用户自定义的比较函数对数组中的键名进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）</p>
<p>自然排序法排序<br>natsort($arr);  自然排序（忽略键名）<br>natcasesort($arr);  自然排序（忽略大小写，忽略键名）</p>
<p>七、数组的计算</p>
<p>数组元素的求和<br>array_sum($arr);  对数组内部的所有元素做求和运算</p>
<p>数组的合并<br>array_merge($arr1,$arr2);  合并两个或多个数组（相同的字符串键名，后面的覆盖前面的，相同的数字键名，后面的不会做覆盖操作，而是附加到后面）<br>“+”$arr1+$arr2;  对于相同的键名只保留后一个<br>array_merge_recursive($arr1,$arr2);   递归合并操作，如果数组中有相同的字符串键名，这些值将被合并到一个数组中去。如果一个值本身是一个数组，将按照相应的键名把它合并为另一个数组。当数组 具有相同的数组键名时，后一个值将不会覆盖原来的值，而是附加到后面</p>
<p>数组的差集<br>array_diff($arr1,$arr2);  返回差集结果数组<br>array_diff_assoc($arr1,$arr2,$arr3);  返回差集结果数组，键名也做比较</p>
<p>数组的交集<br>array_intersect($arr1,$arr2);  返回交集结果数组<br>array_intersect_assoc($arr1,$arr2);  返回交集结果数组，键名也做比较</p>
<p>八、其他的数组函数</p>
<p>range(0,12);  创建一个包含指定范围单元的数组<br>array_unique($arr);  移除数组中重复的值，新的数组中会保留原始的键名<br>array_reverse($arr,TRUE);  返回一个单元顺序与原数组相反的数组，如果第二个参数为TRUE保留原来的键名<br>//srand((float)microtime()*10000000);   随机种子触发器<br>array_rand($arr,2);  从数组中随机取出一个或 多个元素<br>shuffle($arr);  将数组的顺序打乱</p>
<h2 id="PHP单列封装redis数据库访问"><a href="#PHP单列封装redis数据库访问" class="headerlink" title="PHP单列封装redis数据库访问"></a>PHP单列封装redis数据库访问</h2><p>三私一公<br>私有静态属性<br>私有构造方法<br>私有克隆方法<br>公有静态方法<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $handle = <span class="keyword">NULL</span>;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="keyword">static</span> $_instance = <span class="keyword">NULL</span>;        <span class="comment">//定义私有的属性变量</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;   <span class="comment">//定义公用的静态方法</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (<span class="keyword">NULL</span> == <span class="keyword">self</span>::$_instance) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">self</span>::$_instance = <span class="keyword">new</span> <span class="keyword">self</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">self</span>::$_instance;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">    $redis = <span class="keyword">new</span> Redis();          <span class="comment">//实例化redis</span></span></span><br><span class="line"><span class="php">    $redis-&gt;connect(<span class="string">'127.0.0.1'</span>,<span class="number">6379</span>);</span></span><br><span class="line"><span class="php">    <span class="comment">//$redis-&gt;auth(Conf::AUTH);</span></span></span><br><span class="line"><span class="php">    <span class="keyword">$this</span>-&gt;handle = &amp;$redis;       <span class="comment">//将变量与redis通过引用符关联在一起，以后直接使用handle即可，相当于将redis付给一个变量，这是另一种写法</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;handle-&gt;close();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hget</span><span class="params">($k,$v)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handle-&gt;hget($k , $v);  <span class="comment">//获取redis键名</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">$test = Handle::getInstance();</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> $test-&gt;hget(<span class="number">1</span>,<span class="number">1</span>);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="PHP生成器函数"><a href="#PHP生成器函数" class="headerlink" title="PHP生成器函数"></a>PHP生成器函数</h2><p>生成器函数的核心是yield关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">my_range</span><span class="params">($start,$limit)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">for</span>($i=$start;$i&lt;=$limit;$i++)&#123;</span><br><span class="line">		<span class="keyword">yield</span> $i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $num)&#123;</span><br><span class="line">	<span class="keyword">echo</span> $num.PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="php内置常量"><a href="#php内置常量" class="headerlink" title="php内置常量"></a>php内置常量</h2><p><img src="\images\pasted-127.png" alt="upload successful"></p>
<p>关于http头 <a href="https://www.cnblogs.com/poissonnotes/p/4844014.html" target="_blank" rel="noopener">https://www.cnblogs.com/poissonnotes/p/4844014.html</a></p>
<h2 id="PHP拷贝机制"><a href="#PHP拷贝机制" class="headerlink" title="PHP拷贝机制"></a>PHP拷贝机制</h2><p>深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个<br>浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个<br>PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号）<br>php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。</p>
<h2 id="php的线程与进程"><a href="#php的线程与进程" class="headerlink" title="php的线程与进程"></a>php的线程与进程</h2><p>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。</p>
<p>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</p>
<p>PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展，而要安装 pthread 扩展，必须使用 –enable-maintainer-zts 参数重新编译 PHP，这个参数是指定编译 PHP 时使用线程安全方式。</p>
<p>什么是线程安全?<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<h2 id="什么是PDO？"><a href="#什么是PDO？" class="headerlink" title="什么是PDO？"></a>什么是PDO？</h2><p>PDO就是PHP data Object 提供了PHP操作多种1（12种）数据库的统一的接口</p>
<h2 id="为什么使用PDO？"><a href="#为什么使用PDO？" class="headerlink" title="为什么使用PDO？"></a>为什么使用PDO？</h2><p>PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可；</p>
<h2 id="PHP抽象类"><a href="#PHP抽象类" class="headerlink" title="PHP抽象类"></a>PHP抽象类</h2><p>抽象类与接口紧密相关，它们不能实例化，并且常常部分实现或根本不实现。抽象类和接口之间的一个主要差别是：类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承。从抽象类派生的类仍可实现接口。可以在创建组件时使用抽象类，因为它们使您得以在某些方法中指定不变级功能，但直到需要该类的特定实现之后才实现其他方法。抽象类也制定版本，因为如果在派生类中需要附加功能，则可以将其添加到基类而不中断代码。<br>PHP抽象类应用的定义：<br>abstract class ClassName{<br>}</p>
<h2 id="什么是抽象方法"><a href="#什么是抽象方法" class="headerlink" title="什么是抽象方法"></a>什么是抽象方法</h2><p>我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰；</p>
<h2 id="什么是php抽象类"><a href="#什么是php抽象类" class="headerlink" title="什么是php抽象类"></a>什么是php抽象类</h2><p>只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。</p>
<h2 id="PHP抽象类应用要点："><a href="#PHP抽象类应用要点：" class="headerlink" title="PHP抽象类应用要点："></a>PHP抽象类应用要点：</h2><p>　　1.定义一些方法，子类必须完全实现这个抽象中所有的方法<br>　　2.不能从抽象类创建对象，它的意义在于被扩展<br>　　3.抽象类通常具有抽象方法，方法中没有大括号</p>
<h2 id="PHP抽象类应用重点："><a href="#PHP抽象类应用重点：" class="headerlink" title="PHP抽象类应用重点："></a>PHP抽象类应用重点：</h2><p>　　1.抽象方法不必实现具体的功能，由子类来完成<br>　　2.在子类实现抽象类的方法时，其子类的可见性必须大于或等于抽象方法的定义<br>　　3.抽象类的方法可以有参数，也可以为空<br>　　4.如果抽象方法有参数，那么子类的实现也必须有相同的参数个数</p>
<p>PHP抽象类应用示例：<br>abstract public function_name(); //注意没有大括号</p>
<h2 id="PHP抽象类规则："><a href="#PHP抽象类规则：" class="headerlink" title="PHP抽象类规则："></a>PHP抽象类规则：</h2><p>某个类只要至少含有一个抽象方法，就必须声明为抽象类<br>抽象方法，不能够含有函数体<br>继承抽象类的子类，实现抽象方法的，必须跟该抽象方法具有相同或者更低的访问级别<br>继承抽象类的子类，如果不实现所有抽象方法，那么该子类也为抽象类</p>
<h2 id="计算矩形的周长"><a href="#计算矩形的周长" class="headerlink" title="计算矩形的周长"></a>计算矩形的周长</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt; ?PHP   </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;   </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">get_area</span><span class="params">()</span></span>;   </span><br><span class="line"><span class="comment">//和一般的方法不同的是，这个方法没有大括号   </span></span><br><span class="line"><span class="comment">//你不能创建这个抽象类的实例：$Shape_Rect= new Shape(); </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;   </span><br><span class="line"><span class="keyword">private</span> $width;   </span><br><span class="line"><span class="keyword">private</span> $height;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($width=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">$height=<span class="number">0</span>)</span></span>&#123;   </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">$this</span>-&gt;width=$width;   </span><br><span class="line">　　<span class="keyword">$this</span>-&gt;height=$height;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_area</span><span class="params">()</span></span>&#123;   </span><br><span class="line">　　<span class="keyword">echo</span> (<span class="keyword">$this</span>-&gt;width+<span class="keyword">$this</span>-&gt;height)*<span class="number">2</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">$Shape_Rect = <span class="keyword">new</span> Rectangle(<span class="number">20</span>,<span class="number">30</span>);   </span><br><span class="line">$Shape_Rect-&gt;get_area();   </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="php垃圾回收机制"><a href="#php垃圾回收机制" class="headerlink" title="php垃圾回收机制"></a>php垃圾回收机制</h2><p>转载： <a href="http://blog.csdn.net/u011957758/article/details/76864400" target="_blank" rel="noopener">http://blog.csdn.net/u011957758/article/details/76864400</a></p>
<p>refcount：多少个变量是一样的用了相同的值，这个数值就是多少。<br>is_ref：bool类型，当refcount大于2的时候，其中一个变量用了地址&amp;的形式进行赋值，好了，它就变成1了。</p>
<p>unset并非一定会释放内存，当有两个变量指向的时候，并非会释放变量占用的内存，只是refcount减1.</p>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<p>如果unset（$a）</p>
<p><img src="/images/pasted-3.png" alt="upload successful"><br>如果在小于php5.3的版本就会出现一个问题：$a已经不在符号表了，没有变量再指向此zval容器，用户已无法访问，但是由于数组的refcount变为1而不是0，导致此部分内存不能被回收从而产生了内存泄漏。</p>
<p>5.3之后版本处理垃圾<br>判断处理过程<br>1.如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾<br>2.如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾<br>3.如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾</p>
<p>白话文版：就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾</p>
<p><img src="/images/pasted-4.png" alt="upload successful"><br>A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。</p>
<p>B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。</p>
<p>C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性）</p>
<p>D：遍历zval节点，将C中标记成白色的节点zval释放掉。</p>
<pre><code>&lt;?php
$a = [&apos;one&apos;]; --- zval_a（将$a对应的zval，命名为zval_a）
$a[] = &amp;$a; --- step1
unset($a);  --- step2
</code></pre><p>为进行unset之前(step1)，进行算法计算，对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样说明zval_a不是一个垃圾不进行回收。</p>
<p>当执行unset的时候(step2)，进行算法计算，由于环形引用，上文得出会有垃圾的结构体，zval_a的refcount是1(zval_a中的索引1指向zval_a)，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就认为zval_a是一个需要回收的垃圾。</p>
<p>算法总的套路:对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。</p>
<p>unset<br>unset只是断开一个变量到一块内存区域的连接，同时将该内存区域的引用计数-1；内存是否回收主要还是看refount是否到0了，以及gc算法判断。</p>
<p>= null 操作；<br>a=null是直接将a 指向的数据结构置空，同时将其引用计数归0。</p>
<p>脚本执行结束<br>脚本执行结束，该脚本中使用的所有内存都会被释放，不论是否有引用环。</p>
<p><a href="https://blog.csdn.net/m_nanle_xiaobudiu/article/details/79251726" target="_blank" rel="noopener">https://blog.csdn.net/m_nanle_xiaobudiu/article/details/79251726</a></p>
<h2 id="php常用框架、模板引擎"><a href="#php常用框架、模板引擎" class="headerlink" title="php常用框架、模板引擎"></a>php常用框架、模板引擎</h2><p>框架：如CI、Yii、Laravel，thinkphp<br>模板引擎：smarty</p>
<h2 id="AJAX的优势？"><a href="#AJAX的优势？" class="headerlink" title="AJAX的优势？"></a>AJAX的优势？</h2><p>ajax是异步传输技术，可以通过javascript实现，也可以通过JQuery框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。</p>
<h2 id="程序的开发中提高程序的运行效率？"><a href="#程序的开发中提高程序的运行效率？" class="headerlink" title="程序的开发中提高程序的运行效率？"></a>程序的开发中提高程序的运行效率？</h2><p>（1）优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询。<br>（2）数据表中创建索引。<br>（3）对程序中经常用到的数据生成缓存（比如使用redis缓存数据，比如使用ob进行动态页面静态化等等）。<br>（4）对mysql做主从复制，读写分离。（提高mysq执行效率和查询速度）<br>（5）使用nginx做负载均衡。（将访问压力平均分配到多态服务器）</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>①可以实现代码的重用性，避免产生代码冗余；<br>②M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，json数据格式固定，可以被多种语言用作数据的传递。<br>PHP中处理json格式的函数为<br>json_decode( string $json [, bool $assoc ] ) ，接受一个 JSON格式的字符串并且把它转换为PHP变量，<br>Json_encode：将PHP变量转换成json格式。</p>
<h2 id="Print、echo、print-r区别"><a href="#Print、echo、print-r区别" class="headerlink" title="Print、echo、print_r区别"></a>Print、echo、print_r区别</h2><p>（1） echo和print都可以做输出，不同的是，echo不是函数，没有返回值，而print是一个函数有返回值，所以相对而言如果只是输出echo会更快，而print_r通常用于打印变量的相关信息，通常在调试中使用。<br>（2） print 是打印字符串<br>（3）print_r 则是打印复合类型 如数组 对象</p>
<h2 id="SESSION与COOKIE的区别？"><a href="#SESSION与COOKIE的区别？" class="headerlink" title="SESSION与COOKIE的区别？"></a>SESSION与COOKIE的区别？</h2><p>（1）存储位置：session存储于服务器，cookie存储于浏览器<br>（2）安全性：session安全性比cookie高<br>（3）session为‘会话服务’，在使用时需要开启服务，cookie不需要开启，可以直接用</p>
<p>PHP操作文件的常用函数？（重点看函数的‘参数’和‘返回值’）</p>
<p>（1）打开文件 fopen()<br>$file = fopen(“/home/test/test.txt”,”r”);<br><a href="http://www.w3school.com.cn/php/func_filesystem_fopen.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_filesystem_fopen.asp</a><br>（2）读取文件 fgets()  ;  注：file_get_contents()也是读取文件<br>fgets() 函数从文件指针中读取一行。<br>fgets(file,length)<br>（3）写入文件fwrite()  ;  注：file_put_contents()同样可以写入文件<br>（4）关闭文件句柄 fclose()<br>（5）移动 / 重命名文件 rename()<br>（6）复制文件 copy()<br>（7）创建文件 vim  或 touch<br>（8）删除文件 unlink()<br>（9）获取文件上次访问的时间 fileatime()<br>（10）获取文件上次修改的时间 filemtime()<br>（11）获取文件大小 filesize()<br>（12）获取文件类型  filetype()<br>（13）获取文件详细信息 state()<br>（14）判断是否是目录 is_dir()</p>
<h2 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h2><p>(1) 视图能够简化用户的操作<br>(2) 视图使用户能以多种角度看待同一数据；<br>(3) 视图为数据库提供了一定程度的逻辑独立性；<br>(4) 视图能够对机密数据提供安全保护。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？<br>（1）设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。<br>（2） 选择合适的表字段数据类型和存储引擎，适当的添加索引。<br>（3） 做mysql主从复制读写分离。<br>（4）对数据表进行分表，减少单表中的数据量提高查询速度。<br>（5）添加缓存机制，比如redis，memcached等。<br>（6）对不经常改动的页面，生成静态页面（比如做ob缓存）。<br>（7）书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</p>
<h2 id="简述-private、-protected、-public修饰符的访问权限。"><a href="#简述-private、-protected、-public修饰符的访问权限。" class="headerlink" title="简述 private、 protected、 public修饰符的访问权限。"></a>简述 private、 protected、 public修饰符的访问权限。</h2><p>private : 私有成员, 在类的内部才可以访问。</p>
<p>protected : 保护成员，该类内部和继承类中可以访问。</p>
<p>public : 公共成员，完全公开，没有访问限制。</p>
<h2 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h2><p>栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；</p>
<p>堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。</p>
<h2 id="XML-与-HTML-的主要区别"><a href="#XML-与-HTML-的主要区别" class="headerlink" title="XML 与 HTML 的主要区别"></a>XML 与 HTML 的主要区别</h2><p>语法要求不同：</p>
<p>（1）在html中不区分大小写，在xml中严格区分。</p>
<p>（2）在HTML中，有时不严格，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略</p>或者之类的结束标记。在XML中，是严格的树状结构，绝对不能省略掉结束标记。<p></p>
<p>（3） 在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个/ 字符作为结尾。这样分析器就知道不用查找结束标记了。</p>
<p>（4）在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。 </p>
<p>（5）在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。 </p>
<p>（6） 在XML文档中，空白部分不会被解析器自动删除；但是html是过滤掉空格的。</p>
<p>标记不同：</p>
<p>（1）html使用固有的标记；而xml没有固有的标记。</p>
<p>（2）Html标签是预定义的；XML标签是免费的、自定义的、可扩展的。</p>
<p>作用不同：</p>
<p>（1）html是用来显示数据的；xml是用来描述数据、存放数据的，所以可以作为持久化的介质！Html将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。 XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。</p>
<p>（2）xml不是HTML的替代品，xml和html是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同HTML 的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。</p>
<p>（3）对于XML最好的形容可能是: XML是一种跨平台的，与软、硬件无关的，处理与传输信息的工具。</p>
<p>（4）XML未来将会无所不在。XML将成为最普遍的数据处理和数据传输的工具。</p>
<h2 id="抽象类和接口的概念以及区别？"><a href="#抽象类和接口的概念以及区别？" class="headerlink" title="抽象类和接口的概念以及区别？"></a>抽象类和接口的概念以及区别？</h2><p>抽象类：它是一种特殊的，不能被实例化的类，只能作为其他类的父类使用。使用abstract关键字声明。<br>接口：它是一种特殊的抽象类，也是一个特殊的类，使用interface声明。</p>
<p>区别：<br>（1）抽象类的操作通过继承关键字extends实现，而接口的使用是通过implements关键字来实现。<br>（2）抽象类中有数据成员，可以实现数据的封装，但是接口没有数据成员。<br>（3）抽象类中可以有构造方法，但是接口没有构造方法。<br>（4）抽象类的方法可以通过private、protected、public关键字修饰（抽象方法不能是private），而接口中的方法只能使用public关键字修饰。<br>（5）一个类只能继承于一个抽象类，而一个类可以同时实现多个接口。<br>（6）抽象类中可以有成员方法的实现代码，而接口中不可以有成员方法的实现代码。</p>
<h2 id="什么是构造函数，什么是析构函数，作用是什么？"><a href="#什么是构造函数，什么是析构函数，作用是什么？" class="headerlink" title="什么是构造函数，什么是析构函数，作用是什么？"></a>什么是构造函数，什么是析构函数，作用是什么？</h2><p>构造函数（方法）是对象创建完成后第一个被对象自动调用的方法。它存在于每个声明的类中，是一个特殊的成员方法。作用是执行一些初始化的任务。Php中使用__construct()声明构造方法，并且只能声明一个。</p>
<p>析构函数（方法）作用和构造方法正好相反，是对象被销毁之前最后一个被对象自动调用的方法。是PHP5中新添加的内容作用是用于实现在销毁一个对象之前执行一些特定的操作，诸如关闭文件和释放内存等。</p>
<h2 id="isnull-empty-isset"><a href="#isnull-empty-isset" class="headerlink" title="isnull empty isset"></a>isnull empty isset</h2><p><img src="\images\pasted-126.png" alt="upload successful"><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$a = [<span class="string">'null'</span>];</span></span><br><span class="line"><span class="php">print_r(<span class="keyword">isset</span>($a)) ;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">print_r(<span class="keyword">empty</span>($a));</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">print_r(is_null($a));</span></span><br><span class="line"><span class="php"><span class="comment">//                  isset empty isnull</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=null            0     1     1</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=0               1     1     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=false           1     1     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=""              1     1     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a="0"             1     1     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=[]              1     1     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a=1               1     0     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//a="null"          1     0     0</span></span></span><br><span class="line"><span class="php"><span class="comment">//$a = ['null'];    1     0     0</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//不定义            0     1     wrong&amp;1</span></span></span><br><span class="line"><span class="php"><span class="comment">//$a=null;unset($a);0     1     wrong&amp;1</span></span></span><br><span class="line"><span class="php"><span class="comment">//$a='1';unset($a); 0     1     wrong&amp;1</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//wrong&amp;1:</span></span></span><br><span class="line"><span class="php"><span class="comment">//Undefined variable: a</span></span></span><br><span class="line"><span class="php"><span class="comment">//1</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//只有a=null或不定义a isest为0</span></span></span><br><span class="line"><span class="php"><span class="comment">//只有a=1(not0)或a="有东西，null也算"(数组规则一样) empty为0</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//is_null判断null 只有当a=null时才为1，当变量不存在时会报错并报1，其他都为false</span></span></span><br><span class="line"><span class="php"><span class="comment">//isset 判断存在  当a被赋值（除a=null） isset就为true 表示变量存在，不判断变量含义，含义空亦true</span></span></span><br><span class="line"><span class="php"><span class="comment">//empty 判断空    仅当a被赋值并且变量含义不为空 empty($var)才为false 其他都是true</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装 继承 多态"></a>封装 继承 多态</h2><p>所谓封装：<br>也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p>所谓继承：<br>是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
<p>所谓多态：<br>就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<h2 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h2><p>（1）构造方法：<br>     抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>（2）抽象类中可以有普通成员变量，接口中没有普通成员变量<br>（3）抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>（4）继承：<br>     一个类可以实现多个接口，但只能继承一个抽象类。<br>（5）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</p>
<h2 id="抽象类与接口的共通"><a href="#抽象类与接口的共通" class="headerlink" title="抽象类与接口的共通"></a>抽象类与接口的共通</h2><p>(1) 都可以被继承<br>(2) 都不能被实例化<br>(3) 都可以包含方法声明<br>(4) 派生类必须实现未实现的方法</p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【总结】如果只剩下博客文件该如何恢复</title>
    <url>/2020/04/13/%E6%9E%9C%E5%8F%AA%E5%89%A9%E4%B8%8B%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>如果只剩下了博客文件夹，如何最快速的恢复博客呢？<br>1.安装git与node.js<br>  安装 npm install hexo-deployer-git –save</p>
<p>2.blog文件夹右键git bash here<br> 执行npm install hexo-cli -g</p>
<p>3.在控制台中输入,其中yourname为github昵称，邮箱是github绑定邮箱<br>git config –global user.name “yourname”<br>git config –global user.email “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“<br>ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p>
<p>4.去shh文件夹下找到rsa.pub，去github上替换公钥，接下来验证。</p>
<p>5.验证公钥<br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>如果出现success与自己的github用户名，则成功。<br>在此期间如果出现22端口连接不上的问题，在ssh文件夹下新建无后缀的config文件，在文件中键入以下内容，并且每行后一定不能留空格</p>
<p>Host github.com<br>User “<a href="mailto:2417666758@qq.com" target="_blank" rel="noopener">2417666758@qq.com</a>“<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port 443</p>
<p>6.如果hexo s启动时报index错，则是没有安装hexo的search模块，安装处理_post文件夹，具体做法是写一篇博客后再把之前的导入进去。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>【记录】实习回顾2019年5月-8月</title>
    <url>/2019/08/27/%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>实习回顾 新浪 5.9-8.2</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>第一天就是配环境 熟悉新环境<br>新浪必须要内网可以访问服务器与数据库 因为了IP地址解析，无论是测试服务器还是线上都是如此，另外必须要配置Redis环境。其余都和我之前一样 wamp直接配好</p>
<p>第一个需求<br>第一个需求是修改一个词云页面，做一个input能更改词云一个项目的名称，实现立刻重命名与暂时重命名的功能。后台只是简单动了一点</p>
<p>第二个需求<br>新浪有它自己的URL类别 如短URL 长URL mid uid<br>这些是新浪微博的ID 都可以进行互转 如短URL是十六位转换 我要做的是优化原来页面 优化操作体验 原来的操作有点反人类</p>
<p>第一个较难的需求<br>鹰眼平台 数据流页面 难在前端 页面中有两列,一列是微博 一个个排列 点击一个微博出现cms接口的连接 难在鼠标滚轮看两列的时候 左右两列不能同步 最后对右边一列做了滚轮事件监听 让它呈现吸顶的效果</p>
<p>这个页面也接触到了组件方式写的vue 在之前我写的vue都是一个父组件从头写到尾，为后期写趋势做铺垫</p>
<h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><p>鹰眼分析版 写的最多的需求 总得来说是一套数据分析的业务平台<br>1.创建任务<br>鹰眼分析版中趋势分析 是根据<br>关键词 如狮子王<br>mid<br>uid<br>趋势类别 如关注点分析 提及趋势 相关趋势<br>时间条件 七月一号至十号<br>其他参数 如 汇总拆分 是否视频<br>这些参数传递给后台接口 </p>
<p>2.任务进库 任务交大数据计算<br>我在后台接口将参数与状态写进数据库后 再传递给hive计算接口 hive是大数据那边计算用的技术 他们会根据参数将该任务的pv或uv按天写进数据库 </p>
<p>3.任务显示与业务方<br>大数据跑完后会将MySQL状态改为成功，然后我再从MySQL中取出这些pv数据 展示到页面的echart图表里 根据天周月可以切换，可以做词拆分，比如奶粉可以拆分为飞鹤 美赞臣 爱他美 另外做Excel下载接口 做相关博文展示接口 新浪的业务需求方则是需要这些数据 做排行 热词<br>分析 报表<br>大部分的数据都用到echart 这是共同点 很多趋势有它独立的分析展示 </p>
<p>比如事件走势 要展示一段是时间内 初始博文 最热博文 最多点击率博文<br>比如情感分析 需要用到词云接口 展示的是根据那几个关键词衍生出的上百个相关词<br>还有博文的转发博主排行 是table形式展示的</p>
<p>还有以得分来衡量词的 做了百分比条</p>
<p>我的大部分工作都是趋势分析这边的 加强了对echart的应用 学会了和数据方与产品经理积极沟通解决问题 因为一开始我根本不知道这个需求到底为什么要这么做 所以不问的话进度很慢<br>，日常改bug，自己测代码，用postman测PHP接口</p>
<p>在实习未了做了一个主题分析，是对之前趋势分析的一个总控 因为各趋势创建任务的相似性 以及趋势展示的模块话 需求要求能够一次性跑多个趋势 于是就要加一张表表示个趋势需要的参数 加一张表记录主题内容 这个应该讲不清楚 大概意思就是一次性创建几个趋势 成功后也在一个页面里面展示</p>
<h2 id="几个比较有意义的需求"><a href="#几个比较有意义的需求" class="headerlink" title="几个比较有意义的需求"></a>几个比较有意义的需求</h2><p>1.百万数据迁移<br>大数据那边重做了一个趋势的运行方式 也换了三张新表存计算结果 但是之前的数据在老表里面 总共有两百万数据 如何迁移？<br>老表中存储的是一个个任务大ID 在ID下有各种数据 于是我按照任务ID 来分别传递数据<br>首先是MySQLgroupby出ID表 然后按照ID 每查五十个数 就进行字符串拼接 再插入到新表中<br>写了两个接口 第一个接口用于查找拼接 第二个根据jobID插入新表 需要计算轮数 拼多了字段MySQL会报错 整个迁移大概用了二十分钟 由于按jobID迁移的 中间出了错不用全部重来 </p>
<p>2.领域标签管理 词上传<br>难点在于去重 每次都是业务整理的大几千词汇 进行上传<br>早期去重用的是先上传上去，再用sql语句去重，这样非常低效<br>后来使用了唯一索引，可以很好的实现去重<br>词分为 一级词 二级 三级 四级 other</p>
<p>依靠微博日志 进行实时计算 过滤日志<br>实时算各种榜单<br>实时监控大V账号</p>
<p>xunzhe 根据条件筛选用户 用到ES引擎</p>
<p>爬虫scrapy  目标： 高性能高可用分布式爬虫</p>
<p>前端JQuery-Angular.js-vue.js<br>目标：前后端分离</p>
<p>新浪为什么要用php ci框架</p>
<p>08年到现在还是php 能用就行… </p>
<p>Apache 高并发会有问题 所以采用nginx</p>
<p>thrift</p>
<p>es速度远超mysql 与mongodb相当</p>
<p>mysql慢查询 读写分离延迟</p>
<p>hbase redis</p>
<p>数据计算</p>
<p>离线技术：hadoop（mapreducehive），spark</p>
<p>实时技术： ols-&gt;spark streaming-&gt;flink</p>
<p>多维查询： ckickhouse，presto</p>
<p>鹰眼如何监控<br>1选择监控的账号<br>2</p>
<p>scrapy</p>
<p>pipline持久化</p>
<p>google baidu本身也是爬虫</p>
<p>代理ip与访问间隔 防止封ip</p>
<p>利用深度学习绕过机器图片检测</p>
<p>滑动进度条不匀速 js代码</p>
<p>模拟登陆 爬取数据必须登陆 携带cookie</p>
<p>反爬虫</p>
<p>检测是否访问js、css</p>
<p>自定义字体库</p>
<p>递归的url 蜜罐</p>
<p>只开放手机端 不开放其他接口</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结】php写的mysql数据迁移</title>
    <url>/2019/07/19/titled/</url>
    <content><![CDATA[<p>原创 by 殷航<br>msyql 200万数据迁移<br>trend与trend_new<br><img src="\images\pasted-123.png" alt="upload successful"></p>
<p>data与data_new<br><img src="\images\pasted-124.png" alt="upload successful"></p>
<p>data_new最大，1980页<br><img src="\images\pasted-125.png" alt="upload successful"><br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run_combine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $ids = [<span class="number">518</span>,<span class="number">520</span>,<span class="number">524</span>,<span class="number">525</span>,<span class="number">542</span>,<span class="number">544</span>,<span class="number">558</span>,<span class="number">689</span>,<span class="number">690</span>,<span class="number">758</span>,<span class="number">759</span>];</span><br><span class="line">        <span class="keyword">foreach</span> ($ids <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $job_id = $v;</span><br><span class="line">            <span class="comment">// $sign = $this-&gt;insert_trend($job_id);</span></span><br><span class="line">            <span class="comment">// if($sign==1)&#123;</span></span><br><span class="line">            <span class="comment">//     $sign = $this-&gt;insert_data($job_id);</span></span><br><span class="line">            <span class="comment">// &#125;  </span></span><br><span class="line">            $sign = <span class="keyword">$this</span>-&gt;insert_data($job_id);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">print</span> json_encode(<span class="keyword">array</span>(<span class="string">'code'</span>=&gt;<span class="number">0</span>, <span class="string">'desc'</span>=&gt;<span class="string">'okokokokokokok'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_trend</span><span class="params">($job_id)</span></span>&#123;</span><br><span class="line">        $sql1 = <span class="string">"select * from t_result_pub_trend where job_id = '$job_id'"</span>;</span><br><span class="line">        $rows = <span class="keyword">$this</span>-&gt;db-&gt;query($sql1)-&gt;result_array(); </span><br><span class="line">        $data = [];</span><br><span class="line">        </span><br><span class="line">        $len = count($rows);</span><br><span class="line">        <span class="comment">// $this-&gt;p($rows[22775]);</span></span><br><span class="line">        $i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($rows <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $j = ceil(($i+<span class="number">1</span>) / <span class="number">50</span>);</span><br><span class="line">            $i++;</span><br><span class="line">            $data[$j][] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//insert</span></span><br><span class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $one = [];</span><br><span class="line">            <span class="keyword">foreach</span> ($data[$k] <span class="keyword">as</span> $k1 =&gt; $v1) &#123;</span><br><span class="line">                $one[] = <span class="string">"('"</span>.$v1[<span class="string">'job_id'</span>].<span class="string">"','"</span>.$v1[<span class="string">'dt'</span>].<span class="string">"','"</span>.$v1[<span class="string">'uid'</span>].<span class="string">"','"</span>.$v1[<span class="string">'category_name'</span>].<span class="string">"','"</span>.$v1[<span class="string">'pv'</span>].<span class="string">"','"</span>.$v1[<span class="string">'hour'</span>].<span class="string">"')"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $tmp = implode(<span class="string">','</span>, $one);</span><br><span class="line">            $sql = <span class="string">"INSERT  INTO t_result_pub_trend_new (job_id,dt,uid,category_name,pv,`hour`) VALUES $tmp"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;db-&gt;query($sql); </span><br><span class="line">            </span><br><span class="line">        &#125;          </span><br><span class="line">        <span class="keyword">unset</span>($rows);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_data</span><span class="params">($job_id)</span></span>&#123;</span><br><span class="line">        $sql1 = <span class="string">"select * from t_result_pub_data where job_id = '$job_id'"</span>;</span><br><span class="line">        $rows = <span class="keyword">$this</span>-&gt;db-&gt;query($sql1)-&gt;result_array(); </span><br><span class="line">        $data = [];</span><br><span class="line">        </span><br><span class="line">        $len = count($rows);</span><br><span class="line">        $i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($rows <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $j = ceil(($i+<span class="number">1</span>) / <span class="number">50</span>);</span><br><span class="line">            $i++;</span><br><span class="line">            $data[$j][] = $v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//insert</span></span><br><span class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $one = [];</span><br><span class="line">            <span class="keyword">foreach</span> ($data[$k] <span class="keyword">as</span> $k1 =&gt; $v1) &#123;</span><br><span class="line">                $one[] = <span class="string">"('"</span>.$v1[<span class="string">'job_id'</span>].<span class="string">"','"</span>.$v1[<span class="string">'dt'</span>].<span class="string">"','"</span>.$v1[<span class="string">'uid'</span>].<span class="string">"','"</span>.$v1[<span class="string">'time'</span>].<span class="string">"','"</span>.$v1[<span class="string">'mid'</span>].<span class="string">"','"</span>.$v1[<span class="string">'is_topic'</span>].<span class="string">"','"</span>.$v1[<span class="string">'category_names'</span>].<span class="string">"','"</span>.$v1[<span class="string">'atuids'</span>].<span class="string">"','"</span>.$v1[<span class="string">'total_valid_cs'</span>].<span class="string">"','"</span>.$v1[<span class="string">'id'</span>].<span class="string">"')"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $tmp = implode(<span class="string">','</span>, $one);</span><br><span class="line">            $sql = <span class="string">"INSERT  INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"</span>;</span><br><span class="line">            <span class="comment">// $this-&gt;p($sql);</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;db-&gt;query($sql); </span><br><span class="line">            </span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="keyword">unset</span>($rows);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_data_special</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $job_id = <span class="number">852</span>;</span><br><span class="line">        $sql_num = <span class="string">"select count('id') ct from t_result_pub_data where job_id = '$job_id'"</span>;</span><br><span class="line">        $all = <span class="keyword">$this</span>-&gt;db-&gt;query($sql_num)-&gt;row_array();</span><br><span class="line">        $num = $all[<span class="string">'ct'</span>];</span><br><span class="line">        $ci = round($num/<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($w=<span class="number">0</span>; $w&lt; $ci; $w++) &#123; </span><br><span class="line">            $x = $w *<span class="number">10000</span>;</span><br><span class="line">            $sql1 = <span class="string">"select * from t_result_pub_data where job_id = '$job_id' limit $x , 10000"</span>;</span><br><span class="line">            $rows = <span class="keyword">$this</span>-&gt;db-&gt;query($sql1)-&gt;result_array(); </span><br><span class="line">            $data = [];</span><br><span class="line">            </span><br><span class="line">            $len = count($rows);</span><br><span class="line">            $i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> ($rows <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">                $j = ceil(($i+<span class="number">1</span>) / <span class="number">50</span>);</span><br><span class="line">                $i++;</span><br><span class="line">                $data[$j][] = $v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//insert</span></span><br><span class="line">            <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">                $one = [];</span><br><span class="line">                <span class="keyword">foreach</span> ($data[$k] <span class="keyword">as</span> $k1 =&gt; $v1) &#123;</span><br><span class="line">                    $one[] = <span class="string">"('"</span>.$v1[<span class="string">'job_id'</span>].<span class="string">"','"</span>.$v1[<span class="string">'dt'</span>].<span class="string">"','"</span>.$v1[<span class="string">'uid'</span>].<span class="string">"','"</span>.$v1[<span class="string">'time'</span>].<span class="string">"','"</span>.$v1[<span class="string">'mid'</span>].<span class="string">"','"</span>.$v1[<span class="string">'is_topic'</span>].<span class="string">"','"</span>.$v1[<span class="string">'category_names'</span>].<span class="string">"','"</span>.$v1[<span class="string">'atuids'</span>].<span class="string">"','"</span>.$v1[<span class="string">'total_valid_cs'</span>].<span class="string">"','"</span>.$v1[<span class="string">'id'</span>].<span class="string">"')"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $tmp = implode(<span class="string">','</span>, $one);</span><br><span class="line">                $sql = <span class="string">"INSERT ignore INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"</span>;</span><br><span class="line">                <span class="comment">// $this-&gt;p($sql);</span></span><br><span class="line">                <span class="keyword">$this</span>-&gt;db-&gt;query($sql); </span><br><span class="line">                </span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="keyword">unset</span>($rows);              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p($sql1);</span><br><span class="line">        <span class="comment">// $this-&gt;p($x);</span></span><br><span class="line">        <span class="keyword">print</span> json_encode(<span class="keyword">array</span>(<span class="string">'code'</span>=&gt;<span class="number">0</span>, <span class="string">'desc'</span>=&gt;<span class="string">'okokokokokokok'</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>【记录】北京之旅2019年5月</title>
    <url>/2019/05/07/%E4%BA%AC%E4%B9%8B%E6%97%85day1/</url>
    <content><![CDATA[<p>之所以去北京是为了新浪的实习，而且目前也只有新浪的offer，是在是没得法子。。虽然昨天下午接了小米的电话，但是好像也不能立刻改变什么，该去的还是要去，历练嘛，不能在毕业之前还心里没有谱，那不等于白读三年研究生。。<br>    早上坐了校车从东澜岸赶到学校，等到了青山老妈已经请了假在帮我收拾行李，老爸打电话告诉我过会送我去火车站，然后我又被我妈怂恿跑去办理银行卡挂失（这导致我当天到了北京之后没有钱付房租，还是找媳妇要的钱付的。。。），实在不是什么明智之举。<br>    去北京，不是第一次去，感觉北京的天气比武汉的舒服，因为不是很热，有风吹过，吹的人心情舒畅一点点，也没有雾霾什么的，听说在办世园会。动车是真的贵，也是真的快，1000公里4小时就到了，但是要花520大洋。中介小哥倒是十分热情，虽然我还不知道他会不会有什么套路，但是年级比我小两岁，如果碰到个40岁的中介绝对比他会的套路多，我在来之前其实大致确定了要住的房子，便宜，优惠一个月，位置还可以，空气也还算可以，我强制他带我去看了其他两套房子，是那种我知道肯定我不会选的，结果比我想的还要差，第一家屋子只能住两个人，客厅里到处都是鞋子衣物，我懂那个租户的想法，想利用这样脏乱的环境劝退其他人，好让自己好好住在里面，并且他是有一个女的一起住的，哪个在外漂的人愿意天天听别个床板吱呀吱呀声。。。另外一家更贵一点，房间更大一点，但是房子味道很重。。。自如的套路其实都写在合同里面了，坑你一个月的房租，比同行高得多的服务费，但是他掌握的房源多，并且服务还算可以，只要甲醛没得问题其他都还好。算下来转租有点难度，估计要花费9000到10000左右，也就是说我工资刚刚抵押房钱，所以说还是武汉好啊，北京不拿几万工资根本活不下去。<br>    晚上在外面晃荡一下，找了一家餐馆吃了点，估计以后会经常去那边吃，物价的话还好，但是味道真的一般，也许明天我可能就会去买个奶锅买点面条每天自己下面吃，这样一天的开销，早晚餐可以压缩到十元左右，每天应该会到处逛逛，去新浪看看，</p>
<h2 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h2><p>昨天入职，今天正式开始接需求，一开始的需求不会太难，但是我还是花了很多时间去看懂他的代码结构，索性最后还是写出来我想要的效果，也算是在周末前给自己的一个定心丸，毕竟如果今天什么都做不出来的话，那么接下来的日子就不好过了。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>今天又去逛了超市，感觉其实没什么好买的，以后晚上应该都是吃零食，因为新浪的伙食，看上去很好看，看上去也很多，但是只要你加一个荤菜，你就会后悔来北京，那是指数级别的加价，我的天哪，加一个荤菜，给我加十块钱，还有昨天吃那个凉面，花了我十三块钱，还没有五谷烩四块钱的热干面好吃，真的是一言难尽。</p>
<h2 id="补充昨天的"><a href="#补充昨天的" class="headerlink" title="补充昨天的"></a>补充昨天的</h2><p>day2主要是到处去逛，一天骑了好长时间的车，而且我发现，在北京，hellobike特别抢手，因为每天早上公司门口停满了hellobike，每天晚上公司门口，一辆hellobike都没有，只剩下破铜烂铁，我还是不打算去办摩拜，因为走回来也只要30分钟，都还好，</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>【总结】session与cookie在vuethink中的应用</title>
    <url>/2019/04/23/ession%E4%B8%8Ecookie%E5%9C%A8vuethink%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>vuethink初始已经写好了基于session与cookie的用户登录模块<br>用户注册之后再user表中保存了用户的账户与MD5格式的密码：<br>guest    c78b6663d47cfbdb4d65ea51c104044e<br>每次用户登录的时候前端将数据发送给login方法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username, $password, $verifyCode = <span class="string">''</span>, $isRemember = false, $type = false)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!$username) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'帐号不能为空'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!$password)&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'密码不能为空'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (config(<span class="string">'IDENTIFYING_CODE'</span>) &amp;&amp; !$type) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!$verifyCode) &#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;error = <span class="string">'验证码不能为空'</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $captcha = <span class="keyword">new</span> HonrayVerify(config(<span class="string">'captcha'</span>));</span><br><span class="line">            <span class="keyword">if</span> (!$captcha-&gt;check($verifyCode)) &#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;error = <span class="string">'验证码错误'</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		$map[<span class="string">'username'</span>] = $username;</span><br><span class="line">		$userInfo = <span class="keyword">$this</span>-&gt;where($map)</span><br><span class="line">					-&gt;find();</span><br><span class="line">    	<span class="keyword">if</span> (!$userInfo) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'帐号不存在'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (user_md5($password) !== $userInfo[<span class="string">'password'</span>]) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'密码错误'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> ($userInfo[<span class="string">'status'</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'帐号已被禁用'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">		Db::table(<span class="string">'oa_admin_user'</span>)-&gt;where([<span class="string">'id'</span> =&gt; $userInfo[<span class="string">'id'</span>]])-&gt;update([<span class="string">'last_login_time'</span> =&gt; date(<span class="string">'Y-m-d H:i:s'</span>, time()), <span class="string">'last_login_ip'</span> =&gt; get_client_ip()]);</span><br><span class="line">		<span class="comment">// 登录成功,添加记录</span></span><br><span class="line">		record(<span class="number">1</span>, <span class="keyword">array</span>(get_client_ip()), $userInfo[<span class="string">'id'</span>]);</span><br><span class="line">        <span class="comment">// 获取菜单和权限</span></span><br><span class="line">        $dataList = <span class="keyword">$this</span>-&gt;getMenuAndRule($userInfo[<span class="string">'id'</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!$dataList[<span class="string">'menusList'</span>]) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;error = <span class="string">'没有权限'</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($isRemember || $type) &#123;</span><br><span class="line">        	$secret[<span class="string">'username'</span>] = $username;</span><br><span class="line">        	$secret[<span class="string">'password'</span>] = $password;</span><br><span class="line">        	$data[<span class="string">'rememberKey'</span>] = encrypt($secret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存缓存        </span></span><br><span class="line">        session_start();</span><br><span class="line">        $info[<span class="string">'userInfo'</span>] = $userInfo;</span><br><span class="line">        $info[<span class="string">'sessionId'</span>] = session_id();</span><br><span class="line">        $authKey = user_md5($userInfo[<span class="string">'username'</span>].$userInfo[<span class="string">'password'</span>].$info[<span class="string">'sessionId'</span>]);</span><br><span class="line">        $info[<span class="string">'_AUTH_LIST_'</span>] = $dataList[<span class="string">'rulesList'</span>];</span><br><span class="line">        $info[<span class="string">'authKey'</span>] = $authKey;</span><br><span class="line">        cache(<span class="string">'Auth_'</span>.$authKey, <span class="keyword">null</span>);</span><br><span class="line">        cache(<span class="string">'Auth_'</span>.$authKey, $info, config(<span class="string">'LOGIN_SESSION_VALID'</span>));</span><br><span class="line">        <span class="comment">// 返回信息</span></span><br><span class="line">        $data[<span class="string">'authKey'</span>]		= $authKey;</span><br><span class="line">        $data[<span class="string">'sessionId'</span>]		= $info[<span class="string">'sessionId'</span>];</span><br><span class="line">        $data[<span class="string">'userInfo'</span>]		= $userInfo;</span><br><span class="line">        $data[<span class="string">'authList'</span>]		= $dataList[<span class="string">'rulesList'</span>];</span><br><span class="line">        $data[<span class="string">'menusList'</span>]		= $dataList[<span class="string">'menusList'</span>];</span><br><span class="line">        <span class="keyword">return</span> $data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>处理流程<br>1、该方法首先会在数据库验证账户密码，根据账户查找用户md5密码，匹配表单的MD5密码与数据库密码<br>2、如果没有任何问题，session_start(),保存sessionid与authkey<br>3、return session中保存的数据，返还到前端代码，并保存到cookie中<br>前端login.vue<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.apiPost(<span class="string">'admin/base/login'</span>, <span class="keyword">data</span>).then((res) =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (res.code != <span class="number">200</span>) &#123;</span><br><span class="line">   		<span class="keyword">this</span>.loading = !<span class="keyword">this</span>.loading</span><br><span class="line">   		<span class="keyword">this</span>.handleError(res)</span><br><span class="line">   		<span class="keyword">this</span>.refreshVerify()</span><br><span class="line">   		<span class="keyword">this</span>.form.verifyCode = <span class="string">''</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="keyword">if</span> (<span class="keyword">this</span>.checked) &#123;</span><br><span class="line">   			Cookies.<span class="keyword">set</span>(<span class="string">'rememberPwd'</span>, <span class="literal">true</span>, &#123; expires: <span class="number">1</span> &#125;)</span><br><span class="line">   		&#125;</span><br><span class="line">   		<span class="keyword">this</span>.resetCommonData(res.<span class="keyword">data</span>)</span><br><span class="line">   		_g.toastMsg(<span class="string">'success'</span>, <span class="string">'登录成功'</span>)</span><br><span class="line">   		&#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p>
<p>4、当用户访问接口的时候，后台控制器写了一个apicommon，每一个控制器都继承了这个类，该类用于验证权限<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="comment">// +----------------------------------------------------------------------</span></span></span><br><span class="line"><span class="php"><span class="comment">// | Description: Api基础类，验证权限</span></span></span><br><span class="line"><span class="php"><span class="comment">// +----------------------------------------------------------------------</span></span></span><br><span class="line"><span class="php"><span class="comment">// | Author: linchuangbin &lt;linchuangbin@honraytech.com&gt;</span></span></span><br><span class="line"><span class="php"><span class="comment">// +----------------------------------------------------------------------</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">admin</span>\<span class="title">controller</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Request</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Db</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">common</span>\<span class="title">adapter</span>\<span class="title">AuthAdapter</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">common</span>\<span class="title">controller</span>\<span class="title">Common</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">ApiCommon</span> <span class="keyword">extends</span> <span class="title">Common</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">_initialize</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">parent</span>::_initialize();</span></span><br><span class="line"><span class="php">        <span class="comment">/*获取头部信息*/</span> </span></span><br><span class="line"><span class="php">        $header = Request::instance()-&gt;header();</span></span><br><span class="line"><span class="php">        </span></span><br><span class="line"><span class="php">        $authKey = $header[<span class="string">'authkey'</span>];</span></span><br><span class="line"><span class="php">        $sessionId = $header[<span class="string">'sessionid'</span>];</span></span><br><span class="line"><span class="php">        $cache = cache(<span class="string">'Auth_'</span>.$authKey);</span></span><br><span class="line"><span class="php">        </span></span><br><span class="line"><span class="php">        <span class="comment">// 校验sessionid和authKey</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (<span class="keyword">empty</span>($sessionId)||<span class="keyword">empty</span>($authKey)||<span class="keyword">empty</span>($cache)) &#123;</span></span><br><span class="line"><span class="php">            header(<span class="string">'Content-Type:application/json; charset=utf-8'</span>);</span></span><br><span class="line"><span class="php">            <span class="keyword">exit</span>(json_encode([<span class="string">'code'</span>=&gt;<span class="number">101</span>, <span class="string">'error'</span>=&gt;<span class="string">'登录已失效'</span>]));</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="comment">// 检查账号有效性</span></span></span><br><span class="line"><span class="php">        $userInfo = $cache[<span class="string">'userInfo'</span>];</span></span><br><span class="line"><span class="php">        $map[<span class="string">'id'</span>] = $userInfo[<span class="string">'id'</span>];</span></span><br><span class="line"><span class="php">        $map[<span class="string">'status'</span>] = <span class="number">1</span>;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!Db::name(<span class="string">'admin_user'</span>)-&gt;where($map)-&gt;value(<span class="string">'id'</span>)) &#123;</span></span><br><span class="line"><span class="php">            header(<span class="string">'Content-Type:application/json; charset=utf-8'</span>);</span></span><br><span class="line"><span class="php">            <span class="keyword">exit</span>(json_encode([<span class="string">'code'</span>=&gt;<span class="number">103</span>, <span class="string">'error'</span>=&gt;<span class="string">'账号已被删除或禁用'</span>]));</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="comment">// 更新缓存</span></span></span><br><span class="line"><span class="php">        cache(<span class="string">'Auth_'</span>.$authKey, $cache, config(<span class="string">'LOGIN_SESSION_VALID'</span>));</span></span><br><span class="line"><span class="php">        $authAdapter = <span class="keyword">new</span> AuthAdapter($authKey);</span></span><br><span class="line"><span class="php">        $request = Request::instance();</span></span><br><span class="line"><span class="php">        $ruleName = $request-&gt;module().<span class="string">'-'</span>.$request-&gt;controller() .<span class="string">'-'</span>.$request-&gt;action(); </span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!$authAdapter-&gt;checkLogin($ruleName, $cache[<span class="string">'userInfo'</span>][<span class="string">'id'</span>])) &#123;</span></span><br><span class="line"><span class="php">            header(<span class="string">'Content-Type:application/json; charset=utf-8'</span>);</span></span><br><span class="line"><span class="php">            <span class="keyword">exit</span>(json_encode([<span class="string">'code'</span>=&gt;<span class="number">102</span>,<span class="string">'error'</span>=&gt;<span class="string">'没有权限'</span>]));</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $GLOBALS[<span class="string">'userInfo'</span>] = $userInfo;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>该类会校验sessionid,authkey与cache，任意一个丢失会导致当前登录失效并强制重登，如服务器中session等字段与当前cookie不匹配。<br>session中亦会存储用户的信息，可以用来设置权限，并不用访问数据库中数据。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>【总结】vuethink 基础配置详解</title>
    <url>/2019/04/23/ethink-%E6%9D%83%E9%99%90%E5%9D%97/</url>
    <content><![CDATA[<p>最开始的vuethink数据库如下，实现了权限管理，群组，用户信息，系统配置等功能<br>在实际使用中具体用到其中6张表</p>
<p><img src="\images\pasted-97.png" alt="upload successful"></p>
<h2 id="user表-用户数据"><a href="#user表-用户数据" class="headerlink" title="user表-用户数据"></a>user表-用户数据</h2><p><img src="\images\pasted-107.png" alt="upload successful"></p>
<p><img src="\images\pasted-99.png" alt="upload successful"><br>user表存储用户账号，自定义名称，以及一些外键</p>
<h2 id="rule表-定义接口"><a href="#rule表-定义接口" class="headerlink" title="rule表-定义接口"></a>rule表-定义接口</h2><p>存储菜单名称，接口名称 菜单等级 继承菜单id 使用状态<br>以树结构表示的菜单，此处id标记为rule_id<br>php config下的基础框架路由配置文件：<br><img src="\images\pasted-109.png" alt="upload successful"><br>rule表：<br><img src="\images\pasted-110.png" alt="upload successful"><br>规则：<br>1、vuethink中每次在controller中写一个接口都需要到配置文件进行注册，否则超管无法访问。<br>2、一个路由在配置文件中写好了，如果不在rule表注册并分配权限给其他用户的话，只能超管访问（越级）。<br>3、同2，任何一个普通用户都离不开接口权限的赋予</p>
<h2 id="group表-定义用户接口权限"><a href="#group表-定义用户接口权限" class="headerlink" title="group表-定义用户接口权限"></a>group表-定义用户接口权限</h2><p>group表要用到rule_id，来标识一个用户可以使用接口的权限<br><img src="\images\pasted-101.png" alt="upload successful"><br>此处是zl配置好菜单后的权限表，其中：<br>1、超管拥有1-10的菜单，1-10应该是默认的内置权限，菜单的功能处于最底层<br>2、vuethink内置了对这张表的可视化管理界面，可以自行勾选，也可以直接在数据库里改<br>3、后台对rules字段进行explode分割即可，这样存储十分方便<br>4、接口在后台注册，没有权限访问不了url</p>
<h2 id="access表-使用权限"><a href="#access表-使用权限" class="headerlink" title="access表-使用权限"></a>access表-使用权限</h2><p>group表定义了权限，access表为用户id制定哪一种group权限<br>access表与user表的id是一样的，access仅有两个字段，分离两张表是为了系统在查找用户权限的时候速度更快<br><img src="\images\pasted-105.png" alt="upload successful"></p>
<h2 id="menu表-后台根菜单"><a href="#menu表-后台根菜单" class="headerlink" title="menu表-后台根菜单"></a>menu表-后台根菜单</h2><p><img src="\images\pasted-103.png" alt="upload successful"><br>如图所示，材料表定义后台左区域菜单路由，即定义：<br>1、菜单名称<br>2、菜单icon<br>3、菜单id<br>4、菜单id之间继承关系<br>5、菜单url<br>如id52是树根，继承52的有系统配置、用户中心、材料管理等<br>继承材料管理的是所有材料 添加材料等</p>
<p>点击菜单显示的内容在route.js中配置并关联vue前台文件</p>
<h2 id="config表-系统设置"><a href="#config表-系统设置" class="headerlink" title="config表-系统设置"></a>config表-系统设置</h2><p><img src="\images\pasted-104.png" alt="upload successful"><br>可以设置logo与名称，以及session过期时间，这同样在vuethink后台中可视化了</p>
<p>总结：<br>access表存储：某个用户 拥有 某个权限（rulename）<br>rule表定义route接口名称，每一个接口有一个接口id 以及层级关系<br>group表定义权限rulename具体是什么，具体的说，就是某一个rulename包含哪些接口id</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】测开基础</title>
    <url>/2019/04/15/hp%E5%BA%95%E5%B1%82/</url>
    <content><![CDATA[<p>一、Linux必备知识<br>linux作为现在最流行的软件环境系统，一定需要掌握，目前的招聘要求都需要有linux能力。</p>
<p><img src="\images\pasted-71.png" alt="upload successful"><br>二、Shell脚本<br>掌握shell脚本，包括shell基础与应用、shell逻辑控制、shell逻辑函数等。</p>
<p><img src="\images\pasted-72.png" alt="upload successful"><br>三、互联网程序原理<br>自动化必由之路：前端开发基础知识以及互联网网络必备知识。</p>
<p><img src="\images\pasted-73.png" alt="upload successful"><br>四、Mysql数据库<br>软件测试工程师必备Mysql数据库知识，不仅仅停留在基本的“增删改查”。</p>
<p><img src="\images\pasted-74.png" alt="upload successful"><br>五、抓包工具<br>Fiddler、Wireshark、Sniffer、Tcpdump各种抓包工具适用于各种项目，总有一款适合你。</p>
<p><img src="\images\pasted-75.png" alt="upload successful"><br>六、接口测试工具<br>接口测试神器，你绕不开的强大工具：Jmeter。小巧灵活：Postman。</p>
<p><img src="\images\pasted-76.png" alt="upload successful"><br>七、Web自动化测试Java&amp;Pyhton<br>了解自动化的目的，熟练掌握testng&amp;unittest自动化框架，以及断言与日志处理。</p>
<p><img src="\images\pasted-77.png" alt="upload successful"><br>八、接口与手机自动化<br>专业接口调用、测试解决方案。组建完整的web和接口自动化框架，Appium整体使用</p>
<p><img src="\images\pasted-78.png" alt="upload successful"><br>九、敏捷测试&amp;TestOps构建<br>揭开TestOps的神秘面纱，持续集成Jenkins框架烂熟于心。</p>
<p><img src="\images\pasted-79.png" alt="upload successful"><br>十、性能测试&amp;安全测试<br>软件测试的彼岸：性能测试和安全测试，选对方向，努力爬坑吧！</p>
<p><img src="\images\pasted-80.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【搬运】php基础</title>
    <url>/2019/04/14/%E7%A1%80/</url>
    <content><![CDATA[<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 三元运算符的应用</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">$a = 10;</span><br><span class="line">$b = 15;</span><br><span class="line">echo $a &gt; $b ? 1 : 0;</span><br><span class="line">*/</span><br><span class="line">//注:php7新添加的运算符比较运算符x&lt;=&gt;y</span><br><span class="line">//如果x和y相等,就返回0,如果x&gt;y,就返回1,如果x的值小于y,就返回-1</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">$a = "aaa";</span><br><span class="line">$b = "bbb";</span><br><span class="line">echo $a.$b;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 预定义常量</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">class a&#123;</span><br><span class="line">    function showname()&#123;</span><br><span class="line">        echo __METHOD__;</span><br><span class="line">        echo "&lt;hr&gt;";</span><br><span class="line">        echo __FUNCTION__;</span><br><span class="line">        echo "&lt;hr&gt;";</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">        echo __FILE__;</span><br><span class="line">        echo __DIR__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$b = new a();</span><br><span class="line">$b-&gt;showname();</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * switch分支语句</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">switch (2)&#123;</span><br><span class="line">    case 1:</span><br><span class="line">        echo "11";</span><br><span class="line">        <span class="attribute">break;</span></span><br><span class="line">    case 2:</span><br><span class="line">        echo "12";</span><br><span class="line">        <span class="attribute">break;</span></span><br><span class="line">    default :</span><br><span class="line">        echo "13";</span><br><span class="line">        <span class="attribute">break;</span></span><br><span class="line"><span class="attribute">&#125;</span></span><br><span class="line"><span class="attribute">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * while循环</span><br><span class="line"> * 需要注意,while循环必须进行变量初始化</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">$i = 1;</span><br><span class="line">while ($i &lt;= 10) &#123;</span><br><span class="line">    echo $i." ";</span><br><span class="line">    $i++;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * do while循环</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">$i = 0;</span><br><span class="line"><span class="attribute">do&#123;</span></span><br><span class="line">    $i++;</span><br><span class="line">    echo $i." ";</span><br><span class="line">&#125;while($i&lt;10);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 跳转语句之goto (还有break,continue)</span><br><span class="line"> * goto</span><br><span class="line"> * goto a直接跳到a 中间部分的代码不执行</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">goto a;</span><br><span class="line">echo 'kkk';</span><br><span class="line">echo '123';</span><br><span class="line"><span class="attribute">a:</span></span><br><span class="line">echo 'bbb';</span><br><span class="line">echo '525';</span><br><span class="line">*/</span><br><span class="line">//此部分代码浏览器显示为</span><br><span class="line">//bbb525</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * goto跳转语句</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">for($i = 0; $i &lt; 10; $i++) &#123;</span><br><span class="line">    if($i == 3)&#123;</span><br><span class="line">        goto a;</span><br><span class="line">    &#125;</span><br><span class="line">    echo $i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">a:</span></span><br><span class="line">echo "跳出循环";</span><br><span class="line">*/</span><br><span class="line">//浏览器显示为</span><br><span class="line">//012跳出循环</span><br></pre></td></tr></table></figure>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(&amp;<span class="variable">$a</span>) &#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$a</span> + 1;</span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$x</span> = 1;</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span>(<span class="variable">$x</span>);//2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x</span>;//2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="函数参数与匿名函数"><a href="#函数参数与匿名函数" class="headerlink" title="函数参数与匿名函数"></a>函数参数与匿名函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 函数的默认参数</span><br><span class="line"> * 为了避免意外情况发生,一般,默认参数放在非默认参数的右侧</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> aa(<span class="variable">$a</span> = 2, <span class="variable">$b</span>)&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span>+<span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br><span class="line">aa(3,5);</span><br><span class="line">//浏览器显示8</span><br><span class="line">//这里,如果调用时aa(3)只给了一个参数,则会报错</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 可变参数变量</span><br><span class="line"> * 参数可包含<span class="string">'...'</span>来表示函数可接受一个可变数量的参数</span><br><span class="line"> * 可变参数将会被当做一个数组传递给函数</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(...<span class="variable">$num</span>)&#123;</span><br><span class="line">    <span class="variable">$sum</span> = 0;</span><br><span class="line">    foreach (<span class="variable">$num</span> as <span class="variable">$k</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line">        <span class="variable">$sum</span> += <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span>(1,3,4,5);</span><br><span class="line">//结果1+3+4+5 = 13</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * <span class="built_in">return</span>跳转语句</span><br><span class="line"> * <span class="built_in">return</span> 本身只能返回一个值,不能返回数组,我们通过这种方法来实现返回数组,并在调用时用list接收</span><br><span class="line"> * <span class="built_in">return</span>之后的代码不在执行,这里,<span class="built_in">echo</span> <span class="string">"111"</span>代码执行不了,所以浏览器只返回了28 11</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> aak(<span class="variable">$a</span>,<span class="variable">$b</span>)&#123;</span><br><span class="line">    <span class="variable">$sum</span> = <span class="variable">$a</span> * <span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$sum2</span> = <span class="variable">$a</span> + <span class="variable">$b</span>;</span><br><span class="line">    <span class="built_in">return</span> array(<span class="variable">$sum</span>,<span class="variable">$sum2</span>);</span><br><span class="line">&#125;</span><br><span class="line">list(<span class="variable">$a1</span>,<span class="variable">$a2</span>) = aak(4,7);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a1</span>.<span class="string">" "</span>.<span class="variable">$a2</span>;</span><br><span class="line">//浏览器显示 28 11</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 使用get_loaded_extensions 我们来查看一下现在的php程序加载了哪些拓展</span><br><span class="line"> */</span><br><span class="line">//var_dump(get_loaded_extensions());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 匿名函数(也叫闭包函数)</span><br><span class="line"> * 允许临时创建一个没有指定名称的函数,经常用作回调函数(callback)参数的值</span><br><span class="line"> * 闭包函数也可以作为变量的值来使用(比如此例)</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$greet</span> = <span class="keyword">function</span> (<span class="variable">$name</span>)&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"hello,<span class="variable">$name</span>"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable">$greet</span>(<span class="string">'xiaobudiu'</span>); //浏览器显示 hello,xiaobudiu</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 递归思想</span><br><span class="line"> * 斐波那契数列</span><br><span class="line"> * 1,1,2,3,5,8...</span><br><span class="line"> *<span class="variable">$n</span>表示第几个数</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> compute(<span class="variable">$n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$n</span> &gt; 2) &#123;</span><br><span class="line">        <span class="variable">$arr</span>[<span class="variable">$n</span>] = compute(<span class="variable">$n</span> - 1) + compute(<span class="variable">$n</span> - 2);</span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$arr</span>[<span class="variable">$n</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> compute(5);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 迭代思想</span><br><span class="line"> * 利用变量的原值推算出变量的一个新值</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> diedai(<span class="variable">$n</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = 0 , <span class="variable">$j</span> = 0; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$j</span> = <span class="variable">$i</span> + <span class="variable">$j</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$j</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> diedai(50);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 单引号和双引号</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"i dont't want to go shoping"</span>;</span><br><span class="line"><span class="built_in">echo</span> ucwords(<span class="variable">$str</span>);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title=" 字符串函数"></a> 字符串函数</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 字符串替换</span><br><span class="line"> *str_ireplace();str_replace()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"hello,world,hello,world"</span>;</span><br><span class="line">//<span class="built_in">echo</span> str_replace(<span class="string">'or'</span>,<span class="string">'dd'</span>,<span class="variable">$str</span>);</span><br><span class="line"><span class="variable">$replace</span> = <span class="string">'hi'</span>;</span><br><span class="line"><span class="built_in">echo</span> substr_replace(<span class="variable">$str</span>,<span class="variable">$replace</span>,0,7);//将第0到第7个字符替换成<span class="variable">$replace</span>字符</span><br><span class="line">//浏览器显示hiorld,hello,world</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 截取字符串</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">echo</span> substr(<span class="variable">$str</span>,0,4);</span><br><span class="line">//浏览器显示:abcd</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 去掉字符串首尾特殊字符</span><br><span class="line"> * trim();ltrim();rtrim()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">' .abcded  .gk.'</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="variable">$str</span> = trim(<span class="variable">$str</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>;//.abcded .gk.(空格去掉了)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&lt;hr&gt;'</span>;</span><br><span class="line"><span class="variable">$str</span> = ltrim(<span class="variable">$str</span>,<span class="string">'.'</span>);//abcded .gk.(左边的点被去掉了)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&lt;hr&gt;'</span>;</span><br><span class="line"><span class="variable">$str</span> = rtrim(<span class="variable">$str</span>,<span class="string">'.'</span>);//（右侧的点被去掉了）</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * str_replace()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">'hello,world,d,hello,world,ef'</span>;</span><br><span class="line">//要求把第二个hello替换成hi</span><br><span class="line"><span class="built_in">echo</span> str_replace(<span class="string">'hello'</span>,<span class="string">'hi'</span>,<span class="variable">$str</span>);</span><br><span class="line">*/</span><br><span class="line">//str_replace()单独实现不了替换限制次数的需求,要替换,都替换,无法替换单独一个</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 对字符串执行指定次数替换</span><br><span class="line"> * @param Mixed <span class="variable">$search</span>  查找目标值</span><br><span class="line"> * @param Mixed <span class="variable">$replace</span> 替换值</span><br><span class="line"> * @param Mixed <span class="variable">$subject</span> 执行替换的字符串／数组</span><br><span class="line"> * @param Int  <span class="variable">$limit</span>  允许替换的次数，默认为-1，不限次数</span><br><span class="line"> * @<span class="built_in">return</span> Mixed</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">function</span> str_replace_limit(<span class="variable">$search</span>, <span class="variable">$replace</span>, <span class="variable">$subject</span>, <span class="variable">$limit</span>=-1)&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_array(<span class="variable">$search</span>)) &#123;</span><br><span class="line">        foreach (<span class="variable">$search</span> as <span class="variable">$k</span>=&gt;<span class="variable">$v</span>) &#123;</span><br><span class="line">            <span class="variable">$search</span>[<span class="variable">$k</span>] = <span class="string">'`'</span>. preg_quote(<span class="variable">$search</span>[<span class="variable">$k</span>], <span class="string">'`'</span>). <span class="string">'`'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$search</span> = <span class="string">'`'</span>. preg_quote(<span class="variable">$search</span>, <span class="string">'`'</span>). <span class="string">'`'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> preg_replace(<span class="variable">$search</span>, <span class="variable">$replace</span>, <span class="variable">$subject</span>, <span class="variable">$limit</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"abccddefccggcccg"</span>;</span><br><span class="line"><span class="built_in">echo</span> str_replace_limit(<span class="string">'cc'</span>,<span class="string">'c'</span>,<span class="variable">$str</span>,2);</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'&lt;hr&gt;'</span>;</span><br><span class="line">*/</span><br><span class="line">//浏览器显示:abcddefcggcccg(前两个cc都被替换了,最后一个ccc没有被替换)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 截取字符串</span><br><span class="line"> * substr</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line"><span class="built_in">echo</span> substr(<span class="variable">$str</span>,-4,2);//kl</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 计算字符串长度</span><br><span class="line"> * str_len</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"abcdefghijklmn我"</span>;</span><br><span class="line"><span class="built_in">echo</span> strlen(<span class="variable">$str</span>);//17 (中文3个字符,英文1个字符)</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 转义和还原字符串</span><br><span class="line"> * 转义:addslashes()  还原:stripslashes</span><br><span class="line"> * 两个参数 第一个参数字符串,第二个参数要进行转义的字符</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"I Don't wang to go shopping.."</span>;</span><br><span class="line"><span class="variable">$str</span> = ucwords(<span class="variable">$str</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>;//I Don<span class="string">'t Wang To Go Shopping..</span></span><br><span class="line"><span class="string">echo "&lt;hr&gt;";</span></span><br><span class="line"><span class="string">//$str = addslashes($str);</span></span><br><span class="line"><span class="string">$str = addcslashes($str,'</span>.<span class="string">');</span></span><br><span class="line"><span class="string">echo $str;//I Don'</span>t Wang To Go Shopping\.\.</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 重复字符串</span><br><span class="line"> * str_repeat</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">'abcd'</span>;</span><br><span class="line"><span class="built_in">echo</span> str_repeat(<span class="variable">$str</span>,2);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 随机打乱字符串</span><br><span class="line"> * str_shuffle()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"abcdefghijklmn"</span>;</span><br><span class="line"><span class="built_in">echo</span> str_shuffle(<span class="variable">$str</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 分割字符串</span><br><span class="line"> * explode()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"piece1,piece2,piece3"</span>;</span><br><span class="line"><span class="variable">$str</span> = explode(<span class="string">','</span>,<span class="variable">$str</span>);</span><br><span class="line">var_dump(<span class="variable">$str</span>); //array(3) &#123; [0]=&gt; string(6) <span class="string">"piece1"</span> [1]=&gt; string(6) <span class="string">"piece2"</span> [2]=&gt; string(6) <span class="string">"piece3"</span> &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="variable">$str</span> = implode(<span class="string">'-'</span>,<span class="variable">$str</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>; //piece1-piece2-piece3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 创建一个指定范围的数组</span><br><span class="line"> * range() 第三个参数step 步进值</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = range(<span class="string">'0'</span>,<span class="string">'9'</span>,<span class="number">2</span>);</span><br><span class="line">var_dump(<span class="variable">$arr</span>); //<span class="keyword">array</span>(<span class="number">5</span>) &#123; [<span class="number">0</span>]=&gt; int(<span class="number">0</span>)  [<span class="number">1</span>]=&gt; int(<span class="number">2</span>)  [<span class="number">2</span>]=&gt; int(<span class="number">4</span>)  [<span class="number">3</span>]=&gt; int(<span class="number">6</span>)  [<span class="number">4</span>]=&gt; int(<span class="number">8</span>) &#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 检查数组中是否存在某个值</span><br><span class="line"> * in_array</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'beijing'</span>,</span><br><span class="line">    <span class="string">'shanghai'</span>,</span><br><span class="line">    <span class="string">'hangzhou'</span>,</span><br><span class="line">    <span class="string">'shenzhen'</span></span><br><span class="line">];</span><br><span class="line">var_dump(in_array(<span class="string">'hangzhou'</span>,<span class="variable">$arr</span>));//bool<span class="built_in">(true</span>)</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 数组转换成字符串</span><br><span class="line"> * implode()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'beijing'</span>,</span><br><span class="line">    <span class="string">'shanghai'</span>,</span><br><span class="line">    <span class="string">'hangzhou'</span>,</span><br><span class="line">    <span class="string">'shenzhen'</span></span><br><span class="line">];</span><br><span class="line"><span class="variable">$arr</span> = implode(<span class="string">'-'</span>,<span class="variable">$arr</span>);</span><br><span class="line">echo <span class="variable">$arr</span>; // beijing-shanghai-hangzhou-shenzhen</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 计算数组中的单元数目</span><br><span class="line"> *<span class="built_in"> count</span>()</span><br><span class="line"> * 第二个参数可选,默认<span class="number">0</span>,识别不了无限递归,<span class="number">1</span>:可以识别无限递归</span><br><span class="line"> * 此例中,输出<span class="built_in">的count</span>就是<span class="number">6</span></span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'beijing'</span>,</span><br><span class="line">    <span class="string">'shanghai'</span>=&gt;[</span><br><span class="line">        <span class="string">'pudong'</span>,</span><br><span class="line">        <span class="string">'jiaoda'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'hangzhou'</span>,</span><br><span class="line">    <span class="string">'shenzhen'</span></span><br><span class="line">];</span><br><span class="line">echo<span class="built_in"> count</span>(<span class="variable">$arr</span>);//<span class="number">4</span></span><br><span class="line">echo <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">echo<span class="built_in"> count</span>(<span class="variable">$arr</span>,<span class="number">1</span>);//<span class="number">6</span></span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 数组当前单元和指针</span><br><span class="line"> * current(),<span class="keyword">next</span>(),prev(),<span class="keyword">end</span>(),reset()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$foods</span> = [<span class="string">'banana'</span>,<span class="string">'apple'</span>,<span class="string">'orange'</span>];</span><br><span class="line">var_dump(current(<span class="variable">$foods</span>));</span><br><span class="line">var_dump(<span class="keyword">next</span>(<span class="variable">$foods</span>));//将数组指针向后移动一位</span><br><span class="line">var_dump(current(<span class="variable">$foods</span>));</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 数组中的键名和值</span><br><span class="line"> *<span class="built_in"> key</span>() <span class="keyword">next</span>()</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 检查给定键名或索引是否存在于数组中</span><br><span class="line"> * array_key_exits</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取数组中键名</span><br><span class="line"> * array_keys()</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取数组中所有的值</span><br><span class="line"> * array_values</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'12'</span> =&gt; <span class="string">'beijing'</span>,</span><br><span class="line">    <span class="string">'25'</span> =&gt; <span class="string">'shanghai'</span>,</span><br><span class="line">    <span class="string">'3'</span> =&gt; <span class="string">'hangzhou'</span>,</span><br><span class="line">    <span class="string">'4'</span> =&gt; <span class="string">'shenzhen'</span></span><br><span class="line">];</span><br><span class="line">var_dump(array_values(<span class="variable">$arr</span>));//获取数组所有键值</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 搜索给定值返回键名</span><br><span class="line"> * array_search</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'0'</span> =&gt; <span class="string">'blue'</span>,</span><br><span class="line">    <span class="string">'2'</span> =&gt; <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'3'</span> =&gt; <span class="string">'green'</span></span><br><span class="line">];</span><br><span class="line">var_dump(array_search(<span class="string">'red'</span>,<span class="variable">$arr</span>)); // <span class="number">2</span></span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 填补数组</span><br><span class="line"> * array_pad()</span><br><span class="line"> * pad_size:填补后数组的长度(若为负数,则填补到左侧)</span><br><span class="line"> * pad_value:填补的内容</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'0'</span> =&gt; <span class="string">'blue'</span>,</span><br><span class="line">    <span class="string">'2'</span> =&gt; <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'3'</span> =&gt; <span class="string">'green'</span></span><br><span class="line">];</span><br><span class="line"><span class="variable">$arr</span> = array_pad(<span class="variable">$arr</span>,<span class="number">6</span>,<span class="string">'orange'</span>);</span><br><span class="line">var_dump(<span class="variable">$arr</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 使用指定的键和值填充数组</span><br><span class="line"> * array_fill_keys</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">'banana'</span>,<span class="string">'apple'</span>,<span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line"><span class="variable">$arr</span> = array_fill_keys(<span class="variable">$arr</span>,<span class="keyword">array</span>(<span class="string">'hangzhou'</span>,<span class="string">'shanghai'</span>,<span class="string">'beijing'</span>));</span><br><span class="line">print_r(<span class="variable">$arr</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 浏览器显示</span><br><span class="line"> Array</span><br><span class="line">(</span><br><span class="line">    [banana] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; hangzhou</span><br><span class="line">            [<span class="number">1</span>] =&gt; shanghai</span><br><span class="line">            [<span class="number">2</span>] =&gt; beijing</span><br><span class="line">        )</span><br><span class="line">    [apple] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; hangzhou</span><br><span class="line">            [<span class="number">1</span>] =&gt; shanghai</span><br><span class="line">            [<span class="number">2</span>] =&gt; beijing</span><br><span class="line">        )</span><br><span class="line">    [<span class="number">2</span>] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; hangzhou</span><br><span class="line">            [<span class="number">1</span>] =&gt; shanghai</span><br><span class="line">            [<span class="number">2</span>] =&gt; beijing</span><br><span class="line">        )</span><br><span class="line">    [<span class="number">5</span>] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; hangzhou</span><br><span class="line">            [<span class="number">1</span>] =&gt; shanghai</span><br><span class="line">            [<span class="number">2</span>] =&gt; beijing</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 从数组中随机取出一个或多个单元</span><br><span class="line"> * array_rand</span><br><span class="line"> * 注:返回随机条目的一个或多个键</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = [</span><br><span class="line">    <span class="string">'0'</span> =&gt; <span class="string">'blue'</span>,</span><br><span class="line">    <span class="string">'2'</span> =&gt; <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'3'</span> =&gt; <span class="string">'green'</span>,</span><br><span class="line">    <span class="string">'4'</span> =&gt; <span class="string">'color'</span></span><br><span class="line">];</span><br><span class="line"><span class="variable">$arrs</span> = array_rand(<span class="variable">$arr</span>,<span class="number">3</span>);</span><br><span class="line">var_dump(<span class="variable">$arrs</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 数组排序与打乱数组</span><br><span class="line"> *<span class="built_in"> sort</span>(),asort() shuffle()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arr</span> = range(<span class="string">'a'</span>,<span class="string">'z'</span>);</span><br><span class="line">shuffle(<span class="variable">$arr</span>);</span><br><span class="line">foreach(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span>=&gt;<span class="variable">$v</span>)&#123;</span><br><span class="line">    echo <span class="variable">$v</span>;</span><br><span class="line">    echo <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 遍历数组</span><br><span class="line"> * <span class="keyword">for</span>,foreach(),each() list()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrs</span>=[<span class="string">'beijing'</span>,<span class="string">'shanghai'</span>,<span class="string">'guangzhou'</span>,<span class="string">'hangzhou'</span>,<span class="string">'shenzhen'</span>];</span><br><span class="line"><span class="variable">$arrss</span>=[<span class="string">'haerbin'</span>,<span class="string">'zhengzhou'</span>=&gt;<span class="string">'henan'</span>,<span class="string">'nanjing'</span>];</span><br><span class="line">//<span class="keyword">for</span>循环写法</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;<span class="built_in"> count</span>(<span class="variable">$arrs</span>); <span class="variable">$i</span>++)&#123;</span><br><span class="line">    echo <span class="variable">$arrs</span>[<span class="variable">$i</span>];</span><br><span class="line">    echo <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">//foreach写法</span><br><span class="line">foreach(<span class="variable">$arrss</span> <span class="keyword">as</span> &amp;<span class="variable">$v</span>)&#123;</span><br><span class="line">    echo <span class="variable">$v</span>;</span><br><span class="line">    echo <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * list() 将数组的值分给赋给变量</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrs</span>=[<span class="string">'beijing'</span>,<span class="string">'shanghai'</span>,<span class="string">'guangzhou'</span>,<span class="string">'hangzhou'</span>,<span class="string">'shenzhen'</span>];</span><br><span class="line">list(<span class="variable">$a</span>[<span class="number">1</span>], <span class="variable">$a</span>[<span class="number">2</span>], <span class="variable">$a</span>[<span class="number">3</span>]) = <span class="variable">$arrs</span>;</span><br><span class="line">var_dump(<span class="variable">$a</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *数组的拆分,拆分成几组，每组几个元素</span><br><span class="line"> * array_chunk()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrs</span> = [<span class="string">'beijing'</span>,<span class="string">'shanghai'</span>,<span class="string">'guangzhou'</span>,<span class="string">'hangzhou'</span>,<span class="string">'shenzhen'</span>];</span><br><span class="line"><span class="variable">$arrs</span> = array_chunk(<span class="variable">$arrs</span>,<span class="number">2</span><span class="built_in">,true</span>);</span><br><span class="line">var_dump(<span class="variable">$arrs</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">//浏览器显示</span><br><span class="line">/**</span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    [<span class="number">0</span>]=&gt;</span><br><span class="line">        <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        [<span class="number">0</span>]=&gt;</span><br><span class="line">       <span class="built_in"> string</span>(<span class="number">7</span>) <span class="string">"beijing"</span></span><br><span class="line">        [<span class="number">1</span>]=&gt;</span><br><span class="line">       <span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"shanghai"</span></span><br><span class="line">        &#125;</span><br><span class="line">    [<span class="number">1</span>]=&gt;</span><br><span class="line">        <span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        [<span class="number">2</span>]=&gt;</span><br><span class="line">       <span class="built_in"> string</span>(<span class="number">9</span>) <span class="string">"guangzhou"</span></span><br><span class="line">        [<span class="number">3</span>]=&gt;</span><br><span class="line">       <span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"hangzhou"</span></span><br><span class="line">        &#125;</span><br><span class="line">    [<span class="number">2</span>]=&gt;</span><br><span class="line">        <span class="keyword">array</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        [<span class="number">4</span>]=&gt;</span><br><span class="line">       <span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"shenzhen"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 合并数组</span><br><span class="line"> * array_merge()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrs</span>=[<span class="string">'beijing'</span>,<span class="string">'shanghai'</span>,<span class="string">'guangzhou'</span>,<span class="string">'hangzhou'</span>,<span class="string">'shenzhen'</span>];</span><br><span class="line"><span class="variable">$arrss</span>=[<span class="string">'haerbin'</span>,<span class="string">'zhengzhou'</span>=&gt;<span class="string">'henan'</span>,<span class="string">'nanjing'</span>,<span class="string">'hangzhou'</span>];</span><br><span class="line"><span class="variable">$arr</span> = array_merge(<span class="variable">$arrs</span>,<span class="variable">$arrss</span>);</span><br><span class="line">var_dump(<span class="variable">$arr</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *增加删除数组中的元素</span><br><span class="line"> *array_shift() 可在数组开头插入一个<span class="number">1</span>或多个单元</span><br><span class="line"> *array_unshift() 可将数组开头的单元移除数组</span><br><span class="line"> * array_push()   用来将一个或多个单元压入数组的末尾(入栈)</span><br><span class="line"> * array_pop()    可将数组的最后一个单元弹出(出栈)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 从数组中取出一段</span><br><span class="line"> * array_slice()  字符串 substr</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrs</span> = [<span class="string">'beijing'</span>,<span class="string">'shanghai'</span>,<span class="string">'guangzhou'</span>,<span class="string">'hangzhou'</span>,<span class="string">'shenzhen'</span>];</span><br><span class="line">var_dump(array_slice(<span class="variable">$arrs</span>,<span class="number">2</span>,<span class="number">3</span><span class="built_in">,true</span>));</span><br><span class="line">//<span class="keyword">array</span>(<span class="number">3</span>) &#123; [<span class="number">2</span>]=&gt;<span class="built_in"> string</span>(<span class="number">9</span>) <span class="string">"guangzhou"</span> [<span class="number">3</span>]=&gt;<span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"hangzhou"</span> [<span class="number">4</span>]=&gt;<span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"shenzhen"</span> &#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 把数组中的一部分去掉,并用其他值取代</span><br><span class="line"> * array_splice()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrss</span> = [<span class="string">'haerbin'</span>,<span class="string">'zhengzhou'</span>=&gt;<span class="string">'henan'</span>,<span class="string">'nanjing'</span>,<span class="string">'hangzhou'</span>];</span><br><span class="line">array_splice(<span class="variable">$arrss</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">'code'</span>);</span><br><span class="line">var_dump(<span class="variable">$arrss</span>); //<span class="keyword">array</span>(<span class="number">3</span>) &#123; [<span class="number">0</span>]=&gt;<span class="built_in"> string</span>(<span class="number">7</span>) <span class="string">"haerbin"</span> [<span class="number">1</span>]=&gt;<span class="built_in"> string</span>(<span class="number">4</span>) <span class="string">"code"</span> [<span class="number">2</span>]=&gt;<span class="built_in"> string</span>(<span class="number">8</span>) <span class="string">"hangzhou"</span> &#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$arrss</span> = [<span class="string">'haerbin'</span>,<span class="string">'zhengzhou'</span>=&gt;<span class="string">'henan'</span>,<span class="string">'nanjing'</span>,<span class="string">'hangzhou'</span>];</span><br><span class="line"><span class="variable">$arr3</span> = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">4</span>,<span class="number">23</span>];</span><br><span class="line">array_splice(<span class="variable">$arrss</span>,<span class="number">2</span>);</span><br><span class="line">var_dump(<span class="variable">$arrss</span>); //<span class="keyword">array</span>(<span class="number">2</span>) &#123; [<span class="number">0</span>]=&gt;<span class="built_in"> string</span>(<span class="number">7</span>) <span class="string">"haerbin"</span> [<span class="string">"zhengzhou"</span>]=&gt;<span class="built_in"> string</span>(<span class="number">5</span>) <span class="string">"henan"</span> &#125;</span><br><span class="line">echo array_sum(<span class="variable">$arr3</span>);//获得数组内所有数的总和</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="系统预定义数组-SERVER-GET-POST"><a href="#系统预定义数组-SERVER-GET-POST" class="headerlink" title="系统预定义数组 $_SERVER $_GET $_POST"></a>系统预定义数组 $_SERVER $_GET $_POST</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//var_dump(<span class="variable">$_SERVER</span>);</span><br><span class="line">//var_dump(<span class="variable">$_POST</span>);</span><br><span class="line">//var_dump(<span class="variable">$_GET</span>);</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">'name'</span>];</span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_POST</span>[<span class="string">'pass'</span>];</span><br><span class="line">var_dump(<span class="variable">$_POST</span>);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="获取通过post方式上传文件的相关信息"><a href="#获取通过post方式上传文件的相关信息" class="headerlink" title="获取通过post方式上传文件的相关信息"></a>获取通过post方式上传文件的相关信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> * <span class="variable">$_FILES</span></span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line">session_id();</span><br><span class="line">var_dump(session_id());</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="variable">$_COOKIE</span>[<span class="string">'name'</span>] = <span class="string">'xiaobudiu'</span>;</span><br><span class="line"><span class="variable">$_COOKIE</span>[<span class="string">'pass'</span>] = <span class="string">'56611'</span>;</span><br><span class="line">var_dump(<span class="variable">$_COOKIE</span>);</span><br><span class="line">setcookie(<span class="string">'session_id'</span>,<span class="string">''</span>);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="php常用时间处理"><a href="#php常用时间处理" class="headerlink" title="php常用时间处理"></a>php常用时间处理</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取当前时间</span><br><span class="line"> * <span class="keyword">time</span>();</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/var_dump(date('Y-m-d  H:i:s',time()));</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> *取得日期时间信息</span><br><span class="line"> * getdate()</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>*$arr=getdate();</span><br><span class="line">var_dump($arr);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">array(<span class="number">11</span>) &#123;</span><br><span class="line">  [<span class="string">"seconds"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">57</span>)</span><br><span class="line">  [<span class="string">"minutes"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">58</span>)</span><br><span class="line">  [<span class="string">"hours"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">18</span>)</span><br><span class="line">  [<span class="string">"mday"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">4</span>)</span><br><span class="line">  [<span class="string">"wday"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">4</span>)</span><br><span class="line">  [<span class="string">"mon"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  [<span class="string">"year"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2018</span>)</span><br><span class="line">  [<span class="string">"yday"</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">3</span>)</span><br><span class="line">  [<span class="string">"weekday"</span>]=&gt;</span><br><span class="line">  string(<span class="number">8</span>) <span class="string">"Thursday"</span></span><br><span class="line">    [<span class="string">"month"</span>]=&gt;</span><br><span class="line">  string(<span class="number">7</span>) <span class="string">"January"</span></span><br><span class="line">    [<span class="number">0</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1515063537</span>)</span><br><span class="line">&#125;</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 常用时间处理</span><br><span class="line"> *</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 默认时区设置</span><br><span class="line"> * date_default_timezone_set()</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/date_default_timezone_set('PRC');</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 计算两个日期的时间差</span><br><span class="line"> * <span class="number">2017</span>年<span class="number">1</span>月<span class="number">4</span>日<span class="number">20</span>时<span class="number">28</span>分<span class="number">30</span>秒 <span class="number">2018</span>年<span class="number">5</span>月<span class="number">6</span>日<span class="number">19</span>时<span class="number">30</span>分<span class="number">15</span>秒</span><br><span class="line"> * @param $hour_start <span class="keyword">int</span> 起始小时 (这里填<span class="number">20</span>)</span><br><span class="line"> * @param $minutes_start <span class="keyword">int</span> 起始分钟数 (这里填<span class="number">28</span>)</span><br><span class="line"> * @param $seconds_start  <span class="keyword">int</span> 起始秒数 (这里填<span class="number">30</span>)</span><br><span class="line"> * @param $month_start <span class="keyword">int</span> 起始月份 (这里填<span class="number">1</span>)</span><br><span class="line"> * @param $day_start <span class="keyword">int</span> 起始日期(这里填<span class="number">4</span>)</span><br><span class="line"> * @param $year_start <span class="keyword">int</span> 起始年份(这里填<span class="number">2017</span>)</span><br><span class="line"> * @param $hour_end</span><br><span class="line"> * @param $minutes_end</span><br><span class="line"> * @param $second_end</span><br><span class="line"> * @param $month_end</span><br><span class="line"> * @param $day_end</span><br><span class="line"> * @param $year_end</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">function diff_time($year_start,$month_start,$day_start,$hour_start,$minutes_start,$seconds_start,</span><br><span class="line">                   $year_end,$month_end,$day_end,$hour_end,$minutes_end,$second_end)</span><br><span class="line">&#123;</span><br><span class="line">    //<span class="number">2016</span>年<span class="number">1</span>月<span class="number">1</span>日<span class="number">19</span>点<span class="number">30</span>分<span class="number">0</span>秒时间戳</span><br><span class="line">    //$start=mktime(<span class="number">19</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2016</span>)</span><br><span class="line">    $start=mktime($hour_start,$minutes_start,$seconds_start,$month_start,$day_start,$year_start);</span><br><span class="line">    //<span class="number">2016</span>年<span class="number">7</span>月<span class="number">7</span>日<span class="number">7</span>点<span class="number">30</span>分<span class="number">0</span>秒时间戳</span><br><span class="line">    //$end=mktime(<span class="number">7</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">2016</span>);</span><br><span class="line">    $end=mktime($hour_end,$minutes_end,$second_end,$month_end,$day_end,$year_end);</span><br><span class="line">    //时间戳之差</span><br><span class="line">    $diff_seconds=$end-$start;</span><br><span class="line">    //一周的秒数是<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>=<span class="number">604800</span></span><br><span class="line">    $diff_weeks=floor($diff_seconds/<span class="number">604800</span>);</span><br><span class="line">    //一天的秒数是<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>=<span class="number">86400</span></span><br><span class="line">    $diff_days=floor($diff_seconds/<span class="number">86400</span>);</span><br><span class="line">    $diff_hours=floor($diff_seconds/<span class="number">3600</span>);</span><br><span class="line">    $diff_minutes=floor($diff_seconds/<span class="number">60</span>);</span><br><span class="line">    echo <span class="string">"两个时间相差"</span>.<span class="string">"："</span>.$diff_weeks.<span class="string">"个星期，"</span>.$diff_days.<span class="string">"天，"</span>.$diff_hours.<span class="string">"小时，"</span>.$diff_minutes.<span class="string">"分，"</span>. $diff_seconds.<span class="string">"秒"</span>;</span><br><span class="line">&#125;</span><br><span class="line">//示例: <span class="number">2016</span>年<span class="number">9</span>月<span class="number">25</span>日<span class="number">18</span>时<span class="number">25</span>分<span class="number">30</span>秒 <span class="number">2017</span>年<span class="number">1</span>月<span class="number">4</span>日<span class="number">20</span>时<span class="number">36</span>分<span class="number">15</span>秒</span><br><span class="line">diff_time(<span class="number">2016</span>,<span class="number">8</span>,<span class="number">25</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">2017</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">36</span>,<span class="number">15</span>);</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 将具体时间日期转化为时间戳</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">echo mktime(<span class="number">10</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">2016</span>);</span><br><span class="line">echo <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">echo strtotime(<span class="string">'20161025102525'</span>);</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 求两个日期的时间差</span><br><span class="line"> * 求<span class="number">2016.9</span>.<span class="number">4</span> <span class="number">10</span>:<span class="number">32</span>:<span class="number">33</span> 与<span class="number">2017.1</span>.<span class="number">4</span> <span class="number">21</span>:<span class="number">22</span>:<span class="number">23</span></span><br><span class="line"> * @param $start <span class="keyword">int</span> 起始日期 <span class="number">20160904103233</span></span><br><span class="line"> * @param $end <span class="keyword">int</span> 结束日期  <span class="number">20170104212223</span></span><br><span class="line"> * 注:也可以不用strtotime,用mktime()去转化时间戳,其他步骤一样</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">function diff_time($start,$end)</span><br><span class="line">&#123;</span><br><span class="line">    $start=strtotime($start);</span><br><span class="line">    $end=strtotime($end);</span><br><span class="line">    //计算两个时间的时间戳</span><br><span class="line">    $diff_seconds=$end-$start;</span><br><span class="line">    //求相差多少个星期</span><br><span class="line">    $diff_weeks=floor($diff_seconds/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">7</span>));</span><br><span class="line">    //求相差多少天</span><br><span class="line">    $diff_days=floor($diff_seconds/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">    //求相差多少小时</span><br><span class="line">    $diff_hours=floor($diff_seconds/(<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">    //求相差多少分</span><br><span class="line">    $diff_minutes=floor($diff_seconds/<span class="number">60</span>);</span><br><span class="line">    //输出结果</span><br><span class="line">    echo <span class="string">"两个时间相差"</span>.<span class="string">"："</span>.$diff_weeks.<span class="string">"个星期，"</span>.$diff_days.<span class="string">"天，"</span>.$diff_hours.<span class="string">"小时，"</span>.$diff_minutes.<span class="string">"分，"</span>. $diff_seconds.<span class="string">"秒"</span>;</span><br><span class="line">&#125;</span><br><span class="line">diff_time(<span class="string">'20160904103233'</span>,<span class="string">'20170104212223'</span>);</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">$start = <span class="string">'last Friday'</span>;</span><br><span class="line">$time1 = strtotime(<span class="string">"$start + 1days"</span>);</span><br><span class="line">echo date(<span class="string">'Y-m-d  H:i:s'</span>,$time1);</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">$start = <span class="string">'20170430122531'</span>;</span><br><span class="line">$end = <span class="string">'20180104224925'</span>;</span><br><span class="line">//求两个时间戳的差</span><br><span class="line">$diff_time = strtotime($end) - strtotime($start);</span><br><span class="line">//求相差多少天</span><br><span class="line">$diff_days = floor($diff_time/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">echo <span class="string">"两个时间相差"</span>.$diff_days.<span class="string">"天"</span>;</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 验证日期</span><br><span class="line"> * checkdate()</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/var_dump(checkdate(12,32,2016));  /</span><span class="regexp">/bool(false)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 表单的种类</span><br><span class="line"> *input文本域</span><br><span class="line"> *</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">var_dump($_POST);</span><br><span class="line">echo <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">var_dump($_FILES);</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<h2 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理文件上传</span><br><span class="line"> * 在html页面上传文件到本方法所在php文件,在php文件中,调用方法即可<span class="params">(html页面中type为file的input name值为file</span></span><br><span class="line"><span class="params"> * 如果想更改,本方法中$_FILES['file']也要对应更改</span></span><br><span class="line"><span class="params"> */</span></span><br><span class="line"><span class="params"> </span></span><br><span class="line"><span class="params">//function upfiles()</span>&#123;</span><br><span class="line"><span class="string">//</span>    <span class="keyword">if</span> <span class="params">($_FILES['file']['error'] &gt; 0)</span> &#123;</span><br><span class="line"><span class="string">//</span>        <span class="keyword">echo</span> <span class="string">"Error:"</span>.$_FILES['file']['error'].<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="string">//</span>    &#125; else &#123;</span><br><span class="line"><span class="string">//</span>        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line"><span class="string">//</span>        print_r<span class="params">($_FILES['file'])</span>;</span><br><span class="line"><span class="string">//</span>        <span class="string">//</span>将临时文件移动到永久文件</span><br><span class="line"><span class="string">//</span>        <span class="string">//</span>判断文件是否是通过http post上传的</span><br><span class="line"><span class="string">//</span>        <span class="keyword">if</span><span class="params">(is_uploaded_file($_FILES['file']['tmp_name'])</span>)&#123;</span><br><span class="line"><span class="string">//</span>            $upfile = $_FILES['file'];</span><br><span class="line"><span class="string">//</span>            <span class="string">//</span>获取数组里的值</span><br><span class="line"><span class="string">//</span>            $name = $upfile['name'];</span><br><span class="line"><span class="string">//</span>            $tmp_name = $upfile['tmp_name'];</span><br><span class="line"><span class="string">//</span>            <span class="string">//</span>移动上传文件到指定目录<span class="params">(这里用绝对路径,也可以用相对路径,但要注意在文件夹前加上网站根目录)</span></span><br><span class="line"><span class="string">//</span>           /* define<span class="params">('ROOT',dirname(__FILE__)</span>); <span class="string">//E</span>:\PHP\phpstudy\WWW\Project\kk</span><br><span class="line"><span class="string">//</span>            <span class="string">//</span>对移动临时文件是否成功做判断</span><br><span class="line"><span class="string">//</span>            <span class="keyword">if</span><span class="params">(!move_uploaded_file($tmp_name,ROOT."\Upload\\".$name)</span>)&#123;</span><br><span class="line"><span class="string">//</span>                <span class="keyword">echo</span> <span class="string">"Error:移动文件失败,请确认文件名全为英文"</span>;</span><br><span class="line"><span class="string">//</span>            &#125;*/</span><br><span class="line"><span class="string">//</span>            <span class="keyword">if</span><span class="params">(@!move_uploaded_file($tmp_name,"E:\PHP\phpstudy\WWW\Project\kk\Upload\\".$name)</span>)&#123;</span><br><span class="line"><span class="string">//</span>                <span class="keyword">echo</span> <span class="string">"Error:移动文件失败,请确认文件名全为英文"</span>;</span><br><span class="line"><span class="string">//</span>            &#125;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>        &#125;</span><br><span class="line"><span class="string">//</span>    &#125;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>&#125;</span><br><span class="line"><span class="string">//upfiles</span><span class="params">()</span>;</span><br><span class="line"><span class="string">//var_dump</span><span class="params">(__FILE__)</span>;</span><br><span class="line"><span class="string">//var_dump</span><span class="params">(dirname(__FILE__)</span>);</span><br></pre></td></tr></table></figure>
<h2 id="static静态属性与方法"><a href="#static静态属性与方法" class="headerlink" title="static静态属性与方法"></a>static静态属性与方法</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class myclass</span><br><span class="line"> * 静态属性<span class="params">(类属性)</span></span><br><span class="line"> * 类内用self调用,类外使用类名调用</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">class myclass &#123;</span><br><span class="line">    static $staticVal = 10;</span><br><span class="line">    function getStatic<span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> self::$staticVal;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">        self::$staticVal++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> myclass::$staticVal;<span class="string">//10</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">$a = new myclass<span class="params">()</span>;</span><br><span class="line">var_dump<span class="params">($a-&gt;getStatic()</span>);<span class="string">//null</span></span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 静态方法<span class="params">(类方法)</span></span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="string">//class</span> myclass&#123;</span><br><span class="line"><span class="string">//</span>    static $staticVal = 10;</span><br><span class="line"><span class="string">//</span>    public $val = 100;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>    /**</span><br><span class="line"><span class="string">//</span>     * 获取类属性<span class="params">(静态属性 $staticVal)</span></span><br><span class="line"><span class="string">//</span>     */</span><br><span class="line"><span class="string">//</span>    static function getStaticVal<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>        <span class="keyword">echo</span> self::$staticVal;</span><br><span class="line"><span class="string">//</span>    &#125;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>    /**</span><br><span class="line"><span class="string">//</span>     * 类内调用类属性,并对类属性进行改变</span><br><span class="line"><span class="string">//</span>     */</span><br><span class="line"><span class="string">//</span>    static function changeStaicVal<span class="params">()</span>&#123;</span><br><span class="line"><span class="string">//</span>        self::$staticVal++;</span><br><span class="line"><span class="string">//</span>        <span class="keyword">echo</span> self::$staticVal;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>    &#125;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//</span>&#125;</span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">//myclass</span>:<span class="function">:getStaticVal</span><span class="params">()</span>;<span class="string">//10</span></span><br><span class="line"><span class="string">//myclass</span>:<span class="function">:changeStaicVal</span><span class="params">()</span>;<span class="string">//11</span></span><br></pre></td></tr></table></figure>
<h2 id="文件名操作"><a href="#文件名操作" class="headerlink" title="文件名操作"></a>文件名操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件名操作</span><br><span class="line"> * basename()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="built_in">echo</span> __FILE__; //E:\PHP\phpstudy\WWW\Project\kk\index.php</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line"><span class="variable">$a</span> = basename(__FILE__,<span class="string">".php"</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>;  //index</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="构造方法与析构方法"><a href="#构造方法与析构方法" class="headerlink" title="构造方法与析构方法"></a>构造方法与析构方法</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> * 创建对象时自动调用的方法</span></span><br><span class="line"><span class="comment"> * __construct</span></span><br><span class="line"><span class="comment"> * 构造方法常用的场景是在创建对象时给变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//class yourclass&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public $name;</span></span><br><span class="line"><span class="comment">//    public $age;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * yourclass constructor.</span></span><br><span class="line"><span class="comment">//     * 构造方法</span></span><br><span class="line"><span class="comment">//     * 创建对象时自动调用此方法</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    function __construct($name,$age)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        $this-&gt;name = $name;</span></span><br><span class="line"><span class="comment">//        $this-&gt;age = $age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * 析构方法</span></span><br><span class="line"><span class="comment">//     * __destruct</span></span><br><span class="line"><span class="comment">//     * 析构方法是在对象被销毁前自动执行的方法</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    function __destruct()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//$a = new yourclass('xiaoming',25);</span></span><br><span class="line"><span class="comment">//echo $a-&gt;name;</span></span><br></pre></td></tr></table></figure>
<h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装和继承</span></span><br><span class="line"><span class="comment"> * public 任何地方都可以调用</span></span><br><span class="line"><span class="comment"> * protected 本类和子类中可以被调用</span></span><br><span class="line"><span class="comment"> * private 只有本类可以调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装,就是将类中的成员属性和方法内容细节尽量隐藏起来,确保类外部代码不能随意访问类内内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承</span></span><br><span class="line"><span class="comment"> * extends</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多态</span></span><br><span class="line"><span class="comment"> * 多态,通过继承,复用代码实现 可编写出健壮可扩展的的代码 减少流程控制语句的使用</span></span><br><span class="line"><span class="comment"> * 在运行时,根据传递的对象参数,决定调用不用的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回顾函数总结:</span></span><br><span class="line"><span class="comment"> * 函数的三个特性:封装,继承,多态</span></span><br><span class="line"><span class="comment"> * 封装:将函数的成员属性成员方法内容细节尽可能隐藏起来,确保类外部代码不能随意访问类中内容</span></span><br><span class="line"><span class="comment"> * 继承:一个类作为公共基类,其他类继承这个类,则其他类都具有这个类的属性和方法</span></span><br><span class="line"><span class="comment"> * 多态:通过继承复用代码而实现 运行时根据传递的参数对象,决定调用哪一个对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 魔术方法</span><br><span class="line"> * php提供了内置的拦截器,他可以<span class="string">'发送'</span>到未定义方法和属性的消息</span><br><span class="line"> * __set()  __get() __isset() __unset() __call()  __toString()</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __set()</span><br><span class="line"> * 在代码要给未定义的属性赋值时调用,或在类外部修改被private修饰的类属性时被调用</span><br><span class="line"> * 它会传递两个参数;属性名和属性值</span><br><span class="line"> * 通过__set()方法也可以实现对private关键词修饰的属性值进行更改</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __get()</span><br><span class="line"> * 当在类外部访问被private或proteced修饰的属性或访问一个类中原本不存在的属性时被调用</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __isset()</span><br><span class="line"> * 当在类外部对未定义的属性或者非公有属性使用isset()函数时,__isset()将会被调用</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//注:结合 property_exists() property_exists()用来检测类中是否定义了该属性</span><br><span class="line">//用法:property_exists(<span class="string">'magic'</span>,<span class="variable">$key</span>)  检测在magic类中是否定义了<span class="variable">$key</span>属性</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __unset()</span><br><span class="line"> * 对类中未定义的属性或非公有属性进行<span class="built_in">unset</span>()操作时,将会触发__unset()方法.</span><br><span class="line"> * 如果属性存在,<span class="built_in">unset</span>操作会销毁这个属性,释放该属性在内存中占用的空间</span><br><span class="line"> * 再用对象访问这个属性时,将会返回NULL</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __call()</span><br><span class="line"> * 当试图调用不存在的方法时会触发__call()</span><br><span class="line"> * __call()有两个参数,即方法名和参数,参数以索引形式存在</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//class magic&#123;</span><br><span class="line">//    <span class="keyword">function</span> __call(<span class="variable">$func</span>,<span class="variable">$param</span>)</span><br><span class="line">//    &#123;</span><br><span class="line">//        <span class="built_in">echo</span> <span class="string">"<span class="variable">$func</span> method not exists"</span>;</span><br><span class="line">//        var_dump(<span class="variable">$param</span>);</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="variable">$obj</span> = new magic();</span><br><span class="line">//<span class="variable">$obj</span>-&gt; register(<span class="string">'param1'</span>,<span class="string">'param2'</span>,<span class="string">'param3'</span>); //实例化的对象调用不存在的register()方法</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 浏览器结果显示:</span><br><span class="line"> * register method not exist</span><br><span class="line">   sarray(3) &#123;</span><br><span class="line">   [0]=&gt;</span><br><span class="line">   string(6) <span class="string">"param1"</span></span><br><span class="line">   [1]=&gt;</span><br><span class="line">   string(6) <span class="string">"param2"</span></span><br><span class="line">   [2]=&gt;</span><br><span class="line">   string(6) <span class="string">"param3"</span></span><br><span class="line">  &#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * toString()</span><br><span class="line"> * 当使用<span class="built_in">echo</span>或<span class="built_in">print</span>打印对象时会被调用__toString()方法将对象转化为字符串</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">class magic&#123;</span><br><span class="line">    <span class="keyword">function</span> __toString()</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">return</span> <span class="string">'when you want to echo or print the object, __toString() will be called'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new magic();</span><br><span class="line"><span class="built_in">print</span> <span class="variable">$obj</span>; //浏览器显示 when you want to <span class="built_in">echo</span> or <span class="built_in">print</span> the object, __toString() will be called</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动加载</span></span><br><span class="line"><span class="comment"> * __autoload()</span></span><br><span class="line"><span class="comment"> * 当在代码尝试加载未定义的类时会触发__autoload()函数</span></span><br><span class="line"><span class="comment"> * 用法简单示例:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="regexp">//假设有两个文件为myclass.php和yourclass.php,另外,在同一目录下写一个autoload.php文件,代码如下</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>中间代码不起作用,不用解除注释<span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"><span class="regexp">//myclass.php代码</span></span><br><span class="line"><span class="regexp">/*</span></span><br><span class="line"><span class="regexp"> class myclass&#123;</span></span><br><span class="line"><span class="regexp">    function myname()&#123;</span></span><br><span class="line"><span class="regexp">        echo "My Name Is xiaobudiu";</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">//</span>yourclass.php代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yourclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">function</span> yourname()&#123;</span><br><span class="line">        echo <span class="string">"Your Name Is pgone"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">/中间代码不起作用,不用解除注释/</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">///</span></span><br><span class="line"><span class="regexp">/*</span></span><br><span class="line"><span class="regexp">//</span>autoload.php代码</span><br><span class="line"><span class="keyword">function</span> __autoload($name)&#123;</span><br><span class="line">    <span class="keyword">if</span>(file_exists($name.<span class="string">".php"</span>))&#123;</span><br><span class="line">        require_once $name.<span class="string">'php'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        echo <span class="string">"The Path Is Error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$my = <span class="keyword">new</span> myclass();</span><br><span class="line">$my<span class="function"> -&gt;</span> myname();</span><br><span class="line">$your = <span class="keyword">new</span> yourclass();</span><br><span class="line">$your<span class="function"> -&gt;</span> yourname();</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动加载</span></span><br><span class="line"><span class="comment"> * spl_autoload_register(),和__autoload()方法功能相似,实现自动加载二选其一即可</span></span><br><span class="line"><span class="comment"> * 可以实现自动加载以及注册给定的函数作为__autoload()的实现</span></span><br><span class="line"><span class="comment"> * 两个参数 第一个参数autoload_function为要注册的自动装载函数,第二个参数throw为布尔值,true为默认,抛出异常;false不抛出异常</span></span><br><span class="line"><span class="comment"> * 实例:假设当前目录下存在myclass.php和yourclass.php,并且代码和上面一样,autoload.php代码进行更改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*function my_autoloader($class)&#123;</span></span><br><span class="line"><span class="comment">    include $class.'.php';</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">spl_autoload_register('my_autoloader');</span></span><br><span class="line"><span class="comment">$my=new myclass();</span></span><br><span class="line"><span class="comment">$my-&gt;myname();</span></span><br><span class="line"><span class="comment">$your=new yourclass();</span></span><br><span class="line"><span class="comment">$your-&gt;yourname();*/</span></span><br><span class="line"><span class="regexp">//此时运行autoload.php 执行结果 My Name Is xiaobudiu Your Name Is pgone</span></span><br></pre></td></tr></table></figure>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.对接口的继承使用implements,抽象类使用extends.</span><br><span class="line"><span class="number">2</span>.接口中不可以声明变量,但可以声明类常量.抽象类中可以声明各种变量</span><br><span class="line"><span class="number">3</span>.接口没有构造函数,抽象类可以有</span><br><span class="line"><span class="number">4</span>.接口中的方法默认为public,抽象类中的方法可以用public,<span class="keyword">protected</span>,<span class="keyword">private</span>修饰</span><br><span class="line"><span class="number">5</span>.一个类可以继承多个接口,但只能继承一个抽象类</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 抽象类</span><br><span class="line"> * <span class="keyword">abstract</span></span><br><span class="line"> * 一种对下级代码的规范</span><br><span class="line"> * 抽象类和接口都是不能被实例化的特殊类</span><br><span class="line"> * 可以在抽象类和接口中保留公共的方法,将抽象类和接口作为公共的基类</span><br><span class="line"> * 一个抽象类必须至少包含一个抽象方法,抽象类中的方法不能被定义为私有的(<span class="keyword">private</span>),因为抽象类中的方法需要被子类覆盖</span><br><span class="line"> * 同样抽象类中的方法也不能用final修饰,因为其需要被子类继承</span><br><span class="line"> * 抽象类中的抽象方法不包括方法实体.如果一个类中包含了一个抽象方法,那么这个类也必须声明为抽象类</span><br><span class="line"> * 抽象方法不实现具体的功能，由子类来完成</span><br><span class="line"> * 子类必须实现抽象类中的所有方法,否则会报错</span><br><span class="line"> *</span><br><span class="line">语法:</span><br><span class="line"><span class="keyword">abstract</span> class class_name&#123;</span><br><span class="line"><span class="keyword">abstract</span> public <span class="keyword">function</span> <span class="title">func_name1</span>(arg1,arg2);</span><br><span class="line"><span class="keyword">abstract</span> public <span class="keyword">function</span> <span class="title">func_name2</span>(arg1,arg2,arg3);</span><br><span class="line">&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//示例:计算矩形的周长</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> <span class="keyword">abstract</span> class Shape &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">function</span> <span class="title">get_area</span>();</span><br><span class="line">//和一般的方法不同的是，这个方法没有大括号</span><br><span class="line">//你不能创建这个抽象类的实例：$Shape_Rect = <span class="keyword">new</span> Shape();</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle extends Shape</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> $width;</span><br><span class="line">    <span class="keyword">private</span> $height;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">__construct</span>($width = 0, $height = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;width = $width;</span><br><span class="line">        $this-&gt;height = $height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">get_area</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        echo ($this-&gt;width + $this-&gt;height) * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Shape_Rect = new Rectangle(20,10);</span><br><span class="line">$Shape_Rect-&gt;get_area();</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> * <span class="keyword">interface</span></span><br><span class="line"> * 一种对下级代码的规范</span><br><span class="line"> * 与抽象类不同,一个子类可以继承自多个接口,接口之间用<span class="string">','</span>隔开,</span><br><span class="line"> * 接口实现了php的多重继承</span><br><span class="line"> * 接口需要被继承,所以接口中定义的方法不能为私有方法或被final修饰</span><br><span class="line"> * 接口中定义的全部方法都必须被子类实现,并且不能包含实体</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//示例:定义database接口</span><br><span class="line">/*</span><br><span class="line"><span class="keyword">interface</span> Database&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">connect</span>($host,$username,$pwd,$db);</span><br><span class="line">    <span class="keyword">function</span> <span class="title">query</span>($sql);</span><br><span class="line">    <span class="keyword">function</span> <span class="title">fetch</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title">close</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">class mysql implements Database &#123;</span><br><span class="line">    <span class="keyword">protected</span> $conn;</span><br><span class="line">    <span class="keyword">protected</span> $query;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">connect</span>($host, $username, $pwd, $db)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;conn = new mysqli($host,$username,$pwd,$db);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">query</span>($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">$this-&gt;conn-&gt;query($sql)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">fetch</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">$this-&gt;query-&gt;fetch()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">close</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;conn-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        echo "test";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="类中的关键字"><a href="#类中的关键字" class="headerlink" title="类中的关键字"></a>类中的关键字</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">//类中的关键字</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * final</span><br><span class="line"> * 子类可覆写父类中的方法,但是在有些时候并不希望父类中的方法被重写,这时只要在父类中的方法前加上final控制符,</span><br><span class="line"> * 该方法便不能被子类重写,否则会报错</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//错误示范:</span><br><span class="line">/*</span><br><span class="line"> class father&#123;</span><br><span class="line">    final <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"My Name Is xiaobudiu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class son extends father&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"My Name Is PGone"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">//执行程序,浏览器会报错 Fatal error: Cannot override final method father::<span class="built_in">test</span>()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * <span class="built_in">clone</span></span><br><span class="line"> * 可通过<span class="built_in">clone</span>关键字克隆一个对象,克隆后的对象相当于在内存中重新开辟了一个空间</span><br><span class="line"> * 克隆得到的对象拥有和原来对象相同的属性和方法</span><br><span class="line"> * 修改克隆得到的对象不会影响到原来的对象</span><br><span class="line"> */</span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line">class father&#123;</span><br><span class="line">    public <span class="variable">$name</span>=<span class="string">'xiaobudiu'</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new father();</span><br><span class="line"><span class="variable">$obj_clone</span> = <span class="built_in">clone</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="variable">$obj_clone</span>-&gt;name = <span class="string">'PGone'</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$obj_clone</span>-&gt;name; //PGone</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$obj</span>-&gt;name //xiaobudiu</span><br><span class="line">*/</span><br><span class="line">///////////////////////////////////////////</span><br><span class="line">//注:如果使用<span class="string">"="</span>将一个对象赋给一个变量,那么得到的将是一个对象得引用,通过这个变量改变属性的值将会影响原来的对象</span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line">class father&#123;</span><br><span class="line">    public <span class="variable">$name</span> = <span class="string">'xiaobudiu'</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new father();</span><br><span class="line"><span class="variable">$obj_clone</span> = <span class="variable">$obj</span>;</span><br><span class="line"><span class="variable">$obj_clone</span>-&gt;name = <span class="string">'PGone'</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$obj</span>-&gt;name,<span class="variable">$obj_clone</span>-&gt;name;</span><br><span class="line">//PGonePGone</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * __clone()</span><br><span class="line"> * 可以使用__clone()魔术方法将克隆后的副本初始化</span><br><span class="line"> * 可以理解为当对象被克隆时自动调用这个方法</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line">class father&#123;</span><br><span class="line">    public <span class="variable">$name</span> = <span class="string">'xiaobudiu'</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">__clone</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"hi,shuaige"</span>;</span><br><span class="line">        <span class="variable">$this</span>-&gt;name = <span class="string">'PGone'</span>;</span><br><span class="line">        //当克隆对象时,克隆后的对象得到的将是此处的name属性值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new father();</span><br><span class="line"><span class="variable">$obj_clone</span> = <span class="built_in">clone</span> <span class="variable">$obj</span>; //触发__clone()方法 //hi,shuaige</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$obj</span>-&gt;name,<span class="variable">$obj_clone</span>-&gt;name;//xiaobudiuPGone</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * instanceof关键字</span><br><span class="line"> * instanceof可以检测对象属于哪个类</span><br><span class="line"> * 也可以用于检测生成实例的类是否继承自某个接口</span><br><span class="line"> */</span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line">class father &#123;</span><br><span class="line">    public <span class="variable">$name</span> = <span class="string">'xiaobudiu'</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Database &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">class mysql implements Database&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new father();</span><br><span class="line"><span class="variable">$mysql</span> = new mysql();</span><br><span class="line">var_dump(<span class="variable">$obj</span> instanceof father);</span><br><span class="line">var_dump(<span class="variable">$mysql</span> instanceof Database);</span><br><span class="line">var_dump(<span class="variable">$obj</span> instanceof Database);</span><br><span class="line">//bool(<span class="literal">true</span>) bool(<span class="literal">true</span>) bool(<span class="literal">false</span>)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 正则表达式</span><br><span class="line"> * php中有两套函数库支持正则表达式</span><br><span class="line"> * PCRE(Perl Compatible Regular Expression)库提供,与Perl语言兼容的正则表达式函数,以<span class="string">"preg_"</span>为函数的前缀名称</span><br><span class="line"> * POSIX(Portable Operating System Interface)扩展语法正则表达式函数,以<span class="string">"ereg_"</span>为函数的前缀名称</span><br><span class="line"> * PCRE的执行效率高于POSIX</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 普通字符</span><br><span class="line"> * 如 <span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>等</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 元字符</span><br><span class="line"> * 分为单字元字符和多字元字符</span><br><span class="line"> * 如;\d 与数字字符相匹配</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*单字符元字符</span><br><span class="line">//* 零次或多次匹配前面的字符或表达式    zo* 与<span class="string">"z"</span>和<span class="string">"zoo"</span>匹配  &#123;0,&#125;</span><br><span class="line">//+ 一次或多次匹配前面的字符或表达式    zo+ 与<span class="string">"zo"</span>和<span class="string">"zoo"</span>匹配,但与<span class="string">"z"</span>不匹配  &#123;1,&#125;</span><br><span class="line">//? 零次或一次匹配前面的字符或表达式    zo? 与<span class="string">"z"</span>和<span class="string">"zo"</span>匹配,但与<span class="string">"zoo"</span>不匹配  &#123;0,1&#125;</span><br><span class="line">//^ 匹配搜索字符串开始的位置    ^\d&#123;3&#125; 与搜索字符串开始处的3个数字匹配</span><br><span class="line">//^ 如果将^用作括号表达式的第一个字符,就会对字符集求反 比如: [^abc] 匹配除abc以外的任何字符</span><br><span class="line">//$ 匹配搜索字符串结尾的位置    \d&#123;3&#125;$ 与搜索字符串结尾处的3个数字匹配</span><br><span class="line">//. 匹配除换行符\n之外的任何单个字符   a.c与<span class="string">"abc"</span>,<span class="string">"alc"</span>和<span class="string">"a-c"</span>匹配</span><br><span class="line">//. 若要匹配包括\n在内的任意字符,可以使用[\s\S]之类的模式(\s \S属于<span class="string">'非打印字符'</span>)</span><br><span class="line">//[] 标记括号表达式的开始和结尾  [1-4]与<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>匹配  [^aeiouAEIOU]与任何非元音字符匹配</span><br><span class="line">//&#123;&#125; 标记限定符表达式的开始和结尾   a&#123;2,3&#125;与<span class="string">"aa"</span>和<span class="string">"aaa"</span>匹配</span><br><span class="line">//() 标记子表达式的开始和结尾,可以保存子表达式,以备将来之用   A(\d)与<span class="string">"A0"</span>至<span class="string">"A9"</span>匹配</span><br><span class="line">//|  指示在两个或多个选项之间进行选择   z|food 与<span class="string">"z"</span>或<span class="string">"food"</span>匹配; (z|f)ood与<span class="string">"zood"</span>或<span class="string">"food"</span>匹配</span><br><span class="line">///  表示JScript中的文本正则表达式模式的开始或结尾.在第二个<span class="string">"/"</span>后添加单字符标志可以指定搜索行为</span><br><span class="line">///  /abc/gi 是与<span class="string">"abc"</span>匹配的JScript文本正则表达式.g(全局)标志指定查找模式的所有匹配项,i(忽略大小写)标志使搜索不区分大小写</span><br><span class="line">//\  转义字符 \\与<span class="string">"\"匹配, \(与"</span>(<span class="string">"匹配, \n与换行符匹配</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/*多字符元字符</span></span><br><span class="line"><span class="string">\b 与一个字边界匹配(即字与空格间的位置) er\b与"</span>never<span class="string">"中的"</span>er<span class="string">"匹配,但与"</span>verb<span class="string">"中的"</span>er<span class="string">"不匹配</span></span><br><span class="line"><span class="string">\B 与非边界字匹配  er\B与"</span>verb<span class="string">"中的er匹配,但与"</span>never<span class="string">"中的er不匹配</span></span><br><span class="line"><span class="string">\d 与数字字符匹配,等效于[0-9]  \d&#123;2&#125;与"</span>12 345<span class="string">"中的"</span>12<span class="string">"和"</span>34<span class="string">"匹配</span></span><br><span class="line"><span class="string">\D 与非数字匹配,等效于[^0-9]   \D+与"</span>abc123 def<span class="string">"中的'abc"</span>和<span class="string">"def"</span>匹配</span><br><span class="line">\w 与a-z,A-Z,0-9,和下划线中的任意字符匹配   在<span class="string">"my name is xiaobudiu..."</span>中，\w与<span class="string">"my"</span>,<span class="string">"name"</span>,<span class="string">"is"</span>,<span class="string">"xiaobudiu"</span>匹配</span><br><span class="line">\W 与除a-z,A-Z,0-9,和下划线中的任意字符匹配 等效于[^a-zA-Z0-9]</span><br><span class="line">[xyz] 字符集,与任何一个指定字符匹配  [abc]与<span class="string">"plane"</span>中的a匹配</span><br><span class="line">[^xyz] 反向字符集,与未指定的任何字符匹配</span><br><span class="line">[a-z] 字符范围,匹配指定范围内的任何字符</span><br><span class="line">[^a-z] 反向字符范围,与不在指定范围内的任何字符匹配</span><br><span class="line">&#123;n&#125; 正好匹配n次,n是非负整数 o&#123;2&#125;与<span class="string">'Bob'</span>中的<span class="string">"o"</span>不匹配,但与<span class="string">"food"</span>中的<span class="string">"oo"</span>匹配</span><br><span class="line">&#123;n,&#125; 至少匹配n次,n是非负整数 o&#123;2,&#125;与<span class="string">'Bob'</span>中的<span class="string">'o'</span>不匹配,但与<span class="string">"fooood"</span>中的所有<span class="string">"o"</span>匹配</span><br><span class="line">&#123;n,m&#125; 匹配至少n次,至多m次   在搜索字符串<span class="string">"1234567"</span>中,\d&#123;1,3&#125;与<span class="string">"123"</span>,<span class="string">"456"</span>和<span class="string">"7"</span>匹配</span><br><span class="line">(模式) 与模式匹配并保存匹配项  (Chapter|Section) [1-9]与<span class="string">"Chapter 5"</span>匹配,保存<span class="string">"Chapter"</span>以备将来之用</span><br><span class="line">(?:模式) 与模式匹配,但不保存匹配项以备将来之用  industr(?:y|ies)与industry|industries相等</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*非打印字符</span><br><span class="line">\f 换页符</span><br><span class="line">\n 换行符</span><br><span class="line">\r 回车符</span><br><span class="line">\t Tab字符</span><br><span class="line">\v 垂直制表符</span><br><span class="line">\s 任何空白字符,包括空格,制表符,换页符 等效于[\f\n\r\t\v]</span><br><span class="line">\S 任何非空白字符  等效于[^\f\n\r\t\v]</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">//////////////////////////////正则表达式正式部分//////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * php中使用正则表达式</span><br><span class="line"> *</span><br><span class="line"> * 匹配与查找</span><br><span class="line"> * preg_match()</span><br><span class="line"> * preg_match_all()</span><br><span class="line"> * preg_grep()</span><br><span class="line"> *</span><br><span class="line"> * 搜索与替换</span><br><span class="line"> * preg_replace()</span><br><span class="line"> * preg_filter()</span><br><span class="line"> *</span><br><span class="line"> * 分割与转义</span><br><span class="line"> * preg_split()</span><br><span class="line"> * preg_quote()</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 匹配与查找</span><br><span class="line"> * preg_match</span><br><span class="line"> * 返回int</span><br><span class="line"> * 语法: preg_match(<span class="variable">$pattern</span>,<span class="variable">$subject</span> [array &amp; <span class="variable">$matches</span>[,<span class="variable">$flags</span>=0 [,<span class="variable">$offset</span>=0]]])</span><br><span class="line"> * pattern是要搜索的模式,例如<span class="string">'/^def/'</span>;</span><br><span class="line"> * subject是指定的被搜索的字符串</span><br><span class="line"> * 它的值是0或1,在匹配一次后就会停止搜索</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"><span class="variable">$subject</span>=<span class="string">"abcdefghijkdef"</span>;</span><br><span class="line"><span class="variable">$pattern_1</span>=<span class="string">'/def/'</span>;</span><br><span class="line"><span class="variable">$num</span>=preg_match(<span class="variable">$pattern_1</span>,<span class="variable">$subject</span>);</span><br><span class="line">var_dump(<span class="variable">$num</span>);</span><br><span class="line">*/</span><br><span class="line">// int(1)</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 匹配与查找</span><br><span class="line"> * preg_match_all()函数</span><br><span class="line"> * 返回int</span><br><span class="line"> * 与preg_match功能相似,只不过在搜索到一次结果之后会继续搜索,知道末尾</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 匹配与查找</span><br><span class="line"> * preg_grep()函数</span><br><span class="line"> * 返回array</span><br><span class="line"> * 可返回匹配模式的数组条目</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">//代码示例:</span><br><span class="line"><span class="variable">$subject</span> = [<span class="string">'abc'</span>,<span class="string">'def'</span>,<span class="string">'efg'</span>,<span class="string">'hijk'</span>,<span class="string">'abcdef'</span>,<span class="string">'defabc'</span>];</span><br><span class="line"><span class="variable">$pattern</span> = <span class="string">'/def$/'</span>;</span><br><span class="line"><span class="variable">$grep_1</span> = preg_grep(<span class="variable">$pattern</span>,<span class="variable">$subject</span>);//返回与<span class="variable">$pattern</span>匹配的元素组成的数组</span><br><span class="line">var_dump(<span class="variable">$grep_1</span>);</span><br><span class="line"><span class="variable">$grep_2</span> = preg_grep(<span class="variable">$pattern</span>,<span class="variable">$subject</span>,PREG_GREP_INVERT);//返回与<span class="variable">$pattern</span>不匹配的元素组成的数组</span><br><span class="line">var_dump(<span class="variable">$grep_2</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">//浏览器显示:</span><br><span class="line"> array(2) &#123;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(3) <span class="string">"def"</span></span><br><span class="line">  [4]=&gt;</span><br><span class="line">  string(6) <span class="string">"abcdef"</span></span><br><span class="line">&#125;</span><br><span class="line">array(4) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(3) <span class="string">"abc"</span></span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(3) <span class="string">"efg"</span></span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(4) <span class="string">"hijk"</span></span><br><span class="line">  [5]=&gt;</span><br><span class="line">  string(6) <span class="string">"defabc"</span></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 搜索与替换</span><br><span class="line"> * preg_replace()</span><br><span class="line"> * 返回替换之后的字符串</span><br><span class="line"> * 三个参数,第一个参数:<span class="variable">$pattern</span> 搜索模式(规则) 可以是一个字符串或字符串数组</span><br><span class="line"> * 第二个参数:<span class="variable">$replacement</span> 用于替换的字符串或字符串数组</span><br><span class="line"> * 第三个参数:<span class="variable">$subject</span> 要进行搜索和替换的字符串或字符串数组</span><br><span class="line"> * <span class="built_in">limit</span> 每个模式在每个subject上进行替换的最大次数 默认-1(无限)</span><br><span class="line"> * count 如果指定,就会被填充为完成的替换次数</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$string_1</span> = <span class="string">'lily likes apple,no reason'</span>;</span><br><span class="line"><span class="variable">$pattern_1</span> = [<span class="string">'/lily/'</span>,<span class="string">'/likes/'</span>,<span class="string">'/apple/'</span>];</span><br><span class="line"><span class="variable">$replacement_1</span> = [<span class="string">'tom'</span>,<span class="string">'hates'</span>,<span class="string">'orange'</span>];</span><br><span class="line"><span class="built_in">echo</span> preg_replace(<span class="variable">$pattern_1</span>,<span class="variable">$replacement_1</span>,<span class="variable">$string_1</span>); //tom hates orange,no reason</span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">'lily likes apple,no reason'</span>,<span class="string">'Tom hates orange,no reason'</span>];</span><br><span class="line"><span class="variable">$pattern_2</span> = [<span class="string">'/no/'</span>,<span class="string">'/reason/'</span>];</span><br><span class="line"><span class="variable">$replacement_2</span> = [<span class="string">'why'</span>,<span class="string">'?'</span>];</span><br><span class="line">var_dump(preg_replace(<span class="variable">$pattern_2</span>,<span class="variable">$replacement_2</span>,<span class="variable">$arr</span>)); //array(2) &#123; [0]=&gt; string(22) <span class="string">"lily likes apple,why ?"</span> [1]=&gt; string(22) <span class="string">"Tom hates orange,why ?"</span> &#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 搜索与替换</span><br><span class="line"> * preg_filter()</span><br><span class="line"> * 与preg_replace()功能相似</span><br><span class="line"> * preg_filter()只返回执行替换的元素(替换后的)(没执行替换的不返回)</span><br><span class="line"> * 而preg_replace()返回全部元素(替换后的)(替没替换都返回)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 分割</span><br><span class="line"> * preg_split</span><br><span class="line"> * 通过一个正则表达式分割字符串</span><br><span class="line"> * array preg_split(<span class="variable">$pattern</span> <span class="variable">$subject</span>[,<span class="variable">$limit</span>=-1 [,<span class="variable">$flag</span>=0]])</span><br><span class="line"> * <span class="variable">$patern</span>  用于搜索的模式(规则)</span><br><span class="line"> * <span class="variable">$subject</span> 输入字符串</span><br><span class="line"> * <span class="variable">$limit</span> 如果指定,就将限制分隔得到的子串最多只有<span class="built_in">limit</span>个,返回的最后一个子串将包含所有剩余部分 <span class="built_in">limit</span>为-1,0,null时都代表不限制</span><br><span class="line"> */</span><br><span class="line">//示例:</span><br><span class="line"> </span><br><span class="line">//<span class="variable">$subject</span> = <span class="string">"I LIKE  APPLE,AND YOU"</span>;</span><br><span class="line">//<span class="variable">$patern</span> = <span class="string">'/[\s,]+/'</span>;</span><br><span class="line">//var_dump(preg_split(<span class="variable">$patern</span>,<span class="variable">$subject</span>));</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> array(5) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) <span class="string">"I"</span></span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(4) <span class="string">"LIKE"</span></span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(5) <span class="string">"APPLE"</span></span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(3) <span class="string">"AND"</span></span><br><span class="line">  [4]=&gt;</span><br><span class="line">  string(3) <span class="string">"YOU"</span></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 转义</span><br><span class="line"> * preg_quote()</span><br><span class="line"> * 函数转义正则表达式</span><br><span class="line"> * preg_quote(<span class="variable">$str</span> [,<span class="variable">$delimiter</span>])</span><br><span class="line"> * <span class="variable">$str</span> 函数会向字符串中的每一个特殊字符前增加一个反斜线</span><br><span class="line"> * 如果指定了<span class="variable">$delimiter</span>,则在指定的<span class="variable">$delimiter</span>前也加反斜线</span><br><span class="line"> * 正则表达式特殊字符包括  . \ + * ? [ ? ] $ ( ) &#123;  &#125; = ! &lt; &gt; | : -</span><br><span class="line"> */</span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$keywords</span> = <span class="string">"<span class="variable">$40</span> for \a g3/400*10/x"</span>;</span><br><span class="line"><span class="variable">$keywords</span> = preg_quote(<span class="variable">$keywords</span>,<span class="string">'x'</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$keywords</span>; //\<span class="variable">$40</span> <span class="keyword">for</span> \\a g3/400\*10/\x</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异常处理</span><br><span class="line"> * php自带的Exception异常类</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*error_reporting(<span class="number">0</span>);//设置错误级别为<span class="number">0</span>,不报错</span><br><span class="line"><span class="keyword">function</span> theDatabaseObj() &#123;</span><br><span class="line">    <span class="variable">$mysql</span> = mysqli_connect(<span class="string">'127.0.0.1'</span>,<span class="string">'root2'</span>,<span class="string">'root'</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$mysql</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$mysql</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> new Exception(<span class="string">"could't connect to the database,try again"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> db()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="variable">$db</span> = theDatabaseObj();</span><br><span class="line">        var_dump(<span class="variable">$db</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception <span class="variable">$e</span>)&#123;</span><br><span class="line">        echo <span class="variable">$e</span>-&gt;getMessage();</span><br><span class="line">//        echo <span class="variable">$e</span>-&gt;getCode();</span><br><span class="line">//        echo <span class="variable">$e</span>-&gt;getLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">db();*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 创建自己的异常类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*class aException extends Exception&#123;</span><br><span class="line">    <span class="keyword">function</span> aEX()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is the bad way"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class aaa &#123;</span><br><span class="line">    <span class="keyword">function</span> a() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            echo <span class="string">"wrong"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> new aException(<span class="string">'你错了,太笨了le'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> b() &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="variable">$b</span> = <span class="variable">$this</span>-&gt;a();</span><br><span class="line">            var_dump(<span class="variable">$b</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception <span class="variable">$E</span>) &#123;</span><br><span class="line">            echo <span class="variable">$E</span>-&gt;getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = new aaa();</span><br><span class="line"><span class="variable">$obj</span>-&gt;b();*/</span><br><span class="line"> </span><br><span class="line">//实现的功能,调用exception异常处理</span><br><span class="line">/*<span class="keyword">function</span> aaa()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">'name'</span>] == <span class="string">'xiaobudiu'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"尊贵的管理员,请登录"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> new Exception(<span class="string">'你没有权限登录'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> upload() &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="variable">$upload</span> = aaa();</span><br><span class="line">        var_dump(<span class="variable">$upload</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception <span class="variable">$e</span>) &#123;</span><br><span class="line">        echo <span class="variable">$e</span>-&gt;getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">upload();*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**.</span><br><span class="line"> * php7中的错误处理</span><br><span class="line"> * 大多数错误开始被当做Error异常抛出,而不是Exception异常</span><br><span class="line"> * <span class="keyword">catch</span>(<span class="variable">$Error</span> <span class="variable">$e</span>)</span><br><span class="line"> */</span><br><span class="line">/*<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable">$a</span> = new zoo();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Error <span class="variable">$E</span>)&#123;</span><br><span class="line">    echo <span class="string">"error_msg:"</span>.<span class="variable">$E</span>-&gt;getMessage();</span><br><span class="line">&#125;*/</span><br><span class="line">//error_msg:Class <span class="string">'zoo'</span> not found</span><br><span class="line">//注:这种Error异常处理方式只适用于php7,php5版本还是要用Exception异常类来处理错误及异常</span><br></pre></td></tr></table></figure>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 图像处理</span><br><span class="line"> * 图像处理要求GD库</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//使用函数查看一下当前安装没有GD库</span></span><br><span class="line"><span class="comment">//echo "&lt;pre&gt;";</span></span><br><span class="line"><span class="comment">//var_dump(get_loaded_extensions());</span></span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 取得图像大小</span><br><span class="line"> * getimagesize()</span><br><span class="line"> * 返回图像的尺寸以及文件类型</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//print_r(getimagesize('./Upload/IGS09651F94M.jpg'));</span></span><br><span class="line"> </span><br><span class="line">/*浏览器结果</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">740</span> <span class="comment">//宽度像素值</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">1166</span> <span class="comment">//高度像素值</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">2</span> <span class="comment">//图像标记,gif是1,jpg是2,png是3,swf是4,psd是5....</span></span><br><span class="line">    [<span class="number">3</span>] =&gt; width=<span class="string">"740"</span> height=<span class="string">"1166"</span> <span class="comment">//文本字符串</span></span><br><span class="line">    [bits] =&gt; <span class="number">8</span> <span class="comment">//每种颜色的位数</span></span><br><span class="line">    [channels] =&gt; <span class="number">3</span> <span class="comment">//RGB图像是3,CMVK图像是4</span></span><br><span class="line">    [mime] =&gt; image/jpeg</span><br><span class="line">)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * getimagesizefromstring()</span><br><span class="line"> * 从字符串中获取图像尺寸信息</span><br><span class="line"> * 与getimagesize()函数的参数和返回结果相同,区别是getimagesizefromstring()的第一个参数是图像数据的字符串表达,而不是文件名</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//$img = file_get_contents('./Upload/IGS09651F94M.jpg');</span></span><br><span class="line"><span class="comment">//var_dump(getimagesizefromstring($img));</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*浏览器结果:</span><br><span class="line"> array(<span class="number">7</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  <span class="type">int</span>(<span class="number">740</span>)</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  <span class="type">int</span>(<span class="number">1166</span>)</span><br><span class="line">  [<span class="number">2</span>]=&gt;</span><br><span class="line">  <span class="type">int</span>(<span class="number">2</span>)</span><br><span class="line">  [<span class="number">3</span>]=&gt;</span><br><span class="line">  <span class="built_in">string</span>(<span class="number">25</span>) <span class="string">"width="</span><span class="number">740</span><span class="string">" height="</span><span class="number">1166</span><span class="string">""</span></span><br><span class="line">  [<span class="string">"bits"</span>]=&gt;</span><br><span class="line">  <span class="type">int</span>(<span class="number">8</span>)</span><br><span class="line">  [<span class="string">"channels"</span>]=&gt;</span><br><span class="line">  <span class="type">int</span>(<span class="number">3</span>)</span><br><span class="line">  [<span class="string">"mime"</span>]=&gt;</span><br><span class="line">  <span class="built_in">string</span>(<span class="number">10</span>) <span class="string">"image/jpeg"</span></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * imagesx,imagesy</span><br><span class="line"> * 取得图像的宽度和高度</span><br><span class="line"> */</span><br><span class="line">/*$img = imagecreatetruecolor(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">echo imagesx($img);<span class="comment">//300</span></span><br><span class="line">echo imagesy($img);<span class="comment">//200*/</span></span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 图像绘制</span><br><span class="line"> * imagecreate(),可创建一个基于调色板的图像</span><br><span class="line"> * 与imagecreateturecolor()作用和参数相同</span><br><span class="line"> * 返回一个图像标识符,代表了一幅大小为x_size和y_size的空白图像</span><br><span class="line"> * <span class="number">1.</span>创建画布</span><br><span class="line"> * <span class="number">2.</span>在画布上绘制图形</span><br><span class="line"> * <span class="number">3.</span>保存并输出结果图像</span><br><span class="line"> * <span class="number">4.</span>销毁图像资源</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"><span class="comment">//创建一个空白画布,并输出一个png格式的图片</span></span><br><span class="line">header(<span class="string">"Content-type:image/png"</span>);<span class="comment">//设置mime类型</span></span><br><span class="line">$image = @imagecreate(<span class="number">120</span>,<span class="number">30</span>) <span class="built_in">or</span> die(<span class="string">"Cannot Initialize new GD image stream"</span>); <span class="comment">//创建画布</span></span><br><span class="line">$background_color = imagecolorallocate($image,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);<span class="comment">//定义颜色</span></span><br><span class="line">imagepng($image);<span class="comment">//输出png格式图像</span></span><br><span class="line">imagedestroy($image);<span class="comment">//销毁图像资源,释放内存</span></span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 定义颜色</span><br><span class="line"> * imagecolorallocate()</span><br><span class="line"> * 给图像的边框背景和文字等元素指定颜色</span><br><span class="line"> * 返回一个标识符,代表由给定的RGB成分组成的颜色</span><br><span class="line"> * 与imagecolorallocate()功能相似的第一个函数是imagecolorallocatealpha(),区别在于后者多了一个透明度参数<span class="number">0</span><span class="number">-127</span> <span class="number">127</span>表示完全透明</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 绘制椭圆</span><br><span class="line"> * imageellipse()</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//新建一个空白的图像</span></span><br><span class="line">/*</span><br><span class="line">$image = imagecreatetruecolor(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">//填充背景色</span></span><br><span class="line">$bg = imagecolorallocate($image,<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line"><span class="comment">//选择椭圆的颜色</span></span><br><span class="line">$col_ellipse = imagecolorallocate($image,<span class="number">55</span>,<span class="number">55</span>,<span class="number">255</span>);</span><br><span class="line"><span class="comment">//画一个椭圆</span></span><br><span class="line">imageellipse($image,<span class="number">200</span>,<span class="number">150</span>,<span class="number">300</span>,<span class="number">200</span>,$col_ellipse);</span><br><span class="line"><span class="comment">//输出图像</span></span><br><span class="line">header(<span class="string">"Content-type:image/png"</span>);</span><br><span class="line">imagepng($image);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 将文字写入图像</span><br><span class="line"> * imagefttext()</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="comment">//echo "&lt;img src=code.php&gt;";//生成图片</span></span><br></pre></td></tr></table></figure>
<h2 id="目录文件操作"><a href="#目录文件操作" class="headerlink" title="目录文件操作"></a>目录文件操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断文件类型</span><br><span class="line"> * filetype()</span><br><span class="line"> * 返回文件的类型.可能值有fifo,char,dir,block,link,file和unknown,出错返回<span class="literal">false</span></span><br><span class="line"> */</span><br><span class="line">//<span class="built_in">echo</span> filetype(<span class="string">'code.php'</span>);//file</span><br><span class="line">//<span class="built_in">echo</span> filetype(<span class="string">'./Public'</span>);//filedir</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 判断是否是一个目录</span><br><span class="line"> * is_dir()</span><br><span class="line"> */</span><br><span class="line">//var_dump(is_dir(<span class="string">'Upload'</span>));//bool(<span class="literal">true</span>)</span><br><span class="line">//var_dump(is_dir(<span class="string">'index.php'</span>));//bool(<span class="literal">false</span>)</span><br><span class="line">//var_dump(is_dir(<span class="string">'Upload/aa.jpg'</span>));//bool(<span class="literal">false</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 创建目录</span><br><span class="line"> * mkdir()</span><br><span class="line"> * 创建成功返回<span class="literal">true</span> recursive值为<span class="literal">true</span>时,表示允许递归创建目录</span><br><span class="line"> */</span><br><span class="line">/*/</span><br><span class="line">error_reporting(0);</span><br><span class="line"><span class="keyword">function</span> mkd(<span class="variable">$name</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(<span class="variable">$name</span>)) &#123;</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"file already exists"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            mkdir(<span class="variable">$name</span>,0777,<span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"创建成功"</span>;</span><br><span class="line">        &#125;catch (Exception <span class="variable">$e</span>)&#123;</span><br><span class="line">            throw new Exception(<span class="string">'创建目录失败,请核查后重试'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mkd(<span class="string">'./aa/bb'</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 删除目录</span><br><span class="line"> * rmdir</span><br><span class="line"> * 尝试删除dir所指定的目录.该目录必须为空,并且要拥有相应权限</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">error_reporting(0);</span><br><span class="line"><span class="variable">$dir</span> = <span class="string">'./aa/bb'</span>;</span><br><span class="line"><span class="keyword">if</span> (rmdir(<span class="variable">$dir</span>)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Remove Dir Successfuly"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    die(<span class="string">'failes to delete folders...'</span>);</span><br><span class="line">&#125;</span><br><span class="line">//注:只能删除一个文件夹,例如<span class="variable">$dir</span>中的<span class="string">'./aa/bb'</span>,就只删除了一个bb文件夹,aa仍在</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * scandir</span><br><span class="line"> * 列出指定路径中的文件和目录</span><br><span class="line"> * 第二个参数shorting可选,设为1,即按字母降序,默认升序</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//<span class="variable">$dir</span> = <span class="string">'./'</span>;</span><br><span class="line">//<span class="variable">$dir1</span> = scandir(<span class="variable">$dir</span>,1);</span><br><span class="line">//var_dump(<span class="variable">$dir1</span>);</span><br><span class="line">/*</span><br><span class="line">array(16) &#123; </span><br><span class="line">  [0]=&gt;  tring(9) <span class="string">"test.html"</span></span><br><span class="line">  [1]=&gt;  tring(11) <span class="string">"option.html"</span></span><br><span class="line">  [2]=&gt;  tring(11) <span class="string">"indexx.html"</span></span><br><span class="line">  [3]=&gt;  string(9) <span class="string">"index.php"</span></span><br><span class="line">  [4]=&gt;  tring(5) <span class="string">"index"</span></span><br><span class="line">  [5]=&gt;  tring(11) <span class="string">"favicon.ico"</span></span><br><span class="line">  [6]=&gt;  tring(8) <span class="string">"code.php"</span></span><br><span class="line">  [7]=&gt;  tring(2) <span class="string">"aa"</span></span><br><span class="line">  [8]=&gt;  tring(6) <span class="string">"Upload"</span></span><br><span class="line">  [9]=&gt;  tring(6) <span class="string">"Public"</span></span><br><span class="line">  [10]=&gt; string(5) <span class="string">"2.css"</span></span><br><span class="line">  [11]=&gt; &gt;string(5) <span class="string">"1.php"</span></span><br><span class="line">  [12]=&gt; string(5) <span class="string">"1.css"</span></span><br><span class="line">  [13]=&gt; string(5) <span class="string">".idea"</span></span><br><span class="line">  [14]=&gt; string(2) <span class="string">".."</span></span><br><span class="line">  [15]=&gt; string(1) <span class="string">"."</span></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * dirname()</span><br><span class="line"> * 返回路径中的目录部分</span><br><span class="line"> */</span><br><span class="line">//<span class="built_in">echo</span> dirname(<span class="string">'./Public/favicon.ico'</span>); // ./Public</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 查看磁盘空间</span><br><span class="line"> * disk_free_space(); 返回磁盘分区可用字节数</span><br><span class="line"> * disk_total_space();返回磁盘分区总容量</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//<span class="built_in">echo</span> disk_total_space(<span class="string">'/'</span>);//191392714752</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 打开文件</span><br><span class="line"> * fopen()</span><br><span class="line"> * 有参数r,r+,w,w+,a,a+,x,x+,c,c+</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 读取文件</span><br><span class="line"> * fgets()</span><br><span class="line"> * 第一个参数表示资源</span><br><span class="line"> * 第二个参数表示读取多少字节,默认1kb(1024字节)</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = fopen(<span class="string">"code.php"</span>, <span class="string">"r"</span>);</span><br><span class="line">//输出文本中所有的行，直到文件结束为止。</span><br><span class="line">//feof() 函数检测是否已到达文件末尾 (eof)。</span><br><span class="line">//如果文件指针到了 EOF 或者出错时则返回 TRUE，否则返回一个错误（包括 socket 超时），其它情况则返回 FALSE</span><br><span class="line"><span class="keyword">while</span>(! feof(<span class="variable">$file</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> fgets(<span class="variable">$file</span>). <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="variable">$file</span>);</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">//要求:读取code.php中所有行数内容</span><br><span class="line">//打开文件</span><br><span class="line"><span class="variable">$file</span> = fopen(<span class="string">'code.php'</span>,<span class="string">"r"</span>);</span><br><span class="line">//读取文件</span><br><span class="line"><span class="keyword">while</span>(!feof(<span class="variable">$file</span>))&#123;//只要不读到末尾,就输出本行</span><br><span class="line">   <span class="built_in">echo</span> fgets(<span class="variable">$file</span>).<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="variable">$file</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取文件上次访问的时间</span><br><span class="line"> * fileatime()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = <span class="string">'code.php'</span>;</span><br><span class="line"><span class="keyword">if</span>(file_exists(<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span>.<span class="string">"上次访问的时间是"</span>.date(<span class="string">"Y-m-d H:i:s"</span>,fileatime(<span class="variable">$file</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"您所访问的文件不存在,请核查后重新操作"</span>;</span><br><span class="line">&#125;</span><br><span class="line">//code.php上次访问的时间是2018-01-08 00:17:28</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取文件上次被修改的时间</span><br><span class="line"> * filemtime()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = <span class="string">"code.php"</span>;</span><br><span class="line"><span class="keyword">if</span>(file_exists(<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span>.<span class="string">"上次修改的时间为"</span>.date(<span class="string">"Y-m-d H:i:s"</span>,filemtime(<span class="variable">$file</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"您所访问的文件不存在,请核查后重新操作"</span>;</span><br><span class="line">&#125;</span><br><span class="line">//code.php上次修改的时间为2018-01-08 00:17:28</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * filesize()</span><br><span class="line"> *获取文件的大小</span><br><span class="line"> * 返回文件大小的字节数</span><br><span class="line"> */</span><br><span class="line">//<span class="built_in">echo</span> filesize(<span class="string">'./code.php'</span>);//1937</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * filetype()</span><br><span class="line"> * 返回文件的类型</span><br><span class="line"> */</span><br><span class="line">//<span class="built_in">echo</span> filetype(<span class="string">'./code.php'</span>);//file</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * <span class="built_in">stat</span>()</span><br><span class="line"> * 给出文件的详细信息</span><br><span class="line"> * 能返回上次访问,上次修改,文件大小等各种信息</span><br><span class="line"> */</span><br><span class="line">//var_dump(<span class="built_in">stat</span>(<span class="string">"./code.php"</span>));</span><br><span class="line">/*</span><br><span class="line"> array(26) &#123; </span><br><span class="line">  [0]=&gt;     int(4)</span><br><span class="line">  [1]=&gt;     int(0)  </span><br><span class="line">  [2]=&gt;     int(33206)</span><br><span class="line">  [3]=&gt;     int(1)</span><br><span class="line">  [4]=&gt;     int(0)</span><br><span class="line">  [5]=&gt;     int(0)</span><br><span class="line">  [6]=&gt;     int(4)</span><br><span class="line">  [7]=&gt;     int(1937)</span><br><span class="line">  [8]=&gt;     int(1515341848)</span><br><span class="line">  [9]=&gt;     int(1515341848)</span><br><span class="line">  [10]=&gt;    int(1515334800)</span><br><span class="line">  [11]=&gt;    int(-1)</span><br><span class="line">  [12]=&gt;    int(-1)</span><br><span class="line">  [<span class="string">"dev"</span>]=&gt;     int(4)</span><br><span class="line">  [<span class="string">"ino"</span>]=&gt;     int(0)</span><br><span class="line">  [<span class="string">"mode"</span>]=&gt;    int(33206)</span><br><span class="line">  [<span class="string">"nlink"</span>]=&gt;   int(1)</span><br><span class="line">  [<span class="string">"uid"</span>]=&gt;     int(0)</span><br><span class="line">  [<span class="string">"gid"</span>]=&gt;     int(0)</span><br><span class="line">  [<span class="string">"rdev"</span>]=&gt;    int(4)</span><br><span class="line">  [<span class="string">"size"</span>]=&gt;    int(1937)</span><br><span class="line">  [<span class="string">"atime"</span>]=&gt;   int(1515341848)</span><br><span class="line">  [<span class="string">"mtime"</span>]=&gt;   int(1515341848)</span><br><span class="line">  [<span class="string">"ctime"</span>]=&gt;   int(1515334800)</span><br><span class="line">  [<span class="string">"blksize"</span>]=&gt; int(-1)</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 复制文件</span><br><span class="line"> * copy()</span><br><span class="line"> * 第一个参数是resource,第二个参数dist表示复制到哪里</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = <span class="string">'./code.php'</span>;</span><br><span class="line"><span class="variable">$newfile</span> = <span class="string">'aa/code2.php'</span>;</span><br><span class="line"><span class="keyword">if</span> (copy(<span class="variable">$file</span>,<span class="variable">$newfile</span>))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"复制文件"</span>.<span class="variable">$file</span>.<span class="string">"到"</span>.<span class="variable">$newfile</span>.<span class="string">"成功"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"复制文件"</span>.<span class="variable">$file</span>.<span class="string">"失败"</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 删除文件</span><br><span class="line"> * unlink()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = <span class="string">'./aa/code2.php'</span>;</span><br><span class="line"><span class="keyword">if</span>(unlink(<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"删除文件"</span>.<span class="variable">$file</span>.<span class="string">"成功"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"删除文件失败"</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *移动或重命名文件</span><br><span class="line"> * rename()</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">error_reporting(0);</span><br><span class="line"><span class="keyword">if</span>(rename(<span class="string">'2.php'</span>,<span class="string">'1.php'</span>))&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"文件重命名成功"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Rename Failed"</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 文件指针</span><br><span class="line"> * 可以实现文件指针的定位和 查询,从而实现所需信息的快速查询</span><br><span class="line"> * rewind() 将文件位置指针设为文件流的开头</span><br><span class="line"> * fseek()  在文件指针中定位</span><br><span class="line"> * ftell()  返回文件指针读写的位置</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$file</span> = <span class="string">"./code.php"</span>;</span><br><span class="line"><span class="variable">$file</span> = fopen(<span class="variable">$file</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="built_in">echo</span> ftell(<span class="variable">$file</span>);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="COOKIE-及-SESSION"><a href="#COOKIE-及-SESSION" class="headerlink" title=" COOKIE 及 SESSION"></a> COOKIE 及 SESSION</h2> <figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">///COOKIE 及 SESSION//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * COOKIE</span></span><br><span class="line"><span class="comment"> * 一种存储在客户端的数据,能存储cookie的客户端不只是浏览器,但绝大多数都是由浏览器来实现的</span></span><br><span class="line"><span class="comment"> * 浏览器通过HTTP协议和服务端进行Cookie交互</span></span><br><span class="line"><span class="comment"> * 在实现过程中,编程语言是通过指令通知浏览器,然后是浏览器实现设置Cookie的功能的</span></span><br><span class="line"><span class="comment"> * 读取cookie则是通过浏览器请求服务端时携带的HTTP头部中的Cookie信息得来的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置cookie</span></span><br><span class="line"><span class="comment"> * setcookie()</span></span><br><span class="line"><span class="comment"> * 第一个参数name是必选参数,表示cookie名称</span></span><br><span class="line"><span class="comment"> * 第二个参数可选,value表示值</span></span><br><span class="line"><span class="comment"> * 第三个参数可选,expire表示cookie的有效时间,以秒为单位,不设置此值,浏览器关闭,cookie随之失效</span></span><br><span class="line"><span class="comment"> * 第四个参数可选,path,设置有效目录,设置为'/'表示当前目录下均可用,设置为'/aa'表示只有aa目录下可用</span></span><br><span class="line"><span class="comment"> * 第五个参数可选,domain,设置cookie的作用域名,默认在本域名下有效,比如设置为example.com表示在example域名下的所有子域名都有效</span></span><br><span class="line"><span class="comment"> * 第六个参数可选,secure,用来设置是否对Cookie进行加密传输,默认false,如果设置为true,则只有使用https时候才会设置Cookie</span></span><br><span class="line"><span class="comment"> * 第七个参数为true表示只能通过HTTP协议才能访问Cookie,意味着客户端javascipt不可以操作这个cookie,使用此参数可减少xss攻击的风险</span></span><br><span class="line"><span class="comment"> * 注:php和javascript都可以设置cookie,不同的是,php设置的cookie需要刷新页面后的下一次请求中才有效,而javascript设置的cookie在本次请求中就有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cookie经常用来存储一些不敏感的信息,如用来防止刷票,记录用户名,限制重复提交等</span></span><br><span class="line"><span class="comment"> * 示例:限制重复提交</span></span><br><span class="line"><span class="comment"> * 原理:当用户第一次提交表单时,设置cookie有效时间1分钟,当再次提交时,判断cookie是否过期来限制用户的提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Session设置</span></span><br><span class="line"><span class="comment"> * $_SESSION[key] = value</span></span><br><span class="line"><span class="comment"> * Session存储在服务器,本质上和Cookie没有区别,都是针对HTTP协议的局限性而提出的一种保持客户端和服务端间会话状态的机制.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="regexp">//开启session会话</span></span><br><span class="line"><span class="regexp">/*</span></span><br><span class="line"><span class="regexp">session_start();</span></span><br><span class="line"><span class="regexp">//</span>设置session</span><br><span class="line">$_SESSION[<span class="string">'name'</span>] = <span class="string">'xiaobudiu'</span>;</span><br><span class="line">session_id();</span><br><span class="line">var_dump($_SESSION);</span><br><span class="line">echo <span class="string">"&lt;hr&gt;"</span>;</span><br><span class="line">var_dump($_COOKIE);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"><span class="regexp">//var_dump(get_loaded_extensions());</span></span><br><span class="line"><span class="regexp">/**</span></span><br><span class="line"><span class="regexp"> * 使用Redis存储Session</span></span><br><span class="line"><span class="regexp"> * 对于大访问量的网站来说,会有许多客户端和服务端建立连接,就会生成许多session文件,由于session文件是存储在硬盘上的,因此每次</span></span><br><span class="line"><span class="regexp"> * 服务器去读取这些session文件都要经过许多I/O操作.</span></span><br><span class="line"><span class="regexp"> * PHP可以使用session_set_save_handle()函数自定义session保存函数(如打开,关闭,写入,读取等),如果想使用php内置的会话机制之外的方式,</span></span><br><span class="line"><span class="regexp"> * 可以使用本函数.例如,可以自定义会话存储函数来将会话数据存储到数据库.函数参数说明如下:</span></span><br><span class="line"><span class="regexp"> *</span></span><br><span class="line"><span class="regexp"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Mysql数据库的使用"><a href="#Mysql数据库的使用" class="headerlink" title="Mysql数据库的使用"></a>Mysql数据库的使用</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">///////////////////////Mysql数据库的使用//////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 关系型数据库,数据以表格的形式出现</span><br><span class="line"> * 每行为各种记录名称</span><br><span class="line"> * 每列为记录名称所对应的数据域,许多的行和列构成一张数据表,许多的表构成一个数据库</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * MYSQLi连接操作数据库</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * Mysqli执行插入数据操作</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$db</span> = new mysqli(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>,<span class="string">'test'</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"insert into `user` (`username`,`email`) VALUES (?,?)"</span>;</span><br><span class="line">//定义参数</span><br><span class="line"><span class="variable">$username</span> = <span class="string">"xiaobudiu"</span>;</span><br><span class="line"><span class="variable">$email</span> = <span class="string">"xiaobudiu163@126.com"</span>;</span><br><span class="line">//预处理</span><br><span class="line"><span class="variable">$sm</span> = <span class="variable">$db-</span>&gt;prepare(<span class="variable">$sql</span>);</span><br><span class="line">//绑定参数</span><br><span class="line"><span class="variable">$sm-</span>&gt;bind_param(<span class="string">'ss'</span>,<span class="variable">$username</span>,<span class="variable">$email</span>);</span><br><span class="line">//执行语句</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$sm-</span>&gt;execute())&#123;</span><br><span class="line">    echo <span class="string">"Insert Successfully"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$db-</span>&gt;close();</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *MYSQLi查询数据</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$db</span> = new mysqli(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'root'</span>,<span class="string">'test'</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"select * from user where uid&lt;4"</span>;</span><br><span class="line"><span class="variable">$re</span> = <span class="variable">$db-</span>&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">echo <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">while(<span class="variable">$arr</span> = <span class="variable">$re-</span>&gt;fetch_assoc())&#123;</span><br><span class="line">    var_dump(<span class="variable">$arr</span>);</span><br><span class="line">&#125;</span><br><span class="line">//释放查询结果</span><br><span class="line"><span class="variable">$re-</span>&gt;free();</span><br><span class="line">//断开数据库连接</span><br><span class="line"><span class="variable">$db-</span>&gt;close();</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line"> <span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">"uid"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">  [<span class="string">"username"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">4</span>) <span class="string">"kate"</span></span><br><span class="line">  [<span class="string">"email"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">12</span>) <span class="string">"kate@126.com"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">"uid"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">1</span>) <span class="string">"2"</span></span><br><span class="line">  [<span class="string">"username"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">5</span>) <span class="string">"admin"</span></span><br><span class="line">  [<span class="string">"email"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">12</span>) <span class="string">"admin@qq.com"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">"uid"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">1</span>) <span class="string">"3"</span></span><br><span class="line">  [<span class="string">"username"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">4</span>) <span class="string">"mary"</span></span><br><span class="line">  [<span class="string">"email"</span>]=&gt;</span><br><span class="line"> <span class="built_in"> string</span>(<span class="number">14</span>) <span class="string">"mary@itcast.cn"</span></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * pdo连接操作mysql数据库</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$dsn</span> = <span class="string">'mysql:dbname=test;host=127.0.0.1'</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pass</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="variable">$pdo</span> = new PDO(<span class="variable">$dsn</span>,<span class="variable">$user</span>,<span class="variable">$pass</span>);</span><br><span class="line">//    var_dump(<span class="variable">$pdo</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(PDOException <span class="variable">$e</span>)&#123;</span><br><span class="line">    echo <span class="string">"Connection failed:"</span>.<span class="variable">$e-</span>&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">//向数据表中插入数据</span><br><span class="line"><span class="variable">$dsn</span>=<span class="string">'mysql:dbname=test;host=127.0.0.1'</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pass</span> = <span class="string">'root'</span>;</span><br><span class="line">//实例化pdo对象,连接数据库</span><br><span class="line"><span class="variable">$pdo</span> = new PDO(<span class="variable">$dsn</span>,<span class="variable">$user</span>,<span class="variable">$pass</span>);</span><br><span class="line">//向数据库插入数据</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"insert into user (`username`,`email`) VALUES ('xiaowangba','sandjdsa@163.com')"</span>;</span><br><span class="line"><span class="variable">$re</span> = <span class="variable">$pdo-</span>&gt;exec(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$re</span>) &#123;</span><br><span class="line">    echo <span class="string">"向数据库插入数据成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var_dump(<span class="variable">$pdo-</span>&gt;errorInfo());</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 修改数据表数据</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$dsn</span>=<span class="string">'mysql:dbname=test;host=localhost'</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pass</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pdo</span> = new PDO(<span class="variable">$dsn</span>,<span class="variable">$user</span>,<span class="variable">$pass</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"update user set username='wangxiaoping' where uid=8"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$pdo-</span>&gt;exec(<span class="variable">$sql</span>)) &#123;</span><br><span class="line">    echo <span class="string">"修改数据成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    echo <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">    var_dump(<span class="variable">$pdo-</span>&gt;errorInfo());</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 删除数据表中的数据</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$dsn</span>=<span class="string">'mysql:dbname=test;host=127.0.0.1'</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pass</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pdo</span> = new PDO(<span class="variable">$dsn</span>,<span class="variable">$user</span>,<span class="variable">$pass</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"delete from user where uid=7"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$pdo-</span>&gt;exec(<span class="variable">$sql</span>)) &#123;</span><br><span class="line">    echo <span class="string">"删除数据成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    var_dump(<span class="variable">$pdo-</span>&gt;errorInfo());</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 查询数据表</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"><span class="variable">$dsn</span>=<span class="string">'mysql:dbname=test;host=localhost'</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pass</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="variable">$pdo</span> = new PDO(<span class="variable">$dsn</span>,<span class="variable">$user</span>,<span class="variable">$pass</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"select `username`,`email` from user where `uid` BETWEEN 2 AND 8"</span>;</span><br><span class="line">//预处理</span><br><span class="line"><span class="variable">$re</span> = <span class="variable">$pdo-</span>&gt;prepare(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$re-</span>&gt;execute();</span><br><span class="line"><span class="variable">$arrs</span> = <span class="variable">$re-</span>&gt;fetchAll();</span><br><span class="line">echo <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">var_dump(<span class="variable">$arrs</span>);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="PHP-与-Redis"><a href="#PHP-与-Redis" class="headerlink" title="PHP 与 Redis"></a>PHP 与 Redis</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//PHP 与 Redis//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>/</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关系型数据库能满足编程中一般的存储查询需求,随着网站业务量的增加,我们还需要存储许多数据,并且要求能够很快的将数据查询出来,这时,关系型数据库mysql</span></span><br><span class="line"><span class="comment"> * 就会稍显吃力.</span></span><br><span class="line"><span class="comment"> * 当网站用户并发性非常高(高并发读写往往达到每秒上万次请求)时,对于传统关系型数据库来说,硬盘I/O是一个很大的瓶颈,因为mysql的数据存储是写入磁盘上的.</span></span><br><span class="line"><span class="comment"> * 同时,网站每天产生的数据量是巨大的,对于关系型数据库来说,在一张包含海量数据表中查询效率也是非常低的</span></span><br><span class="line"><span class="comment"> * 针对关系型数据库的不足,出现了很多NOSQL产品,这些数据库中很大一部分都是针对某些特定应用需求出现的,对于该类应用具有极高性能,依据结构化方法以及应用</span></span><br><span class="line"><span class="comment"> * 场合不同,主要分为以下几类:</span></span><br><span class="line"><span class="comment"> * 面向高性能并发读写的key-value数据库,主要特点是具有极高的并发读写性能.Redis,TokyoCabinet,Flare是这类数据库的代表</span></span><br><span class="line"><span class="comment"> * 面向海量数据访问的面向文档数据库,这类数据库的特点是可以在海量的数据中快速查询数据,典型代表为MongoDB和CouchDB</span></span><br><span class="line"><span class="comment"> * 面向可扩展性的分布式数据库,相对于传统数据库存在的可扩展性缺陷,这类数据库可以适应数据量的增加以及数据结构的变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis是一个高级开源的key-value数据库存储系统.支持string,list,set,zset,hash 5种数据存储类型,支持对数据的多种操作,能够满足绝大部分业务需求.</span></span><br><span class="line"><span class="comment"> * Redis中的数据都是缓存在内存中的,比读取存储在硬盘上的数据速度要快很多.</span></span><br><span class="line"><span class="comment"> * Redis支持数据的持久化操作,可通过配置,周期性的将内存中的数据写入磁盘,提高了数据的安全性</span></span><br><span class="line"><span class="comment"> * Redis还支持主从同步,更好的解决了高并发的问题</span></span><br><span class="line"><span class="comment"> * Redis支持在Linux,Windows,MacOS系统中运行,但在实际应用场景中,推荐使用Linux系统.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Linux系统使用Redis</span></span><br><span class="line"><span class="comment"> * http://redis.io/   下载Redis安装包</span></span><br><span class="line"><span class="comment"> * Redis采用"主版本号,次版本号,补丁版本号"的命名规则.次版本号的位置,偶数表示稳定版本,如1.2  2.0 ，奇数表示测试版本,如2.9代表测试版本,n那么3.0将会是2.9.x的稳定版本</span></span><br><span class="line"><span class="comment"> *这里建议lnamp或者lnmp一键安装包</span></span><br><span class="line"><span class="comment"> * lnamp默认网站根目录 /data/wwwroot/default/index.php</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">///////////////////////////XML///////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 使用字符串生成xml</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">header(<span class="string">'Content-type:text/xml'</span>);</span><br><span class="line"><span class="variable">$xmlstr</span>=&lt;&lt;&lt;XML</span><br><span class="line">&lt;?xml version=<span class="string">'1.0'</span> standalone=<span class="string">'yes'</span>?&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">movies</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">movie</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>shanpaojincheng<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">content</span>&gt;</span>Two shan pao jin cheng<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">plot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>演的不错<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">plot</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">movies</span>&gt;</span></span></span><br><span class="line">XML;</span><br><span class="line">echo <span class="variable">$xmlstr</span>;</span><br><span class="line">//注: &lt;&lt;&lt;xml 作用:将<span class="string">"&lt;&lt;&lt;xml"</span>和最后的<span class="string">"xml"</span>之间的内容转换成字符串;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">movies</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">movie</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>shanpaojincheng<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">content</span>&gt;</span>Two shan pao jin cheng<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">plot</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>演的不错<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">plot</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">movies</span>&gt;</span></span></span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 使用数组循环遍历生成xml</span><br><span class="line"> * 与使用字符串生成xml相比,数组生成xml则不用写那么多&lt;&gt;标签,轻松很多</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">header(<span class="string">'Content-type:text/xml'</span>);</span><br><span class="line">echo <span class="string">'&lt;?xml version="1.0" ?&gt;'</span>.<span class="string">"\n"</span>;</span><br><span class="line">echo <span class="string">"&lt;books&gt;\n"</span>;</span><br><span class="line"><span class="variable">$books</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'bookname'</span>=&gt;<span class="string">'微信小程序开发实战与应用实例'</span>,</span><br><span class="line">        <span class="string">'press'</span>=&gt;<span class="string">'清华大学出版社'</span>,</span><br><span class="line">        <span class="string">'publishtime'</span>=&gt;<span class="string">'2016-07'</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'bookname'</span>=&gt;<span class="string">'一周微信公众号开发入门到精通'</span>,</span><br><span class="line">        <span class="string">'press'</span>=&gt;<span class="string">'延安出版社'</span>,</span><br><span class="line">        <span class="string">'publishtime'</span>=&gt;<span class="string">'2017-5'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">foreach(<span class="variable">$books</span> <span class="keyword">as</span> <span class="variable">$book</span>)&#123;</span><br><span class="line">    echo <span class="string">"    &lt;book&gt;\n"</span>;</span><br><span class="line">    foreach (<span class="variable">$book</span> <span class="keyword">as</span> <span class="variable">$tag</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line">        echo <span class="string">"    &lt;$tag&gt;"</span>.htmlspecialchars(<span class="variable">$value</span>).<span class="string">"&lt;/$tag&gt;\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    echo <span class="string">"    &lt;/book&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">"&lt;/books&gt;"</span>;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">bookname</span>&gt;</span>微信小程序开发实战与应用实例<span class="tag">&lt;/<span class="name">bookname</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">press</span>&gt;</span>清华大学出版社<span class="tag">&lt;/<span class="name">press</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">publishtime</span>&gt;</span>2016-07<span class="tag">&lt;/<span class="name">publishtime</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">bookname</span>&gt;</span>一周微信公众号开发入门到精通<span class="tag">&lt;/<span class="name">bookname</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">press</span>&gt;</span>延安出版社<span class="tag">&lt;/<span class="name">press</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">publishtime</span>&gt;</span>2017-5<span class="tag">&lt;/<span class="name">publishtime</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span></span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 通过PHP SimpleXML()解析xml,将字符串解析成对象,采用对象调用属性的方式获取值</span><br><span class="line"> * SimpleXML()是用来处理XML最便捷的方案</span><br><span class="line"> * 简化了与xml的交互,可以把元素转换成对象属性,位于标签之间的文本被指定给属性</span><br><span class="line"> * 如果同一个位置上有多个同名元素,n那么这些元素会被放在一个列表中.元素的属性会被转换成一个数组元素,其中</span><br><span class="line"> * 数组的键是属性名,键的值就是属性值</span><br><span class="line"> */</span><br><span class="line">//示例:</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$xmlstr</span>=&lt;&lt;&lt;XML</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> standalone=<span class="string">'yes'</span> ?&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">movies</span> <span class="attr">attr</span>=<span class="string">"qwe"</span> <span class="attr">ha</span>=<span class="string">"hahah属性值"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">movie</span> <span class="attr">a</span>=<span class="string">"shiyanshuxing"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">title</span> <span class="attr">tt</span>=<span class="string">"tt属性值"</span>&gt;</span>PHP从中阶进阶到大神<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">characters</span>&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">character</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">name</span> <span class="attr">age</span>=<span class="string">"22 years old"</span> <span class="attr">country</span>=<span class="string">"china"</span>&gt;</span>lixiaoming<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">acter</span>&gt;</span>onlivia actora<span class="tag">&lt;/<span class="name">acter</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">            </span><span class="xml"><span class="tag">&lt;<span class="name">character</span>&gt;</span></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Mr.coder<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">                </span><span class="xml"><span class="tag">&lt;<span class="name">acter</span>&gt;</span>xiaobudiu<span class="tag">&lt;/<span class="name">acter</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">character</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">characters</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">movie</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">movies</span>&gt;</span></span></span><br><span class="line">XML;</span><br><span class="line"><span class="variable">$xml</span> = simplexml_load_string(<span class="variable">$xmlstr</span>);</span><br><span class="line">var_dump(<span class="variable">$xml</span>);//将字符串变成xml对象</span><br><span class="line">echo <span class="variable">$xml-</span>&gt;movie-&gt;title;</span><br><span class="line">echo <span class="string">":"</span>;</span><br><span class="line">echo <span class="variable">$xml-</span>&gt;movie-&gt;characters-&gt;character[<span class="number">0</span>]-<span class="built_in">&gt;name</span>;</span><br><span class="line">//获取属性值</span><br><span class="line">echo <span class="variable">$xml-</span>&gt;movie-&gt;title[<span class="string">'tt'</span>]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">////////////////////////////////////////json的使用////////////////////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * json_encode() 将数组转换成json编码数据</span><br><span class="line"> * json_decode() 对json格式的字符串进行解码</span><br><span class="line"> * PHP作为一门服务端语言,常被用来写服务端接口逻辑,向客户端返回json格式的数据</span><br><span class="line"> * 与xml相比,在很多语言中,json数据的处理都比xml数据的处理简单得多,json数据和数组可以实现非常方便的转换</span><br><span class="line"> * 在包含同样信息的情况下,json数据字节数要比xml少很多</span><br><span class="line"> * json这种便捷性和简洁性使其可以取代xml成为互联网信息的规范数据格式</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * json_encode() 将数组转换成json编码数据</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"连续数组"</span>;</span><br><span class="line"><span class="variable">$a</span> = array(<span class="string">'foo'</span>,<span class="string">'zoo'</span>,<span class="string">'xiaoming'</span>,<span class="string">'xiaodong'</span>);</span><br><span class="line">var_dump(json_encode(<span class="variable">$a</span>));</span><br><span class="line">//连续数组string(35) <span class="string">"["</span>foo<span class="string">","</span>zoo<span class="string">","</span>xiaoming<span class="string">","</span>xiaodong<span class="string">"]"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"非连续数组"</span>;</span><br><span class="line"><span class="variable">$b</span> = array(</span><br><span class="line">    1=&gt;<span class="string">'foo'</span>,</span><br><span class="line">    2=&gt;<span class="string">'zoo'</span>,</span><br><span class="line">    3=&gt;<span class="string">'XIAOMING'</span>,</span><br><span class="line">    4=&gt;<span class="string">'XIAODONG'</span></span><br><span class="line">);</span><br><span class="line">var_dump(json_encode(<span class="variable">$b</span>));</span><br><span class="line">//非连续数组string(51) <span class="string">"&#123;"</span>1<span class="string">":"</span>foo<span class="string">","</span>2<span class="string">":"</span>zoo<span class="string">","</span>3<span class="string">":"</span>XIAOMING<span class="string">","</span>4<span class="string">":"</span>XIAODONG<span class="string">"&#125;"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"删除一个连续数组值的方式产生的非连续数组"</span>;</span><br><span class="line"><span class="built_in">unset</span>(<span class="variable">$a</span>[1]);</span><br><span class="line">var_dump(json_encode(<span class="variable">$a</span>));</span><br><span class="line">//删除一个连续数组值的方式产生的非连续数组string(41) <span class="string">"&#123;"</span>0<span class="string">":"</span>foo<span class="string">","</span>2<span class="string">":"</span>xiaoming<span class="string">","</span>3<span class="string">":"</span>xiaodong<span class="string">"&#125;"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"二维数组"</span>;</span><br><span class="line"><span class="variable">$arr</span> = array(</span><br><span class="line">    array(</span><br><span class="line">        <span class="string">'name'</span>=&gt;<span class="string">'xiaobudiu'</span>,</span><br><span class="line">        <span class="string">'age'</span>=&gt;25,</span><br><span class="line">        <span class="string">'sex'</span>=&gt;<span class="string">'man'</span></span><br><span class="line">    ),</span><br><span class="line">    array(</span><br><span class="line">        <span class="string">'name'</span>=&gt;<span class="string">'PGone'</span>,</span><br><span class="line">        <span class="string">'age'</span>=&gt;25,</span><br><span class="line">        <span class="string">'sex'</span>=&gt;<span class="string">'woman'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">var_dump(json_encode(<span class="variable">$arr</span>));</span><br><span class="line">//二维数组string(81) <span class="string">"[&#123;"</span>name<span class="string">":"</span>xiaobudiu<span class="string">","</span>age<span class="string">":25,"</span>sex<span class="string">":"</span>man<span class="string">"&#125;,&#123;"</span>name<span class="string">":"</span>PGone<span class="string">","</span>age<span class="string">":25,"</span>sex<span class="string">":"</span>woman<span class="string">"&#125;]"</span></span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * json_decode()</span><br><span class="line"> * 将json格式的字符串解码</span><br><span class="line"> * 第二个参数可选,选择为<span class="literal">true</span>表示 将json字符串解码成数组</span><br><span class="line"> * 第二个参数默认<span class="literal">false</span>,解码成对象object</span><br><span class="line"> */</span><br><span class="line">//<span class="variable">$json</span> = <span class="string">'&#123;"0":"foo","2":"xiaoming","3":"xiaodong"&#125;'</span>;</span><br><span class="line">//var_dump(json_decode(<span class="variable">$json</span>));</span><br><span class="line">/*</span><br><span class="line">object(stdClass)<span class="comment">#1 (3) &#123;</span></span><br><span class="line">[<span class="string">"0"</span>]=&gt;</span><br><span class="line">  string(3) <span class="string">"foo"</span></span><br><span class="line">[<span class="string">"2"</span>]=&gt;</span><br><span class="line">  string(8) <span class="string">"xiaoming"</span></span><br><span class="line">[<span class="string">"3"</span>]=&gt;</span><br><span class="line">  string(8) <span class="string">"xiaodong"</span></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">//var_dump(json_decode(<span class="variable">$json</span>,<span class="literal">true</span>));</span><br><span class="line">/*array(3) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(3) <span class="string">"foo"</span></span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(8) <span class="string">"xiaoming"</span></span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(8) <span class="string">"xiaodong"</span></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="mvc-amp-TP"><a href="#mvc-amp-TP" class="headerlink" title="mvc&amp;TP"></a>mvc&amp;TP</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mvc 一种软件设计典范,用业务逻辑/数据/界面显示分离 的方法组织代码,将业务逻辑聚集到一个页面里面,使得各部分的代码做各自的事情,</span></span><br><span class="line"><span class="comment"> * 各个人员编写的代码负责特定的功能,降低了耦合度</span></span><br><span class="line"><span class="comment"> * 由mvc架构系统的程序执行流程:</span></span><br><span class="line"><span class="comment"> * controller截获用户发出的请求,调用model完成状态的读写操作</span></span><br><span class="line"><span class="comment"> * controller把数据传给view,view渲染最终效果并呈现给用户.</span></span><br><span class="line"><span class="comment"> * 另外,php经常用来写一些接口程序,提供接口返回特定格式的数据(一般是json),不同的客户端(网页前端,桌面客户端,手机客户端等)可通过调用接口</span></span><br><span class="line"><span class="comment"> * 获得数据.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用的php开源框架</span></span><br><span class="line"><span class="comment"> * ThinkPHP tp是为了简化企业级应用开发和敏捷Web应用开发而诞生.</span></span><br><span class="line"><span class="comment"> * Yii 用于开发大型web应用.基于组件的高性能php框架通过一个简单的命令行工具yiic可以快速创建一个web应用程序的代码框架.</span></span><br><span class="line"><span class="comment"> * CI 组件的导入和函数的执行只有在被要求执行的时候才执行,而不是在全局范围,因此默认的系统非常轻量级,为了达到最大的用途,每个类和它的功能都是高度自治的.</span></span><br><span class="line"><span class="comment"> * Laravel 一套简洁,优雅的php web开发框架</span></span><br><span class="line"><span class="comment"> * Yaf (yet another framework) 提供了bootstrap,路由,分发,视图,插件 ,是一个全功能的php框架</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tp5支持使用composer安装</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">////////////////////设计模式/////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 分为3大类:创建型模式,结构型模式,行为型模式,还有一种J2EE设计模式,共23种设计模式(设计模式-可复用的面向对象软件元素)</span><br><span class="line"> * 工厂模式以及单例模式属于创建型模式.</span><br><span class="line"> * 创建型模式的描述:这些设计模式提供了一种在创建对象的同时,隐藏创建逻辑的方式,而不是使用新的运算符直接实例化对象.</span><br><span class="line"> * 这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * 工厂模式</span><br><span class="line"> * 工厂模式属于创建型模式,提供了一种创建对象的方式.</span><br><span class="line"> * 工厂模式是先定义一个创建对象的接口,让其子类自己决定实例化哪一个工厂类.</span><br><span class="line"> * 工厂模式的精髓就是可以根据不同的参数生成不同的类实例</span><br><span class="line"> */</span><br><span class="line">//示例:加减乘除工厂类实例</span><br><span class="line">//定义接口</span><br><span class="line">/*</span><br><span class="line">interface Calc&#123;</span><br><span class="line">    public <span class="keyword">function</span> getValue(<span class="variable">$num1</span>,<span class="variable">$num2</span>);</span><br><span class="line">&#125;</span><br><span class="line">//创建实现接口的实体类</span><br><span class="line">class Add implements Calc &#123;</span><br><span class="line">    public <span class="keyword">function</span> getValue(<span class="variable">$num1</span>, <span class="variable">$num2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">return</span> <span class="variable">$num1</span>+<span class="variable">$num2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub implements Calc &#123;</span><br><span class="line">    public <span class="keyword">function</span> getValue(<span class="variable">$num1</span>, <span class="variable">$num2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$num1</span>-<span class="variable">$num2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Mul implements Calc &#123;</span><br><span class="line">    public <span class="keyword">function</span> getValue(<span class="variable">$num1</span>, <span class="variable">$num2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$num1</span>*<span class="variable">$num2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Div implements Calc &#123;</span><br><span class="line">    public <span class="keyword">function</span> getValue(<span class="variable">$num1</span>, <span class="variable">$num2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="variable">$num2</span>==0)&#123;</span><br><span class="line">               throw new Exception(<span class="string">'除数不能为0'</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="built_in">return</span> <span class="variable">$num1</span>/<span class="variable">$num2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;catch (Exception <span class="variable">$e</span>)&#123;</span><br><span class="line">           <span class="built_in">echo</span> <span class="string">"错误信息:"</span>.<span class="variable">$e</span>-&gt;getMessage();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建一个工厂,生成基于给定信息的实体类的对象</span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static <span class="keyword">function</span> creatObj(<span class="variable">$operate</span>)&#123;</span><br><span class="line">        switch (<span class="variable">$operate</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="built_in">return</span> new Add();</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="built_in">return</span> new Sub();</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="built_in">return</span> new Mul();</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="built_in">return</span> new Div();</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$test</span>=Factory::creatObj(<span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$test</span>-&gt;getValue(1,4);</span><br><span class="line">//注:其实想实现本功能,定义一个类,一个公共方法,方法里采用switch也可以实现本功能,但为了代码的可读性以及代码的执行效率,所以采用工厂类;</span><br><span class="line">//注;这样,我们就实现了根据用户输入的操作符实例化相应的对象,进而完成接下来相应的操作.在软件开发中,php可能要链接mysql,也可能链接sqlserver.</span><br><span class="line">//或者其他数据库,这样我们就可以定义一个工厂类,动态生成不同的数据库连接对象;</span><br><span class="line">//再比如设计一个连接服务器的框架,需要三个协议,即pop3,imap,http,可以把这三个作为产品类,共同实现一个接口.工厂模式使用场景很多,需要在实</span><br><span class="line">//际开发中尝试1应用</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 单例模式</span><br><span class="line"> * 单例模式涉及一个单一的类,该类负责创建自己的对象,同时确保只有单个对象被创建</span><br><span class="line"> * 单例模式主要解决一个全局使用的类被频繁创建与销毁的问题</span><br><span class="line"> * 由于只创建了一个类的实例,因此减少了内存的开销,节省了系统资源</span><br><span class="line"> * php中,单例模式经常被用在数据库应用中.</span><br><span class="line"> */</span><br><span class="line">//代码示例:</span><br><span class="line">/*</span><br><span class="line">class Student&#123;</span><br><span class="line">    //私有的静态属性, 作用是为了存储对象的.</span><br><span class="line">    private static <span class="variable">$_instance</span>=null;</span><br><span class="line">    //私有的构造方法,保证不允许在类外 new</span><br><span class="line">    private <span class="keyword">function</span> <span class="function"><span class="title">__construct</span></span>()&#123;&#125;</span><br><span class="line">    //私有的克隆方法, 保证不允许在类外 通过 <span class="built_in">clone</span> 来创建新对象</span><br><span class="line">    private <span class="keyword">function</span> <span class="function"><span class="title">__clone</span></span>()&#123;&#125;</span><br><span class="line">    //公有的静态方法, 作用,就是用来实例化对象</span><br><span class="line">    public static <span class="keyword">function</span> <span class="function"><span class="title">getIntance</span></span>()&#123;</span><br><span class="line">        //将创建的新对象存储到静态属性中</span><br><span class="line">        //判断静态属性中是否为空</span><br><span class="line">        <span class="keyword">if</span>(is_null(self::<span class="variable">$_instance</span>))&#123;</span><br><span class="line">            //如果为空,则创建新对象,并将新存储赋给静态属性<span class="variable">$instance</span></span><br><span class="line">            self::<span class="variable">$_instance</span> = new self;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果<span class="variable">$instance</span>不为空,则直接将对象返回</span><br><span class="line">        <span class="built_in">return</span> self::<span class="variable">$_instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用静态方法来创建对象</span><br><span class="line"><span class="variable">$obj</span> = Student::getIntance();</span><br><span class="line"><span class="variable">$obj2</span> = Student::getIntance();//此行不再创建新对象</span><br><span class="line">//var_dump(<span class="variable">$obj</span>);</span><br><span class="line">//var_dump(<span class="variable">$obj2</span>);</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 观察者模式</span><br><span class="line"> * 一种事件系统.有两个类,a类和b类,a类允许b类观察,获取a类的状态,当a类状态发生改变的时候,b类可以收到通知,并作出相应的动作</span><br><span class="line"> * 观察者模式提供了避免组件之间紧密耦合的另一种方法</span><br><span class="line"> * 比如要实现用户注册后发送邮件通知管理员和用户自己填写的邮箱的功能,我们可以将发送邮件给管理员和用户自己都写在这个实现用户注册</span><br><span class="line"> * 的类里(使用观察者实现),这样,即使在以后更改了用户注册逻辑也不会影响到发送邮件的功能实现</span><br><span class="line"> * 再比如当用户下单购买一件商品时,我们需要将购买记录写入文本日志,数据库日志,还要发送短信,送抵兑换券积分等,我们可以在主体类中实</span><br><span class="line"> * 现下单购买的流程并定义一个观察者接口,当用户下单后通知各个观察者对象执行自己的业务逻辑.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//示例1</span><br><span class="line">//观察者模式设计两个类</span><br><span class="line">//男人类和女人类</span><br><span class="line">//男人类对象 xiaoming 女人类对象 xiaohua mother</span><br><span class="line">/*</span><br><span class="line">class man&#123;</span><br><span class="line">    //定义数组属性,用于存放观察者对象</span><br><span class="line">    protected <span class="variable">$observers</span>=[];</span><br><span class="line">    //将传进来的观察者对象存入观察者数组中的方法</span><br><span class="line">    <span class="keyword">function</span> addObserver(<span class="variable">$observer</span>)&#123;</span><br><span class="line">        <span class="variable">$this</span>-&gt;observers[]=<span class="variable">$observer</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除观察者的方法</span><br><span class="line">    <span class="keyword">function</span> delObserver(<span class="variable">$observer</span>)&#123;</span><br><span class="line">        //查找观察者在数组中的键值</span><br><span class="line">        <span class="variable">$key</span>=array_search(<span class="variable">$observer</span>,<span class="variable">$this</span>-&gt;observers);</span><br><span class="line">        //根据键值删除对应观察者</span><br><span class="line">        <span class="built_in">unset</span>(<span class="variable">$this</span>-&gt;observers[<span class="variable">$key</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    //男人buy()方法</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">buy</span></span>()&#123;</span><br><span class="line">        foreach (<span class="variable">$this</span>-&gt;observers as <span class="variable">$girl</span>)&#123;</span><br><span class="line">            //当被观察者作出buy()这个行为时,让观察者得到通知,并作出相应的反应</span><br><span class="line">            <span class="variable">$girl</span>-&gt;dongjie();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class woman&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">dongjie</span></span>()&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"你的儿子或者男朋友正在花钱&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建被观察着对象</span><br><span class="line"><span class="variable">$xiaoming</span> = new man();</span><br><span class="line">//创建观察者对象</span><br><span class="line"><span class="variable">$xiaohua</span> = new woman();</span><br><span class="line"><span class="variable">$mother</span> = new woman();</span><br><span class="line">//为xiaoming添加观察者</span><br><span class="line"><span class="variable">$xiaoming</span>-&gt;addObserver(<span class="variable">$mother</span>);</span><br><span class="line"><span class="variable">$xiaoming</span>-&gt;addObserver(<span class="variable">$xiaohua</span>);</span><br><span class="line">//<span class="variable">$xiaoming</span>-&gt;delObserver(<span class="variable">$xiaohua</span>);</span><br><span class="line">//xiaomign执行buy()之后,看观察者xiaohua和mother是否能得到通知,并作出相应反应</span><br><span class="line"><span class="variable">$xiaoming</span>-&gt;buy();</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">//示例2:</span><br><span class="line">/**</span><br><span class="line"> * 场景描述：</span><br><span class="line"> * 哈票以购票为核心业务(此模式不限于该业务)，但围绕购票会产生不同的其他逻辑，如：</span><br><span class="line"> * 1、购票后记录文本日志</span><br><span class="line"> * 2、购票后记录数据库日志</span><br><span class="line"> * 3、购票后发送短信</span><br><span class="line"> * 4、购票送抵扣卷、兑换卷、积分</span><br><span class="line"> * 5、其他各类活动等</span><br><span class="line"> *</span><br><span class="line"> * 传统解决方案:</span><br><span class="line"> * 在购票逻辑等类内部增加相关代码，完成各种逻辑。</span><br><span class="line"> *</span><br><span class="line"> * 存在问题：</span><br><span class="line"> * 1、一旦某个业务逻辑发生改变，如购票业务中增加其他业务逻辑，需要修改购票核心文件、甚至购票流程。</span><br><span class="line"> * 2、日积月累后，文件冗长，导致后续维护困难。</span><br><span class="line"> *</span><br><span class="line"> * 存在问题原因主要是程序的<span class="string">"紧密耦合"</span>，使用观察者模式将目前的业务逻辑优化成<span class="string">"松耦合"</span>，达到易维护、易修改的目的，</span><br><span class="line"> * 同时也符合面向接口编程的思想。</span><br><span class="line"> *</span><br><span class="line"> * 观察者模式典型实现方式：</span><br><span class="line"> * 1、定义2个接口：观察者（通知）接口、被观察者（主题）接口</span><br><span class="line"> * 2、定义2个类，观察者对象实现观察者接口、主题类实现被观者接口</span><br><span class="line"> * 3、主题类注册自己需要通知的观察者</span><br><span class="line"> * 4、主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="comment">#===================定义观察者、被观察者接口============</span></span><br><span class="line">/*</span><br><span class="line">//观察者接口(通知接口)</span><br><span class="line">interface guancha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">function</span> onBuyTicketOver(<span class="variable">$sender</span>, <span class="variable">$args</span>); //得到通知后调用的方法</span><br><span class="line">&#125;</span><br><span class="line">//被观察者接口(主题接口)</span><br><span class="line">interface beiguancha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">function</span> addObserver(<span class="variable">$observer</span>); //提供添加观察者的方法</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////主题类实现///////////////////</span><br><span class="line">//主题类（购票）</span><br><span class="line">class buyPiao implements beiguancha &#123; //实现主题接口（被观察者）</span><br><span class="line">    private <span class="variable">$_observers</span> = []; //数组存放观察者对象</span><br><span class="line">    public <span class="keyword">function</span> buyTicket(<span class="variable">$ticket</span>) //购票核心类，处理购票流程</span><br><span class="line">    &#123;</span><br><span class="line">        //购票逻辑</span><br><span class="line">        //循环通知，调用其onBuyTicketOver实现不同业务逻辑</span><br><span class="line">        foreach ( <span class="variable">$this</span>-&gt;_observers as <span class="variable">$obs</span> )</span><br><span class="line">            <span class="variable">$obs</span>-&gt;onBuyTicketOver ( <span class="variable">$this</span>, <span class="variable">$ticket</span> ); //<span class="variable">$this</span> 可用来获取主题类句柄，在通知中使用</span><br><span class="line">    &#125;</span><br><span class="line">    //添加通知</span><br><span class="line">    public <span class="keyword">function</span> addObserver(<span class="variable">$observer</span>) //添加N个通知</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$this</span>-&gt;_observers [] = <span class="variable">$observer</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////////////////定义多个通知/////////////////////////</span><br><span class="line">//短信日志通知</span><br><span class="line">class HipiaoMSM implements guancha &#123;</span><br><span class="line">    public <span class="keyword">function</span> onBuyTicketOver(<span class="variable">$sender</span>, <span class="variable">$ticket</span>) &#123;</span><br><span class="line">        <span class="built_in">echo</span> (date ( <span class="string">'Y-m-d H:i:s'</span> ) . <span class="string">" 短信日志记录：购票成功:<span class="variable">$ticket</span>&lt;br&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//文本日志通知</span><br><span class="line">class HipiaoTxt implements guancha &#123;</span><br><span class="line">    public <span class="keyword">function</span> onBuyTicketOver(<span class="variable">$sender</span>, <span class="variable">$ticket</span>) &#123;</span><br><span class="line">        <span class="built_in">echo</span> (date ( <span class="string">'Y-m-d H:i:s'</span> ) . <span class="string">" 文本日志记录：购票成功:<span class="variable">$ticket</span>&lt;br&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抵扣卷赠送通知</span><br><span class="line">class HipiaoDiKou implements guancha &#123;</span><br><span class="line">    public <span class="keyword">function</span> onBuyTicketOver(<span class="variable">$sender</span>, <span class="variable">$ticket</span>) &#123;</span><br><span class="line">        <span class="built_in">echo</span> (date ( <span class="string">'Y-m-d H:i:s'</span> ) . <span class="string">" 赠送抵扣卷：购票成功:<span class="variable">$ticket</span> 赠送10元抵扣卷1张。&lt;br&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////////用户购票///////////////////////////</span><br><span class="line"><span class="variable">$buy</span> = new buyPiao ();</span><br><span class="line"><span class="variable">$buy</span>-&gt;addObserver ( new HipiaoMSM () ); //根据不同业务逻辑加入各种通知</span><br><span class="line"><span class="variable">$buy</span>-&gt;addObserver ( new HipiaoTxt () );</span><br><span class="line"><span class="variable">$buy</span>-&gt;addObserver ( new HipiaoDiKou () );</span><br><span class="line">//购票</span><br><span class="line"><span class="variable">$buy</span>-&gt;buyTicket ( <span class="string">"一排一号"</span> );</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 策略模式</span><br><span class="line"> * 与工厂模式实现的功能相似,区别是工厂模式关注的是对象的创建,提供创建对象的接口,是创建型的设计接口,接收指令,创建出符合要求的实例</span><br><span class="line"> * 策略模式是行为型的设计模式,接受已经创建好的实例,实现不同的行为</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">///////////////////////////////开始进入API的世界//////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 随着移动网络的发展,多终端的出现,为了降低服务端的工作量,和以后的维护量,我们希望开发一套可适用于多个终端的接口.</span><br><span class="line"> * 面向接口编程要求我们将定义和实现分开,尽可能编写粒度更细的接口,降低各个接口之间的依赖度,这些接口通过一定的组合能够对外提供一套系统服务</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="传输消息加解密"><a href="#传输消息加解密" class="headerlink" title="传输消息加解密"></a>传输消息加解密</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////传输消息加解密//////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 单向散列加密</span><br><span class="line"> * 常用的单向散列加密:MD5,SHA等</span><br><span class="line"> * 单向加密是对不同输入长度的信息进行散列计算,得到固定长度的散列计算值.输入信息的任何微小变化都会导致散列的很大不同,并且这种计算是不可逆的</span><br><span class="line"> * 即无法根据散列值获得明文信息.这种单向散列加密可用于用户密码的保存.即不将用户输入的密码直接保存到数据库,而是对密码进行单向散列加密.将密文</span><br><span class="line"> * 存入数据库,用户登陆时进行密码验证,同样对输入的密码进行散列加密,与数据库中密码的密文进行对比,若一致,则验证通过</span><br><span class="line"> * 虽然不能通过算法从散列密文解出明文,但是由于人们设置的密码具有一定的模式(比如使用生日或名字作为密码),因此通过彩虹表(密码和对应的密文关系表)</span><br><span class="line"> * 等手段都可以猜测式的1破解.为了增加单向散列被破解的难度,还可以给散列算法加盐值(salt),salt相当于加密时的钥匙,增加破解时的难度</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 对称加密</span><br><span class="line"> * 对称加密是指加密和解密使用的是同一个秘钥.对称加密类似接口签名验证,将明文和密钥按照一定的算法进行加密,同样使用密钥和一定的算法对密文进行解密</span><br><span class="line"> * 获得明文.</span><br><span class="line"> * PHP提供了一个MCRYPT扩展,可用于对称加密.</span><br><span class="line"> * 注:php7开始,已经对mcrypt加密方式进行删除,官方不推荐此方式了.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * mycrpt加密需要以下几个步骤:</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//示例1</span><br><span class="line">/*</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"我的名字是？一般人我不告诉他！"</span>; //加密内容</span><br><span class="line"><span class="variable">$key</span> = <span class="string">"key25111"</span>; //密钥</span><br><span class="line"><span class="variable">$cipher</span> = MCRYPT_DES; //密码类型</span><br><span class="line"><span class="variable">$modes</span> = MCRYPT_MODE_ECB; //密码模式</span><br><span class="line"><span class="variable">$iv</span> = mcrypt_create_iv(mcrypt_get_iv_size(<span class="variable">$cipher</span>,<span class="variable">$modes</span>),MCRYPT_RAND);//初始化向量</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"加密明文："</span>.<span class="variable">$str</span>.<span class="string">"&lt;p&gt;"</span>;</span><br><span class="line"><span class="variable">$str_encrypt</span> = mcrypt_encrypt(<span class="variable">$cipher</span>,<span class="variable">$key</span>,<span class="variable">$str</span>,<span class="variable">$modes</span>,<span class="variable">$iv</span>); //加密函数</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"加密密文："</span>.<span class="variable">$str_encrypt</span>.<span class="string">" &lt;p&gt;"</span>;</span><br><span class="line"><span class="variable">$str_decrypt</span> = mcrypt_decrypt(<span class="variable">$cipher</span>,<span class="variable">$key</span>,<span class="variable">$str_encrypt</span>,<span class="variable">$modes</span>,<span class="variable">$iv</span>); //解密函数</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"还原："</span>.<span class="variable">$str_decrypt</span>;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *非对称加密</span><br><span class="line"> * RSA是目前最有影响力的公钥加密算法</span><br><span class="line"> *与对称加密不同的是,非对称加密和解密使用的是不同的密钥,其中一个对外公开作为公钥,另一个只有私有者私有,成为私钥.用私钥加密的</span><br><span class="line"> *信息只有公钥能够解开,反之用公钥加密的信息只有私钥能够解开.</span><br><span class="line"> *常用的非对称加密有RSA算法</span><br><span class="line"> *RSA算法基于一个非常简单的数论事实,将两个大质数相乘十分容易,但是想要对其乘积进行因式分解却极其困难,因此可以将乘积公开作为加密密钥</span><br><span class="line"> *PHP中,提供基于RSA算法的openssl扩展可实现对数据的非对称加密</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="使用ajax进行交互"><a href="#使用ajax进行交互" class="headerlink" title="使用ajax进行交互"></a>使用ajax进行交互</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/////////////////////////////////////使用ajax进行交互/////////////////////////////////////</span><br><span class="line">/**</span><br><span class="line"> * 把网页看成客户端,服务端以提供接口的形式向客户端提供数据的增删改查服务.</span><br><span class="line"> * 在网页开发中,经常使用ajax技术实现客户端与服务端的数据交互</span><br><span class="line"> * ajax是一种在无须重新加载整个网页的情况下能够更新部分网页的技术.</span><br><span class="line"> * ajax通过在后台与服务器进行少量的数据交换可以使网页实现异步更新.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">//检测用户名是否可用</span><br><span class="line">//假设用户名为zhangsan和lisi已经被使用了</span><br><span class="line">/**</span><br><span class="line"> *html代码</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>检测用户名是否被使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"span"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--实现的功能是:当用户输入完用户名,失去焦点时,自动检测是否被使用了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">//获取input元素</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(<span class="string">'name'</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">//给其绑定失去焦点事件</span></span></span><br><span class="line"><span class="actionscript">input.onblur=<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//创建xhr对象</span></span></span><br><span class="line"><span class="actionscript">xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript"><span class="comment">//获取用户输入的用户名</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> name = <span class="keyword">this</span>.value;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//状态确认后才接收数据</span></span></span><br><span class="line"><span class="actionscript">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(xhr.responseText == <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'span'</span>).innerHTML = <span class="string">"&lt;font color='red'&gt;baoqian,您输入的用户名已经有人注册&lt;/font&gt;"</span></span></span><br><span class="line"><span class="actionscript">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'span'</span>).innerHTML = <span class="string">"&lt;font color='#7fffd4'&gt;gongxi,可以注册此用户名&lt;/font&gt;"</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//设置请求</span></span></span><br><span class="line"><span class="actionscript">xhr.open(<span class="string">'get'</span>,<span class="string">'index.php?name='</span>+name,<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">//发送请求</span></span></span><br><span class="line"><span class="undefined">xhr.send();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *php代码</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line">$name = $_GET['name'];</span><br><span class="line">if($name == 'zhangsan')&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo 2;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--------------------- </span><br><span class="line">作者：m_nanle_xiaobudiu </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/m_nanle_xiaobudiu/article/details/79251726 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>搬运</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】设计模式</title>
    <url>/2019/04/09/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。<br>策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。<br>策略模式的三个角色：<br>1．抽象策略角色<br>2．具体策略角色<br>3．环境角色（对抽象策略角色的引用）<br>实现步骤：<br>1．定义抽象角色类（定义好各个实现的共同抽象方法）<br>2．定义具体策略类（具体实现父类的共同方法）<br>3．定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）<br>就在编程领域之外，有许多例子是关于策略模式的。例如：<br>如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。<br><a id="more"></a><br>策略模式的代码实例：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">baseAgent</span> </span>&#123; <span class="comment">//抽象策略类</span></span></span><br><span class="line"><span class="php">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//用于客户端是IE时调用的类（环境角色）</span></span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">ieAgent</span> <span class="keyword">extends</span> <span class="title">baseAgent</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="string">'IE'</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">//用于客户端不是IE时调用的类（环境角色）</span></span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">otherAgent</span> <span class="keyword">extends</span> <span class="title">baseAgent</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="function"><span class="keyword">function</span> <span class="title">PrintPage</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="string">'not IE'</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">Browser</span> </span>&#123; <span class="comment">//具体策略角色</span></span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">call</span><span class="params">($object)</span> </span>&#123;</span></span><br><span class="line"><span class="php">                <span class="keyword">return</span> $object-&gt;PrintPage ();</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        $bro = <span class="keyword">new</span> Browser ();</span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> $bro-&gt;call ( <span class="keyword">new</span> ieAgent () );</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。<br>使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">header(<span class="string">'Content-Type:text/html;charset=utf-8'</span>);</span></span><br><span class="line">/**</span><br><span class="line"> *简单工厂模式（静态工厂方法模式）</span><br><span class="line"><span class="php"> */</span></span><br><span class="line">/**</span><br><span class="line"> * Interface people 人类</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">interface</span>  <span class="title">people</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">say</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line">/**</span><br><span class="line"> * Class man 继承people的男人类</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">man</span> <span class="keyword">implements</span> <span class="title">people</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="comment">// 具体实现people的say方法</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">'我是男人&lt;br&gt;'</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line">/**</span><br><span class="line"> * Class women 继承people的女人类</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">women</span> <span class="keyword">implements</span> <span class="title">people</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="comment">// 具体实现people的say方法</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">'我是女人&lt;br&gt;'</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line">/**</span><br><span class="line"> * Class SimpleFactoty 工厂类</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoty</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="comment">// 简单工厂里的静态方法-用于创建男人对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createMan</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">new</span> man();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="comment">// 简单工厂里的静态方法-用于创建女人对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createWomen</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">new</span> women();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line">/**</span><br><span class="line"> * 具体调用</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php">$man = SimpleFactoty::createMan();</span></span><br><span class="line"><span class="php">$man-&gt;say();</span></span><br><span class="line"><span class="php">$woman = SimpleFactoty::createWomen();</span></span><br><span class="line"><span class="php">$woman-&gt;say();</span></span><br></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
</code></pre><p>单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。<br>单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。<br>单例模式有以下3个特点：<br>1．只能有一个实例。<br>2．必须自行创建这个实例。<br>3．必须给其他对象提供这一实例。<br>那么为什么要使用PHP单例模式？<br>PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $name;<span class="comment">//声明一个私有的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;<span class="comment">//声明私有构造方法为了防止外部代码使用new来创建对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> $instance;<span class="comment">//声明一个静态变量（保存在类中唯一的一个实例）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getinstance</span><span class="params">()</span></span>&#123;<span class="comment">//声明一个getinstance()静态方法，用于检测是否有实例对象</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">self</span>::$instance) <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setname</span><span class="params">($n)</span></span>&#123; <span class="keyword">$this</span>-&gt;name = $n; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getname</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name; &#125;</span><br><span class="line">&#125;</span><br><span class="line">$oa = Single::getinstance();</span><br><span class="line">$ob = Single::getinstance();</span><br><span class="line">$oa-&gt;setname(<span class="string">'hello world'</span>);</span><br><span class="line">$ob-&gt;setname(<span class="string">'good morning'</span>);</span><br><span class="line"><span class="keyword">echo</span> $oa-&gt;getname();<span class="comment">//good morning</span></span><br><span class="line"><span class="keyword">echo</span> $ob-&gt;getname();<span class="comment">//good morning</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式-懒汉"><a href="#单例模式-懒汉" class="headerlink" title="单例模式-懒汉"></a>单例模式-懒汉</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//懒汉式单例模式</span></span><br><span class="line">    <span class="comment">//比较懒，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton intance = <span class="keyword">null</span>;<span class="comment">//静态私用成员，没有初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//私有构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span>    <span class="comment">//静态，同步，公开访问点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intance == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            intance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（类加载时不初始化）<br>1）构造函数定义为私有—-不能在别的类中来获取该类的对象，只能在类自身中得到自己的对象</p>
<p>2）成员变量为static的，没有初始化—-类加载快，但访问类的唯一实例慢，static保证在自身类中获取自身对象</p>
<p>3）公开访问点getInstance： public和synchronized的—–public保证对外公开，同步保证多线程时的正确性（因为类变量不是在加载时初始化的）</p>
<h2 id="单例模式-饿汉"><a href="#单例模式-饿汉" class="headerlink" title="单例模式-饿汉"></a>单例模式-饿汉</h2><p>（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//饿汉单例模式</span></span><br><span class="line">    <span class="comment">//在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();<span class="comment">//静态私有成员，已初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//私有构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span>    <span class="comment">//静态，不用同步（类加载时已初始化，不会有多线程的问题）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h2><p>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Register</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> <span class="keyword">static</span>  $objects;</span></span><br><span class="line"><span class="php">        <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($alias,$object)</span>//将对象注册到全局的树上</span></span></span><br><span class="line"><span class="php">        &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">self</span>::$objects[$alias]=$object;<span class="comment">//将对象放到树上</span></span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name)</span></span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">self</span>::$objects[$name];<span class="comment">//获取某个注册到树上的对象</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">_unset</span><span class="params">($alias)</span></span></span></span><br><span class="line"><span class="php">　　&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">unset</span>(<span class="keyword">self</span>::$objects[$alias]);<span class="comment">//移除某个注册到树上的对象。</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将各种截然不同的函数接口封装成统一的API。<br>PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。<br>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。</p>
<p>接口 IDatabase<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">interface</span> <span class="title">IDatabase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span>;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span>;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">MySQL</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> <span class="keyword">implements</span> <span class="title">IDatabase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> $conn;</span></span><br><span class="line"><span class="php">        <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span></span></span><br><span class="line"><span class="php">        &#123;</span></span><br><span class="line"><span class="php">            $conn = mysql_connect($host, $user, $passwd);</span></span><br><span class="line"><span class="php">            mysql_select_db($dbname, $conn);</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;conn = $conn;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span></span></span><br><span class="line"><span class="php">        &#123;</span></span><br><span class="line"><span class="php">            $res = mysql_query($sql, <span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> $res;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        mysql_close(<span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">MySQLi</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MySQLi</span> <span class="keyword">implements</span> <span class="title">IDatabase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> $conn;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $conn = mysqli_connect($host, $user, $passwd, $dbname);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;conn = $conn;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> mysqli_query(<span class="keyword">$this</span>-&gt;conn, $sql);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        mysqli_close(<span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。<br>2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。<br>3：观察者模式实现了低耦合，非侵入式的通知与更新机制。<br>定义一个事件触发抽象类。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">EventGenerator.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'Loader.php'</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventGenerator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $observers = <span class="keyword">array</span>();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">addObserver</span><span class="params">(Observer $observer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;observers[]=$observer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;observers <span class="keyword">as</span> $observer)&#123;</span><br><span class="line">            $observer-&gt;update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义一个观察者接口</span><br><span class="line"></span><br><span class="line">Observer.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="string">'Loader.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>;<span class="comment">//这里就是在事件发生后要执行的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span></span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'Loader.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> <span class="keyword">extends</span> <span class="title">EventGenerator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">triger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Event&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"逻辑1&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"逻辑2&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$event = <span class="keyword">new</span> Event();</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer1());</span><br><span class="line">$event-&gt;addObserver(<span class="keyword">new</span> Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【积累】linux基础操作</title>
    <url>/2019/04/08/inux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h2><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。<br>find . -name “*.c”<br><img src="\images\pasted-26.png" alt="upload successful"><br>将目前目录其其下子目录中所有一般文件列出<br>find . -type f</p>
<p>递归查找<br>find . -r -name “*.txt”</p>
<h2 id="grep操作"><a href="#grep操作" class="headerlink" title="grep操作"></a>grep操作</h2><p>grep查找字符（利用递归查找在后缀为md的文件中查找字符为1的文件）<br>grep -r 1 *.md</p>
<p>找出程序运行的端口<br>netstat -ap | grep ssh</p>
]]></content>
      <categories>
        <category>积累</category>
      </categories>
  </entry>
  <entry>
    <title>【搬运】mysql千行笔记</title>
    <url>/2019/03/30/ysql%E5%8D%83%E8%A1%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Windows服务</p>
<pre><code>-- 启动MySQL
   net start mysql
-- 创建Windows服务
   sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)
</code></pre><p>连接与断开服务器</p>
<pre><code>mysql -h 地址 -P 端口 -u 用户名 -p 密码

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 显示系统变量信息
</code></pre><p> 数据库操作</p>
<pre><code>-- 查看当前数据库
   SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
   SELECT now(), user(), version();
-- 创建库
   CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项
   数据库选项：
       CHARACTER SET charset_name
       COLLATE collation_name
-- 查看已有库
   SHOW DATABASES[ LIKE &apos;PATTERN&apos;]
-- 查看当前库信息
   SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
   ALTER DATABASE 库名 选项信息
-- 删除库
   DROP DATABASE[ IF EXISTS] 数据库名
       同时删除该数据库相关的目录及其目录内容
</code></pre><a id="more"></a>
<p>表的操作</p>
<pre><code>-- 创建表
   CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]
       每个字段必须有数据类型
       最后一个字段后不能有逗号
       TEMPORARY 临时表，会话结束时表自动消失
       对于字段的定义：
           字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;]
-- 表选项
   -- 字符集
       CHARSET = charset_name
       如果表没有设定，则使用数据库字符集
   -- 存储引擎
       ENGINE = engine_name
       表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
       常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
       不同的引擎在保存表的结构和数据时采用不同的方式
       MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
       InnoDB表文件含义：.frm表定义，表空间数据和日志文件
       SHOW ENGINES -- 显示存储引擎的状态信息
       SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
   -- 自增起始数
       AUTO_INCREMENT = 行数
   -- 数据文件目录
       DATA DIRECTORY = &apos;目录&apos;
   -- 索引文件目录
       INDEX DIRECTORY = &apos;目录&apos;
   -- 表注释
       COMMENT = &apos;string&apos;
   -- 分区选项
       PARTITION BY ... (详细见手册)
-- 查看所有表
   SHOW TABLES[ LIKE &apos;pattern&apos;]
   SHOW TABLES FROM 表名
-- 查看表机构
   SHOW CREATE TABLE 表名 （信息更详细）
   DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;]
   SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;]
-- 修改表
   -- 修改表本身的选项
       ALTER TABLE 表名 表的选项
       eg: ALTER TABLE 表名 ENGINE=MYISAM;
   -- 对表进行重命名
       RENAME TABLE 原表名 TO 新表名
       RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）
       -- RENAME可以交换两个表名
   -- 修改表的字段机构（13.1.2. ALTER TABLE语法）
       ALTER TABLE 表名 操作名
       -- 操作名
           ADD[ COLUMN] 字段定义       -- 增加字段
               AFTER 字段名          -- 表示增加在该字段名后面
               FIRST               -- 表示增加在第一个
           ADD PRIMARY KEY(字段名)   -- 创建主键
           ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
           ADD INDEX [索引名] (字段名) -- 创建普通索引
           DROP[ COLUMN] 字段名      -- 删除字段
           MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
           CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改
           DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
           DROP INDEX 索引名 -- 删除索引
           DROP FOREIGN KEY 外键    -- 删除外键
-- 删除表
   DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
   TRUNCATE [TABLE] 表名
-- 复制表结构
   CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
   CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
   CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
   OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
   REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
   ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre><p>数据操作</p>
<pre><code>-- 增
   INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
       -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
       -- 可同时插入多条数据记录！
       REPLACE 与 INSERT 完全一样，可互换。
   INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
   SELECT 字段列表 FROM 表名[ 其他子句]
       -- 可来自多个表的多个字段
       -- 其他子句可以不使用
       -- 字段列表可以用*代替，表示所有字段
-- 删
   DELETE FROM 表名[ 删除条件子句]
       没有条件子句，则会删除全部
-- 改
   UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]
</code></pre><p>字符集编码</p>
<pre><code>-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE &apos;character_set_%&apos;   -- 查看所有字符集编码项
   character_set_client        客户端向服务器发送数据时使用的编码
   character_set_results       服务器端将结果返回给客户端所使用的编码
   character_set_connection    连接层编码
SET 变量名 = 变量值
   SET character_set_client = gbk;
   SET character_set_results = gbk;
   SET character_set_connection = gbk;
SET NAMES GBK;  -- 相当于完成以上三个设置
-- 校对集
   校对集用以排序
   SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;]   查看所有字符集
   SHOW COLLATION [LIKE &apos;pattern&apos;]     查看所有校对集
   CHARSET 字符集编码     设置字符集编码
   COLLATE 校对集编码     设置校对集编码
</code></pre><p>数据类型（列类型）</p>
<pre><code>1. 数值类型

-- a. 整型 ----------
   类型         字节     范围（有符号位）
   tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255
   smallint    2字节    -32768 ~ 32767
   mediumint   3字节    -8388608 ~ 8388607
   int         4字节
   bigint      8字节
   int(M)  M表示总位数
   - 默认存在符号位，unsigned 属性修改
   - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
       例：int(5)   插入一个数&apos;123&apos;，补填后为&apos;00123&apos;
   - 在满足要求的情况下，越小越好。
   - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。

-- b. 浮点型 ----------
   类型             字节     范围
   float(单精度)     4字节
   double(双精度)    8字节
   浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
       不同于整型，前后均会补填0.
   定义浮点型时，需指定总位数和小数位数。
       float(M, D)     double(M, D)
       M表示总位数，D表示小数位数。
       M和D的大小会决定浮点数的范围。不同于整型的固定范围。
       M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
       支持科学计数法表示。
       浮点数表示近似值。

-- c. 定点数 ----------
   decimal -- 可变长度
   decimal(M, D)   M也表示总位数，D表示小数位数。
   保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
   将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型

-- a. char, varchar ----------
   char    定长字符串，速度快，但浪费空间
   varchar 变长字符串，速度慢，但节省空间
   M表示能存储的最大长度，此长度是字符数，非字节数。
   不同的编码，所占用的空间不同。
   char,最多255个字符，与编码无关。
   varchar,最多65535字符，与编码有关。
   一条有效记录最大不能超过65535个字节。
       utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
   varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
   varchar 的最大有效长度由最大行大小和使用的字符集确定。
   最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。
   例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
   blob 二进制字符串（字节字符串）
       tinyblob, blob, mediumblob, longblob
   text 非二进制字符串（字符字符串）
       tinytext, text, mediumtext, longtext
   text 在定义时，不需要定义长度，也不会计算总长度。
   text 类型在定义时，不可给default值

-- c. binary, varbinary ----------
   类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
   char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
   一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
   datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59
   date        3字节    日期         1000-01-01 到 9999-12-31
   timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
   time        3字节    时间         -838:59:59 到 838:59:59
   year        1字节    年份         1901 - 2155
datetime    YYYY-MM-DD hh:mm:ss
timestamp   YY-MM-DD hh:mm:ss
           YYYYMMDDhhmmss
           YYMMDDhhmmss
           YYYYMMDDhhmmss
           YYMMDDhhmmss
date        YYYY-MM-DD
           YY-MM-DD
           YYYYMMDD
           YYMMDD
           YYYYMMDD
           YYMMDD
time        hh:mm:ss
           hhmmss
           hhmmss
year        YYYY
           YY
           YYYY
           YY

4. 枚举和集合

-- 枚举(enum) ----------
enum(val1, val2, val3...)
   在已知的值中进行单选。最大数量为65535.
   枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
   表现为字符串类型，存储却是整型。
   NULL值的索引是NULL。
   空字符串错误值的索引值是0。


-- 集合（set） ----------
set(val1, val2, val3...)
   create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) );
   insert into tab values (&apos;男, 女&apos;);
   最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
   当创建表时，SET成员值的尾部空格将自动被删除。
</code></pre><p>选择类型</p>
<pre><code>-- PHP角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned
   1) PHP函数转换
       ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
       利用sprintf函数格式化字符串
       sprintf(&quot;%u&quot;, ip2long(&apos;192.168.3.134&apos;));
       然后用long2ip将整型转回IP字符串
   2) MySQL函数转换(无符号整型，UNSIGNED)
       INET_ATON(&apos;127.0.0.1&apos;) 将IP转为整型
       INET_NTOA(2130706433) 将整型转为IP
</code></pre><p>列属性（列约束）</p>
<pre><code>1. PRIMARY 主键
   - 能唯一标识记录的字段，可以作为主键。
   - 一个表只能有一个主键。
   - 主键具有唯一性。
   - 声明字段时，用 primary key 标识。
       也可以在字段列表之后声明
           例：create table tab ( id int, stu varchar(10), primary key (id));
   - 主键字段的值不能为null。
   - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
       例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));
2. UNIQUE 唯一索引（唯一约束）
   使得某字段的值也不能重复。
3. NULL 约束
   null不是数据类型，是列的一个属性。
   表示当前列是否可以为null，表示什么都没有。
   null, 允许为空。默认。
   not null, 不允许为空。
   insert into tab values (null, &apos;val&apos;);
       -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null
4. DEFAULT 默认值属性
   当前字段的默认值。
   insert into tab values (default, &apos;val&apos;);    -- 此时表示强制使用默认值。
   create table tab ( add_time timestamp default current_timestamp );
       -- 表示将当前时间的时间戳设为默认值。
       current_date, current_time
5. AUTO_INCREMENT 自动增长约束
   自动增长必须为索引（主键或unique）
   只能存在一个字段为自动增长。
   默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;
6. COMMENT 注释
   例：create table tab ( id int ) comment &apos;注释内容&apos;;
7. FOREIGN KEY 外键约束
   用于限制主表与从表数据完整性。
   alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
       -- 将表t1的t1_id外键关联到表t2的id字段。
       -- 每个外键都有一个名字，可以通过 constraint 指定
   存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。
   作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。
   MySQL中，可以对InnoDB引擎使用外键约束：
   语法：
   foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
   此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。
   可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
   如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
   1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
   2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
   3. restrict，拒绝父表删除和更新。
   注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。
</code></pre><p>建表规范</p>
<pre><code>   -- Normal Format, NF
       - 每个表保存一个实体信息
       - 每个具有一个ID字段作为主键
       - ID主键 + 原子表
   -- 1NF, 第一范式
       字段不能再分，就满足第一范式。
   -- 2NF, 第二范式
       满足第一范式的前提下，不能出现部分依赖。
       消除符合主键就可以避免部分依赖。增加单列关键字。
   -- 3NF, 第三范式
       满足第二范式的前提下，不能出现传递依赖。
       某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
       将一个实体信息的数据放在一个表内实现。

SELECT

SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT
a. select_expr
   -- 可以用 * 表示所有字段。
       select * from tb;
   -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
       select stu, 29+25, now() from tb;
   -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
       - 使用 as 关键字，也可省略 as.
       select stu+10 as add10 from tb;
b. FROM 子句
   用于标识查询来源。
   -- 可以为表起别名。使用as关键字。
       SELECT * FROM tb1 AS tt, tb2 AS bb;
   -- from子句后，可以同时出现多个表。
       -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
       SELECT * FROM tb1, tb2;
   -- 向优化符提示如何选择索引
       USE INDEX、IGNORE INDEX、FORCE INDEX
       SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;
       SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;
c. WHERE 子句
   -- 从from获得的数据源中进行筛选。
   -- 整型1表示真，0表示假。
   -- 表达式由运算符和运算数组成。
       -- 运算数：变量（字段）、值、函数返回值
       -- 运算符：
           =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;,&gt;=, &gt;, !, &amp;&amp;, ||,
           in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
           is/is not 加上ture/false/unknown，检验某个值的真假
           &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较
d. GROUP BY 子句, 分组子句
   GROUP BY 字段/别名 [排序方式]
   分组后会进行排序。升序：ASC，降序：DESC
   以下[合计函数]需配合 GROUP BY 使用：
   count 返回不同的非NULL值数目  count(*)、count(字段)
   sum 求和
   max 求最大值
   min 求最小值
   avg 求平均值
   group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。
e. HAVING 子句，条件子句
   与 where 功能、用法相同，执行时机不同。
   where 在开始时执行检测数据，对原数据进行过滤。
   having 对筛选出的结果再次进行过滤。
   having 字段必须是查询出来的，where 字段必须是数据表存在的。
   where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
   where 不可以使用合计函数。一般需用合计函数才会用 having
   SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。
f. ORDER BY 子句，排序子句
   order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
   升序：ASC，降序：DESC
   支持多个字段的排序。
g. LIMIT 子句，限制结果数量子句
   仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
   limit 起始位置, 获取条数
   省略第一个参数，表示从索引0开始。limit 获取条数
h. DISTINCT, ALL 选项
   distinct 去除重复记录
   默认为 all, 全部记录

UNION

   将多个select查询的结果组合成一个结果集合。
   SELECT ... UNION [ALL|DISTINCT] SELECT ...
   默认 DISTINCT 方式，即所有返回的行都是唯一的
   建议，对每个SELECT查询加上小括号包裹。
   ORDER BY 排序时，需加上 LIMIT 进行结合。
   需要各select查询的字段数量一样。
   每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。

子查询

   - 子查询需用括号包裹。
-- from型
   from后要求是一个表，必须给子查询结果取个别名。
   - 简化每个查询内的条件。
   - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
   - 子查询返回一个表，表型子查询。
   select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
   - 子查询返回一个值，标量子查询。
   - 不需要给子查询取别名。
   - where子查询内的表，不能直接用以更新。
   select * from tb where money = (select max(money) from tb);
   -- 列子查询
       如果子查询结果返回的是一列。
       使用 in 或 not in 完成查询
       exists 和 not exists 条件
           如果子查询返回数据，则返回1或0。常用于判断条件。
           select column1 from t1 where exists (select * from t2);
   -- 行子查询
       查询条件是一个行。
       select * from t1 where (id, gender) in (select id, gender from t2);
       行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
       行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。
   -- 特殊运算符
   != all()    相当于 not in
   = some()    相当于 in。any 是 some 的别名
   != some()   不等同于 not in，不等于其中某一个。
   all, some 可以配合其他运算符一起使用。
</code></pre><p>连接查询(join)</p>
<pre><code>   将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
   - 默认就是内连接，可省略inner。
   - 只有数据存在时才能发送连接。即连接结果不能出现空行。
   on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
   也可用where表示连接条件。
   还有 using, 但需字段名相同。 using(字段名)
   -- 交叉连接 cross join
       即，没有条件的内连接。
       select * from tb1 cross join tb2;
-- 外连接(outer join)
   - 如果数据不存在，也会出现在连接结果中。
   -- 左外连接 left join
       如果数据不存在，左表记录会出现，而右表为null填充
   -- 右外连接 right join
       如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
   自动判断连接条件完成连接。
   相当于省略了using，会自动查找相同字段名。
   natural join
   natural left join
   natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;

导出

select * into outfile 文件地址 [控制格式] from 表名;   -- 导出表数据

load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据
   生成的数据默认的分隔符是制表符
   local未指定，则数据文件必须在服务器上
   replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields  控制字段格式
默认：fields terminated by &apos;    &apos; enclosed by &apos;&apos; escaped by &apos;\&apos;
   terminated by &apos;string&apos;  -- 终止
   enclosed by &apos;char&apos;      -- 包裹
   escaped by &apos;char&apos;       -- 转义
   -- 示例：
       SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;
       FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;
       LINES TERMINATED BY &apos; &apos;
       FROM test_table;
lines   控制行格式
默认：lines terminated by &apos; &apos;
   terminated by &apos;string&apos;  -- 终止

INSERT

select语句获得的数据可以用insert插入。
可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
   或者使用set语法。
   INSERT INTO tbl_name SET field=value,...；
可以一次性使用多个值，采用(), (), ();的形式。
   INSERT INTO tbl_name VALUES (), (), ();
可以在列值指定时，使用表达式。
   INSERT INTO tbl_name VALUES (field_value, 10+10, now());
可以使用一个特殊值 DEFAULT，表示该列使用默认值。
   INSERT INTO tbl_name VALUES (field_value, DEFAULT);
可以通过一个查询的结果，作为需要插入的值。
   INSERT INTO tbl_name SELECT ...;
可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
   INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;

DELETE

DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]
按照条件删除。where
指定删除的最多记录数。limit
可以通过排序条件删除。order by + limit
支持多表删除，使用类似连接语法。
delete from 需要删除数据多表1，表2 using 表连接操作 条件。

TRUNCATE

TRUNCATE [TABLE] tbl_name
清空数据
删除重建表
区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区
</code></pre><p>备份与还原</p>
<pre><code>备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。
-- 导出
mysqldump [options] db_name [tables]
mysqldump [options] ---database DB1 [DB2 DB3...]
mysqldump [options] --all--database
1. 导出一张表
  mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
  mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
  mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库
  mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)
可以-w携带WHERE条件
-- 导入
1. 在登录mysql的情况下：
  source  备份文件
2. 在不登录的情况下
  mysql -u用户名 -p密码 库名 &lt; 备份文件
</code></pre><p>视图</p>
<pre><code>什么是视图：
   视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
   视图具有表结构文件，但不存在数据文件。
   对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
   视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。
-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
   - 视图名必须唯一，同时不能与表重名。
   - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
   - 可以指定视图执行的算法，通过ALGORITHM指定。
   - column_list如果存在，则数目必须等于SELECT语句检索的列数
-- 查看结构
   SHOW CREATE VIEW view_name
-- 删除视图
   - 删除视图后，数据依然存在。
   - 可同时删除多个视图。
   DROP VIEW [IF EXISTS] view_name ...
-- 修改视图结构
   - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
   ALTER VIEW view_name [(column_list)] AS select_statement
-- 视图作用
   1. 简化业务逻辑
   2. 对客户端隐藏真实的表结构
-- 视图算法(ALGORITHM)
   MERGE       合并
       将视图的查询语句，与外部查询需要先合并再执行！
   TEMPTABLE   临时表
       将视图执行完毕后，形成临时表，再做外层查询！
   UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。
</code></pre><p>事务(transaction)</p>
<pre><code>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。
   - 支持连续SQL的集体成功或集体撤销。
   - 事务是数据库在数据晚自习方面的一个功能。
   - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
   - InnoDB被称为事务安全型引擎。
-- 事务开启
   START TRANSACTION; 或者 BEGIN;
   开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
   COMMIT;
-- 事务回滚
   ROLLBACK;
   如果部分操作发生问题，映射到事务开启前。
-- 事务的特性
   1. 原子性（Atomicity）
       事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
   2. 一致性（Consistency）
       事务前后数据的完整性必须保持一致。
       - 事务开始和结束时，外部数据一致
       - 在整个事务过程中，操作是连续的
   3. 隔离性（Isolation）
       多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
   4. 持久性（Durability）
       一个事务一旦被提交，它对数据库中的数据改变就是永久性的。
-- 事务的实现
   1. 要求是事务支持的表类型
   2. 执行一组相关的操作前开启事务
   3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。
-- 事务的原理
   利用InnoDB的自动提交(autocommit)特性完成。
   普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
   而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。
-- 注意
   1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
   2. 事务不能被嵌套
-- 保存点
   SAVEPOINT 保存点名称 -- 设置一个事务保存点
   ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
   RELEASE SAVEPOINT 保存点名称 -- 删除保存点
-- InnoDB自动提交特性设置
   SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。
   - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
   - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
       SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
       而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)
</code></pre><p>锁表</p>
<pre><code>表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
   LOCK TABLES tbl_name [AS alias]
-- 解锁
   UNLOCK TABLES

触发器

   触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
   监听：记录的增加、修改、删除。
-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROWtrigger_stmt
   参数：
   trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
   trigger_event指明了激活触发程序的语句的类型
       INSERT：将新行插入表时激活触发程序
       UPDATE：更改某一行时激活触发程序
       DELETE：从表中删除某一行时激活触发程序
   tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
   trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构
-- 删除
DROP TRIGGER [schema_name.]trigger_name
可以使用old和new代替旧的和新的数据
   更新操作，更新前是old，更新后是new.
   删除操作，只有old.
   增加操作，只有new.
-- 注意
   1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。



-- 字符连接函数
concat(str1,str2,...])
concat_ws(separator,str1,str2,...)

-- 分支语句
if 条件 then
   执行语句
elseif 条件 then
   执行语句
else
   执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
   SQL语句
自定义结束符号
delimiter ;     -- 修改回原来的分号

-- 语句块包裹
begin
   语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
   如果没有重复记录，会触发 before insert, after insert;
   如果有重复记录并更新，会触发 before insert, before update, after update;
   如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert

SQL编程

--// 局部变量 ----------
-- 变量声明
   declare var_name[,...] type [default value]
   这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。
-- 赋值
   使用 set 和 select into 语句为变量赋值。
   - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;
select into 可以将表中查询获得的数据赋给变量。
   -| select max(height) into @max_height from tb;
-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;
   - 变量被定义后，在整个会话周期都有效（登录到退出）



--// 控制结构 ----------
-- if语句
if search_condition then
   statement_list   
[elseif search_condition then
   statement_list]
...
[else
   statement_list]
end if;
-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END
-- while循环
[begin_label:] while search_condition do
   statement_list
end while [end_label];
- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。
   -- 退出循环
       退出整个循环 leave
       退出当前循环 iterate
       通过退出的标签决定退出哪个循环



--// 内置函数 ----------
-- 数值函数
abs(x)          -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)         -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)       -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)       -- m^n
sqrt(x)         -- 算术平方根
rand()          -- 随机数
truncate(x, d)  -- 截取d位小数
-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                 -- 当前日期
current_time();                 -- 当前时间
date(&apos;yyyy-mm-dd hh:ii:ss&apos;);    -- 获取日期部分
time(&apos;yyyy-mm-dd hh:ii:ss&apos;);    -- 获取时间部分
date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间
unix_timestamp();               -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间
-- 字符串函数
length(string)          -- string长度，字节
char_length(string)     -- string的字符个数
substring(str, position [,length])      -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])   -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)           -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position]) -- 同instr,但可指定开始位置
lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)           -- 去除前端空格
repeat(string, count)   -- 重复count次
rpad(string, length, pad)   --在str后用pad补充,直到长度为length
rtrim(string)           -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小
-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。
-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()
-- 其他常用函数
md5();
default();

--// 存储函数，自定义函数 ----------
-- 新建
   CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
       函数体
   - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
   - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
   - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。
   - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
   - 多条语句应该使用 begin...end 语句块包含。
   - 一定要有 return 返回值语句。
-- 删除
   DROP FUNCTION [IF EXISTS] function_name;
-- 查看
   SHOW FUNCTION STATUS LIKE &apos;partten&apos;
   SHOW CREATE FUNCTION function_name;
-- 修改
   ALTER FUNCTION function_name 函数选项

--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。
-- 创建
CREATE PROCEDURE sp_name (参数列表)
   过程体
参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型
注意，没有返回值。


/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中
-- 参数
IN|OUT|INOUT 参数名 数据类型
IN      输入：在调用过程中，将数据输入到过程体内部的参数
OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT   输入输出：既可输入，也可输出
-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
   过程体
END
</code></pre><p>用户和权限管理</p>
<pre><code>-- root密码重置
1. 停止MySQL服务
2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;
   [Windows] mysqld --skip-grant-tables
3. use mysql;
4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;
5. FLUSH PRIVILEGES;
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES;
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
   - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
   - 只能创建用户，不能赋予权限。
   - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos;
   - 密码也需引号，纯数字密码也要加引号
   - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD(&apos;密码&apos;)  -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;]
   - all privileges 表示所有权限
   - *.* 表示所有库的所有表
   - 库名.表名 表示某库下面的某表
   GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;;
-- 查看权限
SHOW GRANTS FOR 用户名
   -- 查看当前用户权限
   SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
   GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
   GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
   GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
   当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER   -- 允许使用ALTER TABLE
ALTER ROUTINE   -- 更改或取消已存储的子程序
CREATE  -- 允许使用CREATE TABLE
CREATE ROUTINE  -- 创建已存储的子程序
CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE
CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW     -- 允许使用CREATE VIEW
DELETE  -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE     -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX   -- 允许使用CREATE INDEX和DROP INDEX
INSERT  -- 允许使用INSERT
LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES  -- 未被实施
RELOAD  -- 允许使用FLUSH
REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT  -- 允许使用SELECT
SHOW DATABASES  -- 显示所有数据库
SHOW VIEW   -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE  -- 允许使用UPDATE
USAGE   -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限
</code></pre><p>表维护</p>
<pre><code>-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre><p>杂项</p>
<pre><code>1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
   单行注释 # 注释内容
   多行注释 /* 注释内容 */
   单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
   _   任意单个字符
   %   任意多个字符，甚至包括零字符
   单引号需要进行转义 &apos;
5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;G&quot;, &quot;g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：c
</code></pre>]]></content>
      <categories>
        <category>搬运</category>
      </categories>
  </entry>
</search>
