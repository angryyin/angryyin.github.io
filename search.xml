<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2019%2F07%2F24%2Fs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[来自https://m.jb51.net/article/24101.htm javascript深入理解js闭包 闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 Js代码1234567 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 Js代码12345 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ Js代码1234567 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 Js代码123456789 function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope）， 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ Js代码123456789101112131415 function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。 各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 怎么来理解这句话呢？请看下面的代码。 Js代码123456789101112131415161718192021 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个 匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便 改变父函数内部变量的值。 六、思考题如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 Js代码12345678910 var name = "The Window"; var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 123456789101112JavaScript闭包例子function outerFun() &#123; var a=0; function innerFun() &#123; a++; alert(a); &#125; &#125;innerFun() 上面的代码是错误的.innerFun()的作用域在outerFun()内部,所在outerFun()外部调用它是错误的. 改成如下,也就是闭包: Js代码 function outerFun(){ var a=0; function innerFun() { a++; alert(a); } return innerFun; //注意这里}var obj=outerFun();obj(); //结果为1obj(); //结果为2var obj2=outerFun();obj2(); //结果为1obj2(); //结果为2 什么是闭包: 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们. 再来看一个例子 Js代码12345678function outerFun()&#123; var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果是 0,4 . 因为在函数内部使用了var关键字 维护a的作用域在outFun()内部. 再看下面的代码: Js代码123456789function outerFun()&#123; //没有var a =0; alert(a); &#125;var a=4;outerFun();alert(a); 结果为 0,0 真是奇怪,为什么呢? 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值 .当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4; 并改变其值. 如果你对javascript闭包还不是很理解，那么请看下面转载的文章：(转载:http://www.felixwoo.com/archives/247) 一、什么是闭包？官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码： function a() { var i = 0; function b() { alert(++i); } return b;}var c = a();c();这段代码有两个特点： 1、函数b嵌套在函数a内部； 2、函数a返回函数b。 引用关系如图： 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说： 当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 二、闭包有什么作用？ 简而言之，闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。这是对闭包作用的非常直白的描述，不专业也不严谨，但大概意思就是这样，理解闭包需要循序渐进的过程。 在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。 那 么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍) 三、闭包内的微观世界 如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。 当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。当执行函数a的时候，a会进入相应的执行环境(excution context)。在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。 当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示： 如图所示，当在函数b中访问一个变量的时候，搜索顺序是： 先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。如果整个作用域链上都无法找到，则返回undefined。小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：123456function f(x) &#123; var g = function () &#123; return x; &#125; return g;&#125;var h = f(1);alert(h()); 这段代码中变量h指向了f中的那个匿名函数(由g返回)。 假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。 运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。 四、闭包的应用场景保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。 在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）私有属性和方法在Constructor外是无法被访问的12345function Constructor(...) &#123; var that = this; var membername = value; function membername(...) &#123;...&#125;&#125; 以上3点是闭包最基本的应用场景，很多经典案例都源于此。 五、Javascript的垃圾回收机制在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。 六、结语理解JavaScript的闭包是迈向高级JS程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[php写的mysql数据迁移]]></title>
    <url>%2F2019%2F07%2F19%2Ftitled%2F</url>
    <content type="text"><![CDATA[msyql 200万数据迁移trend与trend_new data与data_new data_new最大，1980页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public function run_combine()&#123; $ids = [518,520,524,525,542,544,558,689,690,758,759]; foreach ($ids as $k =&gt; $v) &#123; $job_id = $v; // $sign = $this-&gt;insert_trend($job_id); // if($sign==1)&#123; // $sign = $this-&gt;insert_data($job_id); // &#125; $sign = $this-&gt;insert_data($job_id); &#125; print json_encode(array('code'=&gt;0, 'desc'=&gt;'okokokokokokok')); &#125; public function insert_trend($job_id)&#123; $sql1 = "select * from t_result_pub_trend where job_id = '$job_id'"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); // $this-&gt;p($rows[22775]); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['category_name']."','".$v1['pv']."','".$v1['hour']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT INTO t_result_pub_trend_new (job_id,dt,uid,category_name,pv,`hour`) VALUES $tmp"; $this-&gt;db-&gt;query($sql); &#125; unset($rows); return 1; &#125; public function insert_data($job_id)&#123; $sql1 = "select * from t_result_pub_data where job_id = '$job_id'"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['time']."','".$v1['mid']."','".$v1['is_topic']."','".$v1['category_names']."','".$v1['atuids']."','".$v1['total_valid_cs']."','".$v1['id']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"; // $this-&gt;p($sql); $this-&gt;db-&gt;query($sql); &#125; unset($rows); return 2; &#125; public function insert_data_special()&#123; $job_id = 852; $sql_num = "select count('id') ct from t_result_pub_data where job_id = '$job_id'"; $all = $this-&gt;db-&gt;query($sql_num)-&gt;row_array(); $num = $all['ct']; $ci = round($num/10000); for ($w=0; $w&lt; $ci; $w++) &#123; $x = $w *10000; $sql1 = "select * from t_result_pub_data where job_id = '$job_id' limit $x , 10000"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['time']."','".$v1['mid']."','".$v1['is_topic']."','".$v1['category_names']."','".$v1['atuids']."','".$v1['total_valid_cs']."','".$v1['id']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT ignore INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"; // $this-&gt;p($sql); $this-&gt;db-&gt;query($sql); &#125; unset($rows); &#125; $this-&gt;p($sql1); // $this-&gt;p($x); print json_encode(array('code'=&gt;0, 'desc'=&gt;'okokokokokokok')); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Untitled]]></title>
    <url>%2F2019%2F07%2F19%2Fntitled%2F</url>
    <content type="text"><![CDATA[msyql 200万数据迁移trend与trend_new data与data_new data_new最大，1980页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public function run_combine()&#123; $ids = [518,520,524,525,542,544,558,689,690,758,759]; foreach ($ids as $k =&gt; $v) &#123; $job_id = $v; // $sign = $this-&gt;insert_trend($job_id); // if($sign==1)&#123; // $sign = $this-&gt;insert_data($job_id); // &#125; $sign = $this-&gt;insert_data($job_id); &#125; print json_encode(array('code'=&gt;0, 'desc'=&gt;'okokokokokokok')); &#125; public function insert_trend($job_id)&#123; $sql1 = "select * from t_result_pub_trend where job_id = '$job_id'"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); // $this-&gt;p($rows[22775]); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['category_name']."','".$v1['pv']."','".$v1['hour']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT INTO t_result_pub_trend_new (job_id,dt,uid,category_name,pv,`hour`) VALUES $tmp"; $this-&gt;db-&gt;query($sql); &#125; unset($rows); return 1; &#125; public function insert_data($job_id)&#123; $sql1 = "select * from t_result_pub_data where job_id = '$job_id'"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['time']."','".$v1['mid']."','".$v1['is_topic']."','".$v1['category_names']."','".$v1['atuids']."','".$v1['total_valid_cs']."','".$v1['id']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"; // $this-&gt;p($sql); $this-&gt;db-&gt;query($sql); &#125; unset($rows); return 2; &#125; public function insert_data_special()&#123; $job_id = 852; $sql_num = "select count('id') ct from t_result_pub_data where job_id = '$job_id'"; $all = $this-&gt;db-&gt;query($sql_num)-&gt;row_array(); $num = $all['ct']; $ci = round($num/10000); for ($w=0; $w&lt; $ci; $w++) &#123; $x = $w *10000; $sql1 = "select * from t_result_pub_data where job_id = '$job_id' limit $x , 10000"; $rows = $this-&gt;db-&gt;query($sql1)-&gt;result_array(); $data = []; $len = count($rows); $i = 0; foreach ($rows as $k =&gt; $v) &#123; $j = ceil(($i+1) / 50); $i++; $data[$j][] = $v; &#125; //insert foreach ($data as $k =&gt; $v) &#123; $one = []; foreach ($data[$k] as $k1 =&gt; $v1) &#123; $one[] = "('".$v1['job_id']."','".$v1['dt']."','".$v1['uid']."','".$v1['time']."','".$v1['mid']."','".$v1['is_topic']."','".$v1['category_names']."','".$v1['atuids']."','".$v1['total_valid_cs']."','".$v1['id']."')"; &#125; $tmp = implode(',', $one); $sql = "INSERT ignore INTO t_result_pub_data_new (job_id,dt,uid,`time`,mid,is_topic,category_names,atuids,total_valid_cs,id) VALUES $tmp"; // $this-&gt;p($sql); $this-&gt;db-&gt;query($sql); &#125; unset($rows); &#125; $this-&gt;p($sql1); // $this-&gt;p($x); print json_encode(array('code'=&gt;0, 'desc'=&gt;'okokokokokokok')); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[鹰眼系统]]></title>
    <url>%2F2019%2F07%2F02%2F%E7%9C%BC%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[依靠微博日志 进行实时计算 过滤日志实时算各种榜单实时监控大V账号 xunzhe 根据条件筛选用户 用到ES引擎 爬虫scrapy 目标： 高性能高可用分布式爬虫 前端JQuery-Angular.js-vue.js目标：前后端分离 新浪为什么要用php ci框架 08年到现在还是php 能用就行… Apache 高并发会有问题 所以采用nginx thrift es速度远超mysql 与mongodb相当 mysql慢查询 读写分离延迟 hbase redis 数据计算 离线技术：hadoop（mapreducehive），spark 实时技术： ols-&gt;spark streaming-&gt;flink 多维查询： ckickhouse，presto 鹰眼如何监控1选择监控的账号2]]></content>
  </entry>
  <entry>
    <title><![CDATA[python知识积累]]></title>
    <url>%2F2019%2F06%2F25%2Fthon%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[scrapy pipline持久化 google baidu本身也是爬虫 代理ip与访问间隔 防止封ip 利用深度学习绕过机器图片检测 滑动进度条不匀速 js代码 模拟登陆 爬取数据必须登陆 携带cookie 反爬虫 检测是否访问js、css 自定义字体库 递归的url 蜜罐 只开放手机端 不开放其他接口]]></content>
  </entry>
  <entry>
    <title><![CDATA[北京之旅day3]]></title>
    <url>%2F2019%2F05%2F10%2F%E4%BA%AC%E4%B9%8B%E6%97%85day3%2F</url>
    <content type="text"><![CDATA[入职昨天入职，今天正式开始接需求，一开始的需求不会太难，但是我还是花了很多时间去看懂他的代码结构，索性最后还是写出来我想要的效果，也算是在周末前给自己的一个定心丸，毕竟如果今天什么都做不出来的话，那么接下来的日子就不好过了。 坑今天又去逛了超市，感觉其实没什么好买的，以后晚上应该都是吃零食，因为新浪的伙食，看上去很好看，看上去也很多，但是只要你加一个荤菜，你就会后悔来北京，那是指数级别的加价，我的天哪，加一个荤菜，给我加十块钱，还有昨天吃那个凉面，花了我十三块钱，还没有五谷烩四块钱的热干面好吃，真的是一言难尽。 补充昨天的day2主要是到处去逛，一天骑了好长时间的车，而且我发现，在北京，hellobike特别抢手，因为每天早上公司门口停满了hellobike，每天晚上公司门口，一辆hellobike都没有，只剩下破铜烂铁，我还是不打算去办摩拜，因为走回来也只要30分钟，都还好，]]></content>
  </entry>
  <entry>
    <title><![CDATA[北京之旅day1]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%BA%AC%E4%B9%8B%E6%97%85day1%2F</url>
    <content type="text"><![CDATA[之所以去北京是为了新浪的实习，而且目前也只有新浪的offer，是在是没得法子。。虽然昨天下午接了小米的电话，但是好像也不能立刻改变什么，该去的还是要去，历练嘛，不能在毕业之前还心里没有谱，那不等于白读三年研究生。。 早上坐了校车从东澜岸赶到学校，等到了青山老妈已经请了假在帮我收拾行李，老爸打电话告诉我过会送我去火车站，然后我又被我妈怂恿跑去办理银行卡挂失（这导致我当天到了北京之后没有钱付房租，还是找媳妇要的钱付的。。。），实在不是什么明智之举。 去北京，不是第一次去，感觉北京的天气比武汉的舒服，因为不是很热，有风吹过，吹的人心情舒畅一点点，也没有雾霾什么的，听说在办世园会。动车是真的贵，也是真的快，1000公里4小时就到了，但是要花520大洋。中介小哥倒是十分热情，虽然我还不知道他会不会有什么套路，但是年级比我小两岁，如果碰到个40岁的中介绝对比他会的套路多，我在来之前其实大致确定了要住的房子，便宜，优惠一个月，位置还可以，空气也还算可以，我强制他带我去看了其他两套房子，是那种我知道肯定我不会选的，结果比我想的还要差，第一家屋子只能住两个人，客厅里到处都是鞋子衣物，我懂那个租户的想法，想利用这样脏乱的环境劝退其他人，好让自己好好住在里面，并且他是有一个女的一起住的，哪个在外漂的人愿意天天听别个床板吱呀吱呀声。。。另外一家更贵一点，房间更大一点，但是房子味道很重。。。自如的套路其实都写在合同里面了，坑你一个月的房租，比同行高得多的服务费，但是他掌握的房源多，并且服务还算可以，只要甲醛没得问题其他都还好。算下来转租有点难度，估计要花费9000到10000左右，也就是说我工资刚刚抵押房钱，所以说还是武汉好啊，北京不拿几万工资根本活不下去。 晚上在外面晃荡一下，找了一家餐馆吃了点，估计以后会经常去那边吃，物价的话还好，但是味道真的一般，也许明天我可能就会去买个奶锅买点面条每天自己下面吃，这样一天的开销，早晚餐可以压缩到十元左右，每天应该会到处逛逛，去新浪看看，]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo重新部署的方法]]></title>
    <url>%2F2019%2F04%2F29%2Fxo%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[安装Git Bash百度git安装 安装NodeJs百度 安装hexonpm install hexo-cli -g 生成SSH并添加到githubgit config –global user.name “yourname”git config –global user.email youremail@example.comssh-keygen -t rsa -C “youremail@example.com“拷贝秘钥到GitHub上，替换秘钥 上传npm install hexo-deployer-git –save]]></content>
  </entry>
  <entry>
    <title><![CDATA[分布式session]]></title>
    <url>%2F2019%2F04%2F24%2F%E5%B8%83%E5%BC%8Fsession%2F</url>
    <content type="text"><![CDATA[(1) 应用服务器间的session复制共享（如tomcat session共享）(2) 基于cache DB缓存的session共享 应用服务器间的session复制共享 session复制共享，主要是指集群环境下，多台应用服务器之间同步session，使session保持一致，对外透明。 如果其中一台服务器发生故障，根据负载均衡的原理，web服务器（apache/nginx）会遍历寻找可用节点，分发请求，由于session已同步，故能保证用户的session信息不会丢失。 此方案的不足之处： 技术复杂,必须在同一种中间件之间完成(如:tomcat-tomcat之间).session复制带来的性能损失会快速增加.特别是当session中保存了较大的对象,而且对象变化较快时, 性能下降更加显著. 这种特性使得web应用的水平扩展受到了限制。Session内容序列化（serialize），会消耗系统性能。Session内容通过广播同步给成员，会造成网络流量瓶颈，即便是内网瓶颈。 基于cache DB缓存的session共享即使用cacheDB存取session信息，应用服务器接受新请求将session信息保存在cache DB中，当应用服务器发生故障时，web服务器（apache/nginx）会遍历寻找可用节点，分发请求，当应用服务器发现session不在本机内存时，则去cache DB中查找，如果找到则复制到本机，这样实现session共享和高可用。 目前有开源的msm用于解决tomcat之间的session共享：Memcached_Session_Manager（MSM） http://code.google.com/p/memcached-session-manager/一个高可用的Tomcat session共享解决方案，除了可以从本机内存快速读取Session信息(仅针对黏性Session)外，同时可使用memcached存取Session，以实现高可用。 特性支持Tomcat6、Tomcat7支持黏性、非黏性Session无单一故障点可处理tomcat故障转移可处理memcached故障转移插件式session序列化允许异步保存session，以提升响应速度只有当session有修改时，才会将session写回memcachedJMX管理&amp;监控该方案的不足之处： memcache支持的数据结构比较单一memcache的内存必须足够大，否则会出现用户session从Cache中被清除需要定期的刷新缓存服务器故障时，存在于内存的memcache数据将会丢失 为了解决基于memcache中存在的不足，故提出了下面的一种解决方案： 基于redis缓存的session共享 结合上面的 MSM 思想，由 redis负责 session 数据的存储，而我们自己实现的 session manager 将负责 session 生命周期的管理。 一般的系统架构:]]></content>
  </entry>
  <entry>
    <title><![CDATA[索引失效的情况]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[1.隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效. 错误的例子：select from test where tu_mdn=13333333333; 正确的例子：select from test where tu_mdn=’13333333333’; 2.对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，，/，! 等) 错误的例子：select from test where id-1=9; 正确的例子：select * from test where id=10; 3.使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引. 错误的例子：select from test where round(id)=10; 说明，此时id的索引已经不起作用了 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select from test where round(id)=10; 这时函数索引起作用了 4.以下使用会使索引失效，应避免使用； a. 使用 &lt;&gt; 、not in 、not exist、!= b. like “%_” 百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理） c. 单独引用复合索引里非第一位置的索引列.应总是使用索引的第一个列，如果索引是建立在多个列上, 只有在它的第一个列被where子句引用时，优化器才会选择使用该索引。 d. 字符型字段为数字时在where条件里不添加引号. e. 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。 5.不要将空的变量值直接与比较运算符（符号）比较。 如果变量可能为空，应使用 IS NULL 或 IS NOT NULL 进行比较，或者使用 ISNULL 函数。 6.不要在 SQL 代码中使用双引号。 因为字符常量使用单引号。如果没有必要限定对象名称，可以使用（非 ANSI SQL 标准）括号将名称括起来。 7.将索引所在表空间和数据所在表空间分别设于不同的磁盘chunk上，有助于提高索引查询的效率。 Oracle默认使用的基于代价的SQL优化器（CBO）非常依赖于统计信息，一旦统计信息不正常，会导致数据库查询时不使用索引或使用错误的索引。一般来说，Oracle的自动任务里面会包含更新统计信息的语句，但如果表数据发生了比较大的变化（超过20%）,可以考虑立即手动更新统计信息，例如：analyze table abc compute statistics，但注意，更新 统计信息比较耗费系统资源，建议在系统空闲时执行。 Oracle在进行一次查询时，一般对一个表只会使用一个索引.因此，有时候过多的索引可能导致Oracle使用错误的索引，降低查询效率。例如某表有索引1（Policyno）和索引2（classcode），如果查询条件为policyno = ‘xx’ and classcode = ‘xx’，则系统有可能会使用索 引2，相较于使用索引1，查询效率明显降低。 优先且尽可能使用分区索引。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库总结]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%BA%93%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在数据库题目中，由于现在大部分公司都是使用MySql作为数据库，因此笔者及其朋友所遇到的问题也都是MySql相关的知识点。1）MySql中索引的基本定义，优劣势，以及索引优化。索引是帮助Mysql高效获取数据的数据结构，因此，索引的本质就是数据结构，索引的目的在于提高查询效率，可类比字典。索引：排好序的快速查找的数据结构。用途：排序 + 快速查找。注意，是两种功能。数据库除了存储数据本身之外，还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。MySql索引通常是指B+树索引。索引优势：类似书籍的目录，提高数据检索的效率，降低数据库的 IO 成本（因为数据最终是存储在磁盘上的）。通过索引列对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗（因为排好序，查询速度增加）。索引劣势：索引也是一张表，保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用磁盘空间的。虽然提高了查询速度，但是会降低更新速度（因为数据更新后，需要重新对索引排序），如 INSERT、UPDATE、DELETE 操作。哪些情况适合建索引：①主键自动建立唯一索引。②频繁作为查询条件的字段应该创建索引。③查询中与其它表关联的字段，外键关系建立索引。④查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。⑤查询中统计或者分组字段。哪些情况不适合建索引：①频繁更新的字段。②Where 条件中用不到的字段。③表记录太少。④经常增删改的表。⑤散列太小的字段，如性别、国籍。索引优化就是为了尽可能的利用索引来提高查询的效率，所以保证索引不失效，并且创建正确的索引与高效的sql语句，就是对索引的优化，因此关于优化直接看下个题目：索引的失效。2）哪些情况下索引失效。索引优化和索引失效是相对应的，我们优化索引的目的就是为了让索引不失效，发生下列情况索引会失效：①对于使用NOT NULL修饰的字段，使用IS NULL和 IS NOT NULL，会导致索引失效，进行全表扫描。②键值较少的列。因为键值较少，如果加上索引，还需要对索引进行维护，本来记录就少，所以直接查询效率更高。③LIKE以%开头会导致索引失效。如果右边加上%，索引不会失效，但是在实际生产环境中，如果只在右边加%，对于模糊查询不够用。解决方式：使用索引覆盖：查询字段和条件字段都在索引列上时，索引才会生效。④使用范围后（如字段&gt;1）会使索引失效（存储引擎不能使用索引中范围条件右边的列）。所以如果存在范围查询的字段，就不要建立索引。⑤对于两张表，如果基于主键的查询，是可以用索引的，因为主键本身就有索引，对于左右连接来说，左连接，左表肯定是All，本来就要查询出左表的结果，所以右表建立索引，而右连接相反，左表建立索引。⑥不要在索引列上做任何操作（计算、函数和类型转换），会导致索引失效，另外在字符串查询不加单引号，也会导致索引失效。⑦最左前缀法则：查询从索引列的最左开始（头部），如果没有头部，则会使用全表扫描，并且中间不能间断，如只有头部和尾部，则只使用头部索引。火车头不能少，中间车厢不能断。⑧使用不等于的时候会使索引失效，导致全表扫描。⑨尽量使用覆盖索引：索引列和查询列一致。⑩OR连接会使索引失效，导致全表扫描。⑪Order By 要尽量使用 Index 排序，避免 Filesort 排序。3）MySql调优项目经历或者相关策略。是否需要添加索引，在哪些字段上添加索引，在sql语句中，索引列是否用上，主要使用Explain对sql语句进行分析。这里对Explain进行简单介绍：使用 Explain 关键字可以模拟优化器执行 Sql 查询语句，从而知道 Mysql 是如何处理 Sql 的。执行Explain会产生一个信息表，表中有如下关键字： ①id：select查询的序列号，表示查询中执行select子句或操作表的顺序。值越大越先执行，值相同，从上到下依次执行。②select_type:有6种取值SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT，其值具体解释，参考：https://yq.aliyun.com/articles/61934③table:显示当前行sql是对哪张表进行操作的。④type：指访问类型，非常重要，根据type可推断sql语句的优劣。其取值从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all，通常需保证到range级别，最好能达到ref级别。 #1.const：表示通过索引一次就找到了，用于比较主键索引或者唯一性索引。如将主键置于 Where 条件中，Mysql 就能将该查询转换为一个常量。 #2.system：表示只有一行数据，是const的特例，生产中基本不会出现，可忽略。 #3.eq_ref：唯一性索引扫描。对于每个索引表中只有一条记录与之匹配。常见于主键或唯一索引扫描。 #4.ref：非唯一性索引扫描，返回匹配某个单独值的所有行。对于 eq_ref &amp; ref 的总结：都会使用索引，但使用索引进行检索后的结果不同，前者的结果是唯一的，而后者的结果不唯一。所以，前者通常用于主键或唯一性索引扫描，而后者通常用于非唯一性索引扫描（有多行记录）。 #5.range：只检索给定范围的行，使用一个索引来选择行；Key 列显示使用了哪个索引；一般就是在 Where 条件中出现了 between, &lt;, &gt;, in 等查询；它比全索引扫描要好，因为它开始于索引的某一点、且结束于另一点，而不用全索引扫描. #6.index：全索引扫描，只遍历索引树，index和all 都是全表扫描，但是 index 是从索引中读取，而 All 是从磁盘中读取。 #7.All：全表扫描，磁盘扫描。⑤possible_keys：显示理论上有可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被实际使用。⑥key：实际使用的索引。如果为 Null，则未使用索引。查询中若使用了覆盖索引，则该索引只出现在 Key 列表中（即不会出现在 possible_keys 列中）。⑦key_len：表示索引中使用的字节数，可通过该值计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的。⑧ref：显示索引的哪一列被使用了，如果索引被使用则是一个常数。表示哪些列或常量被用于查找索引列上的值。⑨rows：根据表统计信息及索引选用情况，大致估算出查询到结果时所需要读取的行数（要跑多少行）。值越小越好（值越小说明查询越精准）。⑩Extra会出现的值包括： #1.Using filesort：说明 Mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行排序；Mysql 中无法利用索引完成的排序操作称为“文件排序”。因此出现该值，表示sql语句比较“烂”了，则需要进行sql语句的优化。 #2.Using Temporary：使用了临时表保存中间结果，Mysql 在查询结果排序时使用临时表，常见于 ORDER BY 和 GROUP BY。出现该值，则表明sql非常“烂”了，急需优化。 #3.Using Where：表明索引被用来执行索引键值的查找。 #4.Using Index：表示相应的 SELECT 操作中使用了覆盖索引，避免访问了表的数据行，效率可以。总结：type、key、ref、Extra，这四个字段比较重要，sql语句的“烂”的程度，通过这几个字段体现。type：取值从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all，查询时至少保证在range，最好达到ref。key：实际使用的索引，如果为NULL，则表示未使用索引。ref：显示那一列索引被使用了。Extra：最好是Using Index、Using Where，一定不能是Using Temporary、Using filesort。5）MySql的事务隔离级别，不可重复读、脏读、幻读。MySql的事务隔离级别有4个，隔离等级从低到高依次为Read uncommitted （读取未提交内容）、Read committed（读取提交内容） 、Repeatable read（可重复读） 、Serializable （串行），这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题，其中Repeatable read是MySql事务的默认隔离级别。 从表中可以看出Serializable隔离等级最高，可以避免一切并发问题，但是效率低。脏读：A事务更新一份数据，但事务未提交，B事务在此时读取了同一份数据，由于某些原因，A事务发生了回滚操作，则B事务拿着失效的数据去做操作就会发生错误。脏读通俗来说就是读错了，读错了。不可重复读：对于不可重复读的解释很多资料说得非常模糊，这里给出一个比较清晰的解释。A事务两次读取同一数据，在A事务还没有结束时，B事务也访问该同一数据，并进行了修改。那么在A事务中的两次读数据之间，由于B事务的修改，A事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即在重复对数据进行读取的时候，不能得到相同的数据内容，感觉这个不可重复读翻译很不好理解，个人的理解方式：不可重复读，那重复读会出现什么情况呢，重复读出现数据不一致的情况，所以还是不要重复读——&gt;不可重复读）例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改，则编辑第二次读取的文档与第一次就不一致了。幻读：通俗来讲读取到的数据像产生幻觉一样。是指当事务不是独立执行时发生的一种现象。事务A在两次查询的过程中（比如查询结果8列），事务B对该表进行了插入、删除操作（增加或减少了2列），从而事务A第二次查询的结果发生了变化，两次查询的数据不一样，感觉产生了“幻觉”一样。虚读：通俗来讲读取的数据不同。A事务在两次查询的过程中（查询结果一列），B事务对数据进行了修改，从而使A事务第二次查询的结果不一样。脏读的事务未提交，虚读与幻读事务已经提交。Read uncommitted（读未提交内容）在该级别下，A事务对一行数据修改的过程中，不允许B事务对该行数据进行修改，但允许B事务对该行数据进行读操作。 因此本级别下，不会出现更新丢失（i++问题），但会出现脏读（A修改时，发生了回滚）、不可重复读（B两次读取时，A修改了数据），幻读（幻读是不可重复读的一种情况）。Read committed（读提交内容）在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。A读取数据，B紧接着A更改了数据，并提交了事务，A再次读取数据时，发现数据已经改变。出现不可重复读和幻读想象。Repeatable read（可重复读）在该级别下，读事务时禁止写事务（读写互斥），A在读取数据时数据为100，事务提交后，紧接着B对数据修改为200，当A再次读取时，发现数据不一样，出现幻读。Serialiazble read（串行）隔离级别最高，避免一切并发问题，但效率低，生产中基本不用。6）delete 与 truncate 区别，分别适用于哪种场景。delete与truncate都是做删除操作，但是两者间还是有一定区别：①truncate删除速度快，没有日志记录，数据不可恢复。释放表或索引的空间②delete删除速度慢，因为删除中会产生日志记录，数据可恢复。不会释放表或索引的空间。③应用场景这个不好说，delete可恢复，truncate不可恢复，只有根据具体需求进行选择了。7）MySql中主从复制，集群。MySql提供主从复制的功能，基础是二进制日志文件。关于集群方面，功力不深，需要更进一步的了解，才能很好的回答该问题。参考：https://www.cnblogs.com/gl-developer/p/6170423.html8）B+树、为什么使用 B+树、B+树优缺点关于B+树，笔者并不是特别的了解。放上一链接：https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.02.md为什么使用B+树？①B+树支持区间查询，而B树不支持。②B+树方便扫库，它直接从叶子节点出发，就可以进行扫描，而B树需进行中序遍历（LDR）。③B+树磁盘读写代价更低。缺点：①当查找数据在非叶子节点时，B+树会走一条根到叶子节点的路径。参考：https://www.cnblogs.com/tiancai/p/9024351.htmlhttp://darrenzhu.iteye.com/blog/20500829）MySql存储引擎MyISAM和InnoDB的区别。①MyISAM不支持外键，InnoDB支持外键。②MyISAM不支持事务，InnoDB支持事务。③MyISAM是表锁，InnoDB是行锁。④MyISAM支持全文索引，InnoDB不支持。⑤MyISAM的查询速度比InnoDB快。]]></content>
  </entry>
  <entry>
    <title><![CDATA[聚簇索引与非聚簇索引]]></title>
    <url>%2F2019%2F04%2F23%2F%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[何时使用聚簇索引与非聚簇索引 InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 14”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引） MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 聚簇索引的优势看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？ 由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。 辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。聚簇索引适合用在排序的场合，非聚簇索引不适合取出一定范围数据的时候，使用用聚簇索引二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。 聚簇索引的劣势维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢， 主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的） 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间 mysql中聚簇索引的设定聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql索引优化]]></title>
    <url>%2F2019%2F04%2F23%2Fysql%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引的优缺点优点①类似大学图书馆的书目索引，提高数据的检索效率，降低数据库的IO成本。②通过索引列对数据进行排序，降低数据的排序成本，从而降低CPU的消耗。缺点①索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也要占用空间。②虽然索引大大提高了查询效率，但是降低了更新表的速度，如insert、update和delete操作。因为更新表时，MySQL不仅要保存数据，还要保存索引文件每次更新的索引列字段，并且在更新操作后，会更新相应字段索引的信息。③索引只是提高查询效率的一个因素，如果你的MySQL有大量的数据表，就需要花时间研究建立最优秀的索引或优化查询语句。 索引分类索引主要分为以下三类：①单值索引：一个索引只包含单个列，一个表可以有多个单值索引。②唯一索引：索引列的值必须唯一，但允许有空值，主键就是唯一索引。③复合索引：一个索引包含多个列索引的结构：①BTREE索引；②Hash索引；③Full-Text索引；④R-Tree索引。 基本语法①创建索引create [unique] index indexname on tablename(columnname(length)); alter table tablename add index indexname (columnname(length));注：如果是char、varchar类型的字段，length可以小于字段实际长度；如果是blob、text类型，必须指定length。②删除索引drop index indexname on tablename;③查看索引show index from tablename;④其他创建索引的方式 1.添加主键索引ALTER TABLE table_name ADD PRIMARY KEY (column) 2.添加唯一索引ALTER TABLE table_name ADD UNIQUE (column) 3.添加全文索引ALTER TABLE table_name ADD FULLTEXT (column) 4.添加普通索引ALTER TABLE table_name ADD INDEX index_name (column ) 5.添加组合索引ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3) 建立索引与否的具体情况①需建立索引的情况 #1.主键自动建立唯一索引。 #2.频繁作为查询条件的字段。 #3.查询中与其他表关联的字段，外键关系建立索引。 #4.高并发下趋向创建组合索引。 #5.查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。 #6.查询中统计或分组字段。②不需要创建索引的情况 #1.表记录太少。（数据量太少MySQL自己就可以搞定了） #2.经常增删改的表。 #3.数据重复且平均分配的字段，如国籍、性别，不适合创建索引。 #4.频繁更新的字段不适合建立索引。 #5.Where条件里用不到的字段不创建索引。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql orderby优化]]></title>
    <url>%2F2019%2F04%2F23%2Fysql-orderby%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[①MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。②order by满足两种情况会使用Using index。 #1.order by语句使用索引最左前列。 #2.使用where子句与order by子句条件列组合满足索引最左前列。③尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最佳左前缀法则。④如果order by的条件不在索引列上，就会产生Using filesort。⑤提升order by速度的方式： #1.在使用order by时，不要用select *，只查询所需的字段。因为当查询字段过多时，会导致sort_buffer不够，从而使用多路排序或进行多次I/O操作。 #2.尝试提高sort_buffer_size。 #3.尝试提高max_length_for_sort_data。 ⑦group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最佳左前缀法则。当无法使用索引列的时候，也要对sort_buffer_size和max_length_for_sort_data参数进行调整。注意where高于having，能写在where中的限定条件就不要去having限定了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[phpexcel常用函数]]></title>
    <url>%2F2019%2F04%2F23%2Fpexcel%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[// /设置Excel文档单元格内容垂直水平居中/$objActSheet-&gt;getDefaultStyle()-&gt;getAlignment() -&gt;setVertical(\PHPExcel_Style_Alignment::VERTICAL_CENTER) -&gt;setHorizontal(\PHPExcel_Style_Alignment::HORIZONTAL_CENTER);$objActSheet-&gt;getDefaultStyle()-&gt;getFont()-&gt;setSize(12)-&gt;setName(“微软雅黑”);//设置默认字体大小和格式 mergeCells合并单元格 setCellValue设置值]]></content>
  </entry>
  <entry>
    <title><![CDATA[session与cookie在vuethink中的应用]]></title>
    <url>%2F2019%2F04%2F23%2Fession%E4%B8%8Ecookie%E5%9C%A8vuethink%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vuethink初始已经写好了基于session与cookie的用户登录模块用户注册之后再user表中保存了用户的账户与MD5格式的密码：guest c78b6663d47cfbdb4d65ea51c104044e每次用户登录的时候前端将数据发送给login方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public function login($username, $password, $verifyCode = '', $isRemember = false, $type = false) &#123; if (!$username) &#123; $this-&gt;error = '帐号不能为空'; return false; &#125; if (!$password)&#123; $this-&gt;error = '密码不能为空'; return false; &#125; if (config('IDENTIFYING_CODE') &amp;&amp; !$type) &#123; if (!$verifyCode) &#123; $this-&gt;error = '验证码不能为空'; return false; &#125; $captcha = new HonrayVerify(config('captcha')); if (!$captcha-&gt;check($verifyCode)) &#123; $this-&gt;error = '验证码错误'; return false; &#125; &#125; $map['username'] = $username; $userInfo = $this-&gt;where($map) -&gt;find(); if (!$userInfo) &#123; $this-&gt;error = '帐号不存在'; return false; &#125; if (user_md5($password) !== $userInfo['password']) &#123; $this-&gt;error = '密码错误'; return false; &#125; if ($userInfo['status'] === 0) &#123; $this-&gt;error = '帐号已被禁用'; return false; &#125; Db::table('oa_admin_user')-&gt;where(['id' =&gt; $userInfo['id']])-&gt;update(['last_login_time' =&gt; date('Y-m-d H:i:s', time()), 'last_login_ip' =&gt; get_client_ip()]); // 登录成功,添加记录 record(1, array(get_client_ip()), $userInfo['id']); // 获取菜单和权限 $dataList = $this-&gt;getMenuAndRule($userInfo['id']); if (!$dataList['menusList']) &#123; $this-&gt;error = '没有权限'; return false; &#125; if ($isRemember || $type) &#123; $secret['username'] = $username; $secret['password'] = $password; $data['rememberKey'] = encrypt($secret); &#125; // 保存缓存 session_start(); $info['userInfo'] = $userInfo; $info['sessionId'] = session_id(); $authKey = user_md5($userInfo['username'].$userInfo['password'].$info['sessionId']); $info['_AUTH_LIST_'] = $dataList['rulesList']; $info['authKey'] = $authKey; cache('Auth_'.$authKey, null); cache('Auth_'.$authKey, $info, config('LOGIN_SESSION_VALID')); // 返回信息 $data['authKey'] = $authKey; $data['sessionId'] = $info['sessionId']; $data['userInfo'] = $userInfo; $data['authList'] = $dataList['rulesList']; $data['menusList'] = $dataList['menusList']; return $data; &#125; 处理流程1、该方法首先会在数据库验证账户密码，根据账户查找用户md5密码，匹配表单的MD5密码与数据库密码2、如果没有任何问题，session_start(),保存sessionid与authkey3、return session中保存的数据，返还到前端代码，并保存到cookie中前端login.vue1234567891011121314this.apiPost('admin/base/login', data).then((res) =&gt; &#123; if (res.code != 200) &#123; this.loading = !this.loading this.handleError(res) this.refreshVerify() this.form.verifyCode = '' &#125; else &#123; if (this.checked) &#123; Cookies.set('rememberPwd', true, &#123; expires: 1 &#125;) &#125; this.resetCommonData(res.data) _g.toastMsg('success', '登录成功') &#125; &#125;) 4、当用户访问接口的时候，后台控制器写了一个apicommon，每一个控制器都继承了这个类，该类用于验证权限1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php// +----------------------------------------------------------------------// | Description: Api基础类，验证权限// +----------------------------------------------------------------------// | Author: linchuangbin &lt;linchuangbin@honraytech.com&gt;// +----------------------------------------------------------------------namespace app\admin\controller;use think\Request;use think\Db;use app\common\adapter\AuthAdapter;use app\common\controller\Common;class ApiCommon extends Common&#123; public function _initialize() &#123; parent::_initialize(); /*获取头部信息*/ $header = Request::instance()-&gt;header(); $authKey = $header['authkey']; $sessionId = $header['sessionid']; $cache = cache('Auth_'.$authKey); // 校验sessionid和authKey if (empty($sessionId)||empty($authKey)||empty($cache)) &#123; header('Content-Type:application/json; charset=utf-8'); exit(json_encode(['code'=&gt;101, 'error'=&gt;'登录已失效'])); &#125; // 检查账号有效性 $userInfo = $cache['userInfo']; $map['id'] = $userInfo['id']; $map['status'] = 1; if (!Db::name('admin_user')-&gt;where($map)-&gt;value('id')) &#123; header('Content-Type:application/json; charset=utf-8'); exit(json_encode(['code'=&gt;103, 'error'=&gt;'账号已被删除或禁用'])); &#125; // 更新缓存 cache('Auth_'.$authKey, $cache, config('LOGIN_SESSION_VALID')); $authAdapter = new AuthAdapter($authKey); $request = Request::instance(); $ruleName = $request-&gt;module().'-'.$request-&gt;controller() .'-'.$request-&gt;action(); if (!$authAdapter-&gt;checkLogin($ruleName, $cache['userInfo']['id'])) &#123; header('Content-Type:application/json; charset=utf-8'); exit(json_encode(['code'=&gt;102,'error'=&gt;'没有权限'])); &#125; $GLOBALS['userInfo'] = $userInfo; &#125;&#125; 该类会校验sessionid,authkey与cache，任意一个丢失会导致当前登录失效并强制重登，如服务器中session等字段与当前cookie不匹配。session中亦会存储用户的信息，可以用来设置权限，并不用访问数据库中数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuethink 基础配置详解]]></title>
    <url>%2F2019%2F04%2F23%2Fethink-%E6%9D%83%E9%99%90%E5%9D%97%2F</url>
    <content type="text"><![CDATA[原创by殷航最开始的vuethink数据库如下，实现了权限管理，群组，用户信息，系统配置等功能在实际使用中具体用到其中6张表 user表-用户数据 user表存储用户账号，自定义名称，以及一些外键 rule表-定义接口存储菜单名称，接口名称 菜单等级 继承菜单id 使用状态以树结构表示的菜单，此处id标记为rule_idphp config下的基础框架路由配置文件：rule表：规则：1、vuethink中每次在controller中写一个接口都需要到配置文件进行注册，否则超管无法访问。2、一个路由在配置文件中写好了，如果不在rule表注册并分配权限给其他用户的话，只能超管访问（越级）。3、同2，任何一个普通用户都离不开接口权限的赋予 group表-定义用户接口权限group表要用到rule_id，来标识一个用户可以使用接口的权限此处是zl配置好菜单后的权限表，其中：1、超管拥有1-10的菜单，1-10应该是默认的内置权限，菜单的功能处于最底层2、vuethink内置了对这张表的可视化管理界面，可以自行勾选，也可以直接在数据库里改3、后台对rules字段进行explode分割即可，这样存储十分方便4、接口在后台注册，没有权限访问不了url access表-使用权限group表定义了权限，access表为用户id制定哪一种group权限access表与user表的id是一样的，access仅有两个字段，分离两张表是为了系统在查找用户权限的时候速度更快 menu表-后台根菜单如图所示，材料表定义后台左区域菜单路由，即定义：1、菜单名称2、菜单icon3、菜单id4、菜单id之间继承关系5、菜单url如id52是树根，继承52的有系统配置、用户中心、材料管理等继承材料管理的是所有材料 添加材料等 点击菜单显示的内容在route.js中配置并关联vue前台文件 config表-系统设置可以设置logo与名称，以及session过期时间，这同样在vuethink后台中可视化了 总结：access表存储：某个用户 拥有 某个权限（rulename）rule表定义route接口名称，每一个接口有一个接口id 以及层级关系group表定义权限rulename具体是什么，具体的说，就是某一个rulename包含哪些接口id]]></content>
  </entry>
  <entry>
    <title><![CDATA[php生命周期]]></title>
    <url>%2F2019%2F04%2F22%2Fhp%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[https://cloud.tencent.com/developer/article/1028995 PHP的运行模式：PHP两种运行模式是WEB模式、CLI模式。无论哪种模式，PHP工作原理都是一样的，作为一种SAPI运行。1、当我们在终端敲入php这个命令的时候，它使用的是CLI。它就像一个web服务器一样来支持php完成这个请求，请求完成后再重新把控制权交给终端。2、当使用Apache或者别web服务器作为宿主时，当一个请求到来时，PHP会来支持完成这个请求。一般有：多进程(通常编译为apache的模块来处理PHP请求)多线程模式 一切的开始: SAPI接口通常我们编写php Web程序都是通过Apache或者Nginx这类Web服务器来测试脚本. 或者在命令行下通过php程序来执行PHP脚本. 执行完成脚本后，服务器应答，浏览器显示应答信息,或者在命令结束后在标准输出显示内容. 我们很少关心PHP解释器在哪里. 虽然通过Web服务器和命令行程序执行脚本看起来很不一样. 实际上她们的工作是一样的. 命令行程序和Web程序类似, 命令行参数传递给要执行的脚本,相当于通过url 请求一个PHP页面. 脚本戳里完成后返回响应结果,只不过命令行响应的结果是显示在终端上. 脚本执行的开始都是通过SAPI接口进行的. 启动apache当给定的SAPI启动时，例如在对/usr/local/apache/bin/apachectl start的响应中，PHP由初始化其内核子系统开始。在接近启动例程的末尾，它加载每个扩展的代码并调用其模块初始化例程（MINIT）。这使得每个扩展可以初始化内部变量、分配资源、注册资源处理器，以及向ZE注册自己的函数，以便于脚本调用这其中的函数时候ZE知道执行哪些代码。 请求处理初始化接下来，PHP等待SAPI层请求要处理的页面。对于CGI或CLI等SAPI，这将立刻发生且只发生一次。对于Apache、IIS或其他成熟的web服务器SAPI，每次远程用户请求页面时都将发生，因此重复很多次，也可能并发。不管请求如何产生，PHP开始于要求ZE建立脚本的运行环境，然后调用每个扩展的请求初始化 （RINIT）函数。RINIT使得扩展有机会设定特定的环境变量，根据请求分配资源，或者执行其他任务，如审核。 session扩展中有个RINIT作用的典型示例，如果启用了session.auto_start选项，RINIT将自动触发用户空间的session_start()函数以及预组装$_SESSION变量。 执行php代码一旦请求被初始化了，ZE开始接管控制权，将PHP脚本翻译成符号，最终形成操作码并逐步运行之。如任一操作码需要调用扩展的函数，ZE将会把参数绑定到该函数，并且临时交出控制权直到函数运行结束。 脚本结束脚本运行结束后，PHP调用每个扩展的请求关闭（RSHUTDOWN）函数以执行最后的清理工作（如将session变量存入磁盘）。接下来，ZE执行清理过程（垃圾收集）－有效地对之前的请求期间用到的每个变量执行unset()。 sapi关闭一旦完成，PHP继续等待SAPI的其他文档请求或者是关闭信号。对于CGI和CLI等SAPI，没有“下一个请求”，所以SAPI立刻开始关闭。关闭期间，PHP再次遍历每个扩展，调用其模块关闭（MSHUTDOWN）函数，并最终关闭自己的内核子系统。 简要的过程 PHP是随着Apache的启动而运行的； PHP通过mod_php5.so模块和Apache相连（具体说来是SAPI，即服务器应用程序编程接口）； PHP总共有三个模块：内核、Zend引擎、以及扩展层； PHP内核用来处理请求、文件流、错误处理等相关操作； Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它； 扩展层是一组函数、类库和流，PHP使用它们来执行一些特定的操作。比如，我们需要mysql扩展来连接MySQL数据库； 当ZE执行程序时可能会需要连接若干扩展，这时ZE将控制权交给扩展，等处理完特定任务后再返还； 最后，ZE将程序运行结果返回给PHP内核，它再将结果传送给SAPI层，最终输出到浏览器上。 php开始的两个过程第一个过程：apache启动的过程，即在任何请求到达之前就发生。是在整个SAPI生命周期内(例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中)的开始阶段(MINIT),该阶段只进行一次.。启动Apache后，PHP解释程序也随之启动； PHP调用各个扩展（模块）的MINIT方法，从而使这些扩展切换到可用状态。看看php.ini文件里打开了哪些扩展吧； MINIT的意思是“模块初始化”。各个模块都定义了一组函数、类库等用以处理其他请求。 模块在这个阶段可以进行一些初始化工作,例如注册常量, 定义模块使用的类等等.典型的的模块回调函数MINIT方法如下： PHP_MINIT_FUNCTION(myphpextension) {/* Initialize functions, classes etc */} { // 注册常量或者类等初始化操作 returnSUCCESS; } 第二个过程发生在请求阶段,当一个页面请求发生时.则在每次请求之前都会进行初始化过程(RINIT请求开始).请求到达之后，SAPI层将控制权交给PHP层，PHP初始化本次请求执行脚本所需的环境变量,例如创建一个执行环境,包括保存php运行过程中变量名称和变量值内容的符号表. 以及当前所有的函数以及类等信息的符号表.例如是Session模块的RINIT，如果在php.ini中启用了Session 模块，那在调用该模块的RINIT时就会初始化$_SESSION变量，并将相关内容读入；然后PHP会调用所有模块RINIT函数,即“请求初始化”。在这个阶段各个模块也可以执行一些相关的操作, 模块的RINIT函数和MINIT函数类似 ，RINIT方法可以看作是一个准备过程，在程序执行之间就会自动启动。 php结束的两个环节第一个环节：请求处理完后结束阶段：请求处理完后就进入了结束阶段，PHP就会启动清理程序。它会按顺序调用各个模块的RSHUTDOWN方法。 RSHUTDOWN用以清除程序运行时产生的符号表，也就是对每个变量调用unset函数。典型的RSHUTDOWN方法如下： PHP_RSHUTDOWN_FUNCTION(myphpextension) { // 例如记录请求结束时间, 并把相应的信息写入到日至文件中. returnSUCCESS; } 第二个环节：最后，所有的请求都已处理完毕，SAPI也准备关闭了， PHP调用每个扩展的MSHUTDOWN方法，这是各个模块最后一次释放内存的机会。（这个是对于CGI和CLI等SAPI，没有“下一个请求”，所以SAPI立刻开始关闭。）典型的RSHUTDOWN方法如下： PHP_MSHUTDOWN_FUNCTION(extension_name) { /* Free handlers and persistent memory etc */ return SUCCESS; } 这样，整个PHP生命周期就结束了。要注意的是，只有在服务器没有请求的情况下才会执行“启动第一步”和“关闭第二步”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[php hashtable]]></title>
    <url>%2F2019%2F04%2F22%2Fhp-hashtable%2F</url>
    <content type="text"><![CDATA[php中键值对的映射是用hashtable实现的https://blog.csdn.net/xiaolei1982/article/details/52292866 hashtable原理1、字符串的键先会被传递给一个hash函数（散列函数）2、这个函数会返回一个整数（我们把它叫做hash值），而这个整数就是“通常”的数组的索引。问题是对于两个不同的字符串，调用hash函数会得到同一个hash值，而现实情况是任意字符串都可以作为键，所以键会有无数个，而数组的大小必须是提前设定好的，因为hash值必须小于数组索引的最大值，所以可以生成的hash值必须是有限的。这样用有限的hash值表示无限的键，必然会导致冲突。我们把两个不同的键的hash值是一样的情况称为冲突，任何Hashtable算法都必须提供某种机制解决这种冲突。 解决hash值冲突的办法1、开放定址法当冲突发生的时候，冲突的元素会被保存到一个不同的索引中；2、链接法所有拥有相同的hash值的元素，它们都会被保存到一个链表中。PHP使用的就是第二种方法。http://www.phpinternalsbook.com/hashtables/basic_structure.html该方法仅将具有相同散列的所有元素存储在链表中。当查找密钥时，PHP将计算哈希值，然后浏览“可能”值的链接列表，直到找到匹配的条目。以下是链接冲突解决方案的说明（旧）： 考虑如何从这样的结构中删除元素：假设你有一个指向桶的指针”c”并想要删除它。要做到这一点你必须设置指针来自何处”a”来NULL。因此，您需要”a”通过遍历哈希值的链接列表或者反向存储指针来检索您可以执行的存储桶。后者就是PHP所做的：每个桶都包含指向下一个bucket（pNext）和前一个bucket（）的指针pLast。如下图所示： 此外，PHP哈希表是有序的：如果遍历一个数组，你将获得插入它们的顺序相同的元素。为了支持这一点，存储桶必须是指定顺序的另一个链表的一部分。由于与上述相同的原因（并以相反的顺序支持遍历），这又是一个双重链表。前向指针存储在pListNext后向指针中pListLast。另外，哈希表结构有一个指向list（pListHead）开头和list（）结尾的指针pListLast。下面是这个链表可能看起来怎么样的元素的例子”a”，”b”，”c”（按顺序）： 老版hashtable结构低效1、Bukets需要分开分配。内存分配总是低效的，而且每次还额外需要分配8/16个字节，这是内存分配的冗余。分开分配也意味着这些buckets会分布在内存空间的不同地址中，这又会降低缓存的效率（可以去了解下缓存的局部性原理，下面还会提到，这篇文章说的缓存基本都是指CPU缓存）。2、Zvals也需要分开分配。上面已经说明这种方式很低效，它也会产生一些额外的头开销冗余（header overhead）。另外这需要在每个bucket中保存一个指向zval结构的指针，由于老的实现过于考虑通用性，所以不止需要一个指针，而是两个指针。3、双向链表中的每个bucket需要4个指针用于链表的连接，这会带来16/32个字节的开销，遍历这种链表也不利于缓存（cache-unfriendly）操作。 新的zval实现新的zval结构的定义如下：123456789101112131415161718192021struct _zval_struct &#123; zend_value value; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved ) &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ &#125; u2;&#125;; zval结构有三个部分：一、8个字节的valuezend_value可以保存任何类型的值，包括整数、字符串、数组等。具体保存什么取决于zval的类型。二、4字节的type_info它包含变量的真正类型（类似于IS_STRING、IS_ARRAY），以及一系列的标志位，用于提供跟类型相关的信息。例如，如果zval保存的是一个对象，那么这些类型标志位会说明它是一个非常量（non-constant）、可引用计数（refcounted）、可垃圾回收（garbage-collectible）、不可复制（non-copying）的类型。三、最后部分占有4个字节，通常情况下不会被用到（它只是用于填充内存，如果不存在的话，编译器也会自动实现）（可以搜索内存对齐）。然而，在某些特殊情况下，这些空间也会被用于存放一些额外的信息。例如，AST（抽象语法树）的节点使用它来存放行号，VM（虚拟机）常量使用它来存放缓冲槽的索引，以及Hashtable使用它来保存冲突处理链上的下一个元素——这一部分才是我们要重点关注的。 新的zval的实现跟老的比较，最大的一点差别是：没有refcount字段。这是因为新的zval将不会被单独分配，它会被直接嵌入到任何需要存放它的地方（例如，一个hashtable bucket中）。所以zvals将不再需要使用引用计数（refcounting），复杂数据类型例如字符串、数组、对象和资源（resources）仍需要使用。所以新的zval的设计将引用计数（包括跟垃圾回收相关的信息）从zval转移到了数组/对象/等中。这种方式有很多优点，在此列出几点：1、保存简单的值（例如，boolean、integer或者float）的zval将不再需要额外分配内存。所以避免内存分配的头部冗余（allocation header overhead），以及减少不必要的内存分配和内存释放，可以提高缓存的局部性，从而提高性能。2、保存简单的值的zval不需要保存refcount和GC的根缓冲区。3、避免两次引用计数。例如，以前的对象即使用了zval的引用计数，又使用额外的对象的引用计数，对于支持按对象传递的语义而言，这是必须的。 现在所有的复杂的值都内嵌一个引用计数，它们可以不依赖于zval的机制而进行共享。特别是字符串现在也有可能共享。这对于hashtable的实现也很重要，因为这样就不用再拷贝非interned字符串的键了。 bucket结构体：12345typedef struct _Bucket &#123; zend_ulong h; zend_string *key; zval val;&#125; Bucket; 待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[php 底层探究]]></title>
    <url>%2F2019%2F04%2F22%2Fp-hashtable%2F</url>
    <content type="text"><![CDATA[Zend hash tablehashtable有键值对形式的散列结构，也有双向链表模式 散列结构1、zend 散列结构为hash表，通过链表方式来解决冲突2、自增数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重置原始位置，初始大小为83、以nkeylength标识key长度来作快速判定（空间换时间） 双向链表双向链表结构主要目的是实现快速删除，避免遍历 php关联数组12345678910getKeyHashValue h; index = n &amp; nTableMask; Bucket *p = arBucket[index]; while (p) &#123; if ((p-&gt;h == h) &amp; (p-&gt;nKeyLength == nKeyLength))&#123; RETURN p-&gt;data; &#125; p=p-&gt;next; &#125;RETURN FALTURE; php索引数组索引数组就是我们常见的数组，通过下标访问。Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。 php变量zvalPHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量，其数据结构如下： Zval主要由三部分组成：type：指定了变量所述的类型（整数、字符串、数组等）refcount&amp;is_ref：用来实现引用计数(后面具体介绍)value：核心部分，存储了变量的实际数据Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。 引用计数引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。 在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。 如果共享变量其中的一个变量被改变当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离” 对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。 整数和浮点数整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。 如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。 字符和字符串在PHP中，字符串是由指向实际数据的指针和长度结构体组成和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中，求字符串长度strlen是O(1)操作。在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加\0。假设有如下4个变量：1234$strA = '123';$strB = '456';$intA = 123;$intB = 456; 现在对如下的几种字符串拼接方式做一个比较和说明：12345678910111213// 下面两张情况，zend会重新malloc一块内存并进行相应处理，其速度一般$res = $strA . $strB$res = "$strA$strB"// 这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝$strA = $strA . $strB// 这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免$res = $intA . $intB// 这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，// 本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。// 不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。$strA = sprintf ("%s%s", $strA . $strB); 数组PHP的数组通过Zend HashTable来天然实现。foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用HashTable-&gt;NumOfElements，O(1)操作。对于 ‘123’ 这样的字符串，zend会转换为其整数形式。$arr[‘123’]和$arr[123]是等价的。 资源资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。如何使用资源：注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。获取一个资源变量：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分。 变量作用域PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。 函数中使用全局变量在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用，如果symbol_table中没有同名变量则会先创建。]]></content>
  </entry>
  <entry>
    <title><![CDATA[php单例封装redis]]></title>
    <url>%2F2019%2F04%2F22%2Fhp%E5%8D%95%E4%BE%8B%E5%B0%81%E8%A3%85redis%2F</url>
    <content type="text"><![CDATA[三私一公私有静态属性私有构造方法私有克隆方法公有静态方法1234567891011121314151617181920212223242526&lt;?phpclass Handle &#123; private $handle = NULL; private static $_instance = NULL; //定义私有的属性变量 public static function getInstance() &#123; //定义公用的静态方法 if (NULL == self::$_instance) &#123; self::$_instance = new self; &#125; return self::$_instance; &#125; public function __construct() &#123; $redis = new Redis(); //实例化redis $redis-&gt;connect('127.0.0.1',6379); //$redis-&gt;auth(Conf::AUTH); $this-&gt;handle = &amp;$redis; //将变量与redis通过引用符关联在一起，以后直接使用handle即可，相当于将redis付给一个变量，这是另一种写法 &#125; public function __destruct() &#123; $this-&gt;handle-&gt;close(); &#125; public function hget($k,$v) &#123; return $this-&gt;handle-&gt;hget($k , $v); //获取redis键名 &#125;&#125;$test = Handle::getInstance();echo $test-&gt;hget(1,1);]]></content>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2019%2F04%2F19%2Ftp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持GET和POST，Spring 3.0提供了一个HiddenHttpMethodFilter，允许你通过“_method”的表单参数指定这些特殊的HTTP方法（实际上还是通过POST提交表单）。服务端配置了HiddenHttpMethodFilter后，Spring会根据_method参数指定的值模拟出相应的HTTP方法，这样，就可以使用这些HTTP方法对处理方法进行映射了。 ②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL，③是协议名称及版本号。 ④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。 ⑤是报文体，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。 对照上面的请求报文，我们把它进一步分解，你可以看到一幅更详细的结构图： 请求头Accept 请求报文可通过一个“Accept”报文头属性告诉服务端 客户端接受什么类型的响应。 如下报文头相当于告诉服务端，俺客户端能够接受的响应类型仅为纯文本数据啊，你丫别发其它什么图片啊，视频啊过来，那样我会歇菜的~~~： Cookie 客户端的Cookie就是通过这个报文头属性传给服务端的哦！如下所示：Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23BE13C4C 服务端是怎么知道客户端的多个请求是隶属于一个Session呢？注意到后台的那个jsessionid=5F4771183629C9834F8382E23BE13C4C木有？原来就是通过HTTP请求报文头的Cookie属性的jsessionid的值关联起来的！（当然也可以通过重写URL的方式将会话ID附带在每个URL的后面哦）。 Referer 表示这个请求是从哪个URL过来的，假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是http://www.google.com。 Cache-Control 对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。 php如何访问请求报文头 HTTP响应报文解剖 HTTP的响应报文也由三部分组成（响应行+响应头+响应体）： 响应状态码 和请求报文相比，响应报文多了一个“响应状态码”，它以“清晰明确”的语言告诉客户端本次请求的处理结果。 HTTP的响应状态码由5段组成： 1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急…2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。 常见的HTTP响应报文头属性 Cache-Control 响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 下面，的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。 ETag 一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。 关于ETag的说明，你可以参见：http://en.wikipedia.org/wiki/HTTP_ETag。Spring 3.0还专门为此提供了一个org.springframework.web.filter.ShallowEtagHeaderFilter（实现原理很简单，对JSP输出的内容MD5，这样内容有变化ETag就相应变化了），用于生成响应的ETag，因为这东东确实可以帮助减少请求和响应的交互。 Location 我们在JSP中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中： Set-Cookie 服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的：]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2019%2F04%2F19%2FTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[跨域浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了. 同源策略请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.比如:我在本地上的域名是study.cn,请求另外一个域名一段数据，这个时候在浏览器上会报错 p($header)每次请求打印出来的头部： Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。如需允许所有资源都可以访问您的资源，您可以如此设置：1Access-Control-Allow-Origin: * 如需允许https://developer.mozilla.org访问您的资源，您可以设置：1Access-Control-Allow-Origin: https://developer.mozilla.org zl的origin为http://localhost:8080 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Allow-Methods响应首部 Access-Control-Allow-Methods 在对 preflight request.（预检请求）的应答中明确了客户端所要访问的资源允许使用的方法或方法列表。 Access-Control-Allow-Headers预检请求,列出了将会在正式请求的 Access-Control-Expose-Headers 字段中出现的首部信息。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
        <tag>微派</tag>
        <tag>难点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI]]></title>
    <url>%2F2019%2F04%2F18%2FSI%2F</url>
    <content type="text"><![CDATA[物理层数据链路层网络层传输层会话层表示层应用层 应用层 OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。 网际控制报文协议DHCP处于应用层 表示层 表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 会话层 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 传输层 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。 网络层 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。 数据链路层 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。 物理层 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。 TCP/IP模型 地址解析协议ARP完成IP地址到MAC地址的映射 即询问目标IP对应的MAC地址 逆地址解析协议RARP完成MAC地址到IP地址的映射 域名解析DNS完成域名到ip地址映射，使用udp传输 在浏览器中输入www.baidu.com后执行的全部过程1、客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[tcp/udp]]></title>
    <url>%2F2019%2F04%2F18%2Fp-udp%2F</url>
    <content type="text"><![CDATA[面向连接与无连接TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 数据可靠性TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付 Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 速度UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 tcp连接一对一每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 占用资源TCP对系统资源要求较多，UDP对系统资源要求较少。 TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP对系统资源要求较多，UDP对系统资源要求较少。 为什么UDP有时比TCP更有优势?UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 TCP与UDP的适用场景TCP：对数据传输的质量有较高要求，但对实时性要求不高。比如HTTP，HTTPS，FTP等传输文件的协议以及POP，SMTP等邮件传输的协议，应选用TCP协议。 UDP：只对数据传输的实时性要求较高，但不对传输质量有要求。比如视频传输、实时通信等，应选用UDP协议。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql事务]]></title>
    <url>%2F2019%2F04%2F17%2Fysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是事务事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。 pass:脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 幻读的重点在于新增或者删除. 脏读：数据读错方只读了一次数据库。不可重复读：数据读错方读了两次数据库 pass：不可重复读与幻读的本质区别不可重复读是读取了其他事务更改的数据，针对update操作解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。 幻读是读取了其他事务新增的数据，针对insert操作解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。 事务并发会产生什么问题 提醒：不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样 事务隔离级别，解决什么并发问题，以及存在什么并发问题（1）READ_UNCOMMITTED（读未提交） 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。 解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。（2）READ_COMMITTED（读已提交） 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。 解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题（3）REPEATABLE_READ（重复读） 保证一个事务相同条件下前后两次获取的数据是一致的 解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。（4）SERIALIZABLE（串行化） 事务被处理为顺序执行。 解决所有问题提醒：Mysql默认的事务隔离级别为repeatable_read]]></content>
      <tags>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redo&undo]]></title>
    <url>%2F2019%2F04%2F17%2Fo-undo%2F</url>
    <content type="text"><![CDATA[redo（重做）保障了数据库的持久性undo（撤销）保障了数据库的原子性 当数据库系统崩溃后，如何恢复？ 两个原则从前向后读取redo，重做所有已提交的事务从后往前读取undo，回滚未提交的事务 Undo + Redo事务的简化过程A.事务开始.B.记录A=1到undo log.C.修改A=3.D.记录A=3到redo log.E.记录B=2到undo log.F.修改B=4.G.记录B=4到redo log.H.将redo log写入磁盘。I.事务提交]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快排123456789101112131415161718192021222324252627&lt;?php//快速排序//待排序数组$arr=array(6,3,8,6,4,2,9,5,1);//函数实现快速排序function quick_sort($arr)&#123; //递归出口:数组长度为1，直接返回数组 $length=count($arr); if($length&lt;=1) return $arr; $left=$right=array(); for($i=1;$i&lt;$length;$i++)&#123; if($arr[$i]&lt;$arr[0])&#123; //第一次排序，left为小于6的所有数 $left[] = $arr[$i]; &#125;else&#123; //right为大于6的所有数 $right[] = $arr[$i]; &#125; &#125; $left = quick_sort($left); $right = quick_sort($right); return array_merge($left,array($arr[0]),$right); &#125; //调用 echo "&lt;pre&gt;"; print_r(quick_sort($arr)); 插排1234567891011121314151617181920212223&lt;?php $arr = [2, 3, 1, 6, 4, 7, 5, 9]; var_dump(insertsort($arr)); function insertSort($arr) &#123; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; // 当前值 $key = $arr[$i]; // 当前位置 $pos = $i; // 如是当前位置 &gt;0 &amp;&amp; 当前值的前一个值 &gt; 当前值 选出最值 while ($pos &gt; 0 &amp;&amp; $arr[$pos - 1] &gt; $key) &#123; // 当前值 = 前一个值 $arr[$pos] = $arr[$pos - 1]; // 当前位置后移 $pos = $pos - 1; &#125; // 找到当前值的位置 $arr[$pos] = $key; &#125; return $arr; &#125; 冒泡排序12345678910111213141516171819202122&lt;?php// 冒泡排序function PrintMinNumber($numbers)&#123; $length = count($numbers); if($length == 0)&#123; return ''; &#125; for($i=0;$i &lt; $length-1;$i++)&#123; for($j = $i;$j &lt; $length;$j++)&#123; if($numbers[$i].$numbers[$j] &gt; $numbers[$j].$numbers[$i])&#123; $temp = $numbers[$i]; $numbers[$i] = $numbers[$j]; $numbers[$j] = $temp; &#125; &#125; &#125; $a = implode('',$numbers); return $a;&#125;$arr = [32,3,321];PrintMinNumber($arr); 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*** mergeSort 归并排序* 是开始递归函数的一个驱动函数* @param &amp;$arr array 待排序的数组*/function mergeSort(&amp;$arr) &#123; $len = count($arr);//求得数组长度 mSort($arr, 0, $len-1);&#125;/*** 实际实现归并排序的程序* @param &amp;$arr array 需要排序的数组* @param $left int 子序列的左下标值* @param $right int 子序列的右下标值*/function mSort(&amp;$arr, $left, $right) &#123; if($left &lt; $right) &#123; //说明子序列内存在多余1个的元素，那么需要拆分，分别排序，合并 //计算拆分的位置，长度/2 去整 $center = floor(($left+$right) / 2); //递归调用对左边进行再次排序： mSort($arr, $left, $center); //递归调用对右边进行再次排序 mSort($arr, $center+1, $right); //合并排序结果 mergeArray($arr, $left, $center, $right); &#125;&#125; /*** 将两个有序数组合并成一个有序数组* @param &amp;$arr, 待排序的所有元素* @param $left, 排序子数组A的开始下标* @param $center, 排序子数组A与排序子数组B的中间下标，也就是数组A的结束下标* @param $right, 排序子数组B的结束下标（开始为$center+1)*/function mergeArray(&amp;$arr, $left, $center, $right) &#123; //设置两个起始位置标记 $a_i = $left; $b_i = $center+1; while($a_i&lt;=$center &amp;&amp; $b_i&lt;=$right) &#123; //当数组A和数组B都没有越界时 if($arr[$a_i] &lt; $arr[$b_i]) &#123; $temp[] = $arr[$a_i++]; &#125; else &#123; $temp[] = $arr[$b_i++]; &#125; &#125; //判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内： while($a_i &lt;= $center) &#123; $temp[] = $arr[$a_i++]; &#125; //判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内： while($b_i &lt;= $right) &#123; $temp[] = $arr[$b_i++]; &#125; //将$arrC内排序好的部分，写入到$arr内： for($i=0, $len=count($temp); $i&lt;$len; $i++) &#123; $arr[$left+$i] = $temp[$i]; &#125; &#125; //do some test:$arr = array(4, 7, 6, 3, 9, 5, 8);mergeSort($arr);print_r($arr); 1234567891011121314151617181920212223242526$arr=array(1,2,3,5,2,3,9,8,3,2,7,4,9,8,0,4,587,93,47,59,8,2,6,83,4,9,65,2,18,7);printArr($arr);echo "&lt;hr&gt;";function merge_sort(&amp;$arr)&#123; $len=count($arr); if($len==1) return $arr; $middle=intval($len/2); $left=array_slice($arr,0,$middle); $right=array_slice($arr,$middle); merge_sort($left); merge_sort($right); $arr=merge($left,$right);&#125;function merge($leftarr,$rightarr)&#123; $arrmerge=array(); while(count($leftarr) &amp;&amp; count($rightarr)) $arrmerge[]=$leftarr[0]&lt;$rightarr[0]?array_shift($leftarr):array_shift($rightarr); return array_merge($arrmerge,$leftarr,$rightarr);&#125;merge_sort($arr);printArr($arr);function printArr($arr)&#123; for($i=0;$i&lt;count($arr);$i++) echo ' '.$arr[$i];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[isnull empty isset]]></title>
    <url>%2F2019%2F04%2F16%2Fitled%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132&lt;?php$a = ['null'];print_r(isset($a)) ;echo "\n";print_r(empty($a));echo "\n";print_r(is_null($a));// isset empty isnull//a=null 0 1 1//a=0 1 1 0//a=false 1 1 0//a="" 1 1 0//a="0" 1 1 0//a=[] 1 1 0//a=1 1 0 0//a="null" 1 0 0//$a = ['null']; 1 0 0//不定义 0 1 wrong&amp;1//$a=null;unset($a);0 1 wrong&amp;1//$a='1';unset($a); 0 1 wrong&amp;1//wrong&amp;1://Undefined variable: a//1//只有a=null或不定义a isest为0//只有a=1(not0)或a="有东西，null也算"(数组规则一样) empty为0//is_null判断null 只有当a=null时才为1，当变量不存在时会报错并报1，其他都为false//isset 判断存在 当a被赋值（除a=null） isset就为true 表示变量存在，不判断变量含义，含义空亦true//empty 判断空 仅当a被赋值并且变量含义不为空 empty($var)才为false 其他都是true]]></content>
  </entry>
  <entry>
    <title><![CDATA[测开基础]]></title>
    <url>%2F2019%2F04%2F15%2Fhp%E5%BA%95%E5%B1%82%2F</url>
    <content type="text"><![CDATA[一、Linux必备知识linux作为现在最流行的软件环境系统，一定需要掌握，目前的招聘要求都需要有linux能力。 二、Shell脚本掌握shell脚本，包括shell基础与应用、shell逻辑控制、shell逻辑函数等。 三、互联网程序原理自动化必由之路：前端开发基础知识以及互联网网络必备知识。 四、Mysql数据库软件测试工程师必备Mysql数据库知识，不仅仅停留在基本的“增删改查”。 五、抓包工具Fiddler、Wireshark、Sniffer、Tcpdump各种抓包工具适用于各种项目，总有一款适合你。 六、接口测试工具接口测试神器，你绕不开的强大工具：Jmeter。小巧灵活：Postman。 七、Web自动化测试Java&amp;Pyhton了解自动化的目的，熟练掌握testng&amp;unittest自动化框架，以及断言与日志处理。 八、接口与手机自动化专业接口调用、测试解决方案。组建完整的web和接口自动化框架，Appium整体使用 九、敏捷测试&amp;TestOps构建揭开TestOps的神秘面纱，持续集成Jenkins框架烂熟于心。 十、性能测试&amp;安全测试软件测试的彼岸：性能测试和安全测试，选对方向，努力爬坑吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[php基础]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%A1%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?php /** * 三元运算符的应用 *//*$a = 10;$b = 15;echo $a &gt; $b ? 1 : 0;*///注:php7新添加的运算符比较运算符x&lt;=&gt;y//如果x和y相等,就返回0,如果x&gt;y,就返回1,如果x的值小于y,就返回-1 /*$a = "aaa";$b = "bbb";echo $a.$b;*/ /** * 预定义常量 */ /*class a&#123; function showname()&#123; echo __METHOD__; echo "&lt;hr&gt;"; echo __FUNCTION__; echo "&lt;hr&gt;"; echo __CLASS__; echo __FILE__; echo __DIR__; &#125;&#125;$b = new a();$b-&gt;showname();*/ /** * switch分支语句 */ /*switch (2)&#123; case 1: echo "11"; break; case 2: echo "12"; break; default : echo "13"; break;&#125;*/ /** * while循环 * 需要注意,while循环必须进行变量初始化 */ /*$i = 1;while ($i &lt;= 10) &#123; echo $i." "; $i++;&#125;*/ /** * do while循环 *//*$i = 0;do&#123; $i++; echo $i." ";&#125;while($i&lt;10);*/ /** * 跳转语句之goto (还有break,continue) * goto * goto a直接跳到a 中间部分的代码不执行 */ /*goto a;echo 'kkk';echo '123';a:echo 'bbb';echo '525';*///此部分代码浏览器显示为//bbb525 /** * goto跳转语句 */ /*for($i = 0; $i &lt; 10; $i++) &#123; if($i == 3)&#123; goto a; &#125; echo $i;&#125;a:echo "跳出循环";*///浏览器显示为//012跳出循环 引用传递1234567891011121314 /** * *//*function test(&amp;$a) &#123; $a = $a + 1; return $a;&#125;$x = 1;echo test($x);//2echo "&lt;hr&gt;";echo $x;//2*/ 函数参数与匿名函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 函数的默认参数 * 为了避免意外情况发生,一般,默认参数放在非默认参数的右侧 *//*function aa($a = 2, $b)&#123; echo $a+$b;&#125;aa(3,5);//浏览器显示8//这里,如果调用时aa(3)只给了一个参数,则会报错*/ /** * 可变参数变量 * 参数可包含'...'来表示函数可接受一个可变数量的参数 * 可变参数将会被当做一个数组传递给函数 *//*function test(...$num)&#123; $sum = 0; foreach ($num as $k=&gt;$value)&#123; $sum += $value; &#125; return $sum;&#125;echo test(1,3,4,5);//结果1+3+4+5 = 13*/ /** * return跳转语句 * return 本身只能返回一个值,不能返回数组,我们通过这种方法来实现返回数组,并在调用时用list接收 * return之后的代码不在执行,这里,echo "111"代码执行不了,所以浏览器只返回了28 11 *//*function aak($a,$b)&#123; $sum = $a * $b; $sum2 = $a + $b; return array($sum,$sum2);&#125;list($a1,$a2) = aak(4,7);echo $a1." ".$a2;//浏览器显示 28 11*/ /** * 使用get_loaded_extensions 我们来查看一下现在的php程序加载了哪些拓展 *///var_dump(get_loaded_extensions()); /** * 匿名函数(也叫闭包函数) * 允许临时创建一个没有指定名称的函数,经常用作回调函数(callback)参数的值 * 闭包函数也可以作为变量的值来使用(比如此例) *//*$greet = function ($name)&#123; echo "hello,$name";&#125;;$greet('xiaobudiu'); //浏览器显示 hello,xiaobudiu*/ /** * 递归思想 * 斐波那契数列 * 1,1,2,3,5,8... *$n表示第几个数 *//*function compute($n) &#123; if ($n &gt; 2) &#123; $arr[$n] = compute($n - 1) + compute($n - 2); return $arr[$n]; &#125;else&#123; return 1; &#125;&#125;echo compute(5);*/ /** * 迭代思想 * 利用变量的原值推算出变量的一个新值 *//*function diedai($n)&#123; for ($i = 0 , $j = 0; $i &lt; $n; $i++) &#123; $j = $i + $j; &#125; return $j;&#125;echo diedai(50);*/ /** * 单引号和双引号 *//*$str = "i dont't want to go shoping";echo ucwords($str);*/ 字符串函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 /** * 字符串替换 *str_ireplace();str_replace() *//*$str = "hello,world,hello,world";//echo str_replace('or','dd',$str);$replace = 'hi';echo substr_replace($str,$replace,0,7);//将第0到第7个字符替换成$replace字符//浏览器显示hiorld,hello,world*/ /** * * 截取字符串 *//*$str = 'abcdefg';echo substr($str,0,4);//浏览器显示:abcd*/ /** * 去掉字符串首尾特殊字符 * trim();ltrim();rtrim() *//*$str = ' .abcded .gk.';echo $str;echo "&lt;hr&gt;";$str = trim($str);echo $str;//.abcded .gk.(空格去掉了)echo '&lt;hr&gt;';$str = ltrim($str,'.');//abcded .gk.(左边的点被去掉了)echo $str;echo '&lt;hr&gt;';$str = rtrim($str,'.');//（右侧的点被去掉了）echo $str;*/ /** * str_replace() *//*$str = 'hello,world,d,hello,world,ef';//要求把第二个hello替换成hiecho str_replace('hello','hi',$str);*///str_replace()单独实现不了替换限制次数的需求,要替换,都替换,无法替换单独一个 /** * 对字符串执行指定次数替换 * @param Mixed $search 查找目标值 * @param Mixed $replace 替换值 * @param Mixed $subject 执行替换的字符串／数组 * @param Int $limit 允许替换的次数，默认为-1，不限次数 * @return Mixed *//*function str_replace_limit($search, $replace, $subject, $limit=-1)&#123; if (is_array($search)) &#123; foreach ($search as $k=&gt;$v) &#123; $search[$k] = '`'. preg_quote($search[$k], '`'). '`'; &#125; &#125; else &#123; $search = '`'. preg_quote($search, '`'). '`'; &#125; return preg_replace($search, $replace, $subject, $limit);&#125;$str = "abccddefccggcccg";echo str_replace_limit('cc','c',$str,2);echo '&lt;hr&gt;';*///浏览器显示:abcddefcggcccg(前两个cc都被替换了,最后一个ccc没有被替换) /** * 截取字符串 * substr *//*$str = "abcdefghijklmn";echo substr($str,-4,2);//kl*/ /* * 计算字符串长度 * str_len *//*$str = "abcdefghijklmn我";echo strlen($str);//17 (中文3个字符,英文1个字符)*/ /** * 转义和还原字符串 * 转义:addslashes() 还原:stripslashes * 两个参数 第一个参数字符串,第二个参数要进行转义的字符 *//*$str = "I Don't wang to go shopping..";$str = ucwords($str);echo $str;//I Don't Wang To Go Shopping..echo "&lt;hr&gt;";//$str = addslashes($str);$str = addcslashes($str,'.');echo $str;//I Don't Wang To Go Shopping\.\.*/ /** * 重复字符串 * str_repeat *//*$str = 'abcd';echo str_repeat($str,2);*/ /** * 随机打乱字符串 * str_shuffle() *//*$str = "abcdefghijklmn";echo str_shuffle($str);*/ /** * 分割字符串 * explode() *//*$str = "piece1,piece2,piece3";$str = explode(',',$str);var_dump($str); //array(3) &#123; [0]=&gt; string(6) "piece1" [1]=&gt; string(6) "piece2" [2]=&gt; string(6) "piece3" &#125;echo "&lt;hr&gt;";$str = implode('-',$str);echo $str; //piece1-piece2-piece3*/ 数组函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342 /** * 创建一个指定范围的数组 * range() 第三个参数step 步进值 *//*$arr = range('0','9',2);var_dump($arr); //array(5) &#123; [0]=&gt; int(0) [1]=&gt; int(2) [2]=&gt; int(4) [3]=&gt; int(6) [4]=&gt; int(8) &#125;*/ /** * 检查数组中是否存在某个值 * in_array *//*$arr = [ 'beijing', 'shanghai', 'hangzhou', 'shenzhen'];var_dump(in_array('hangzhou',$arr));//bool(true)*/ /** * 数组转换成字符串 * implode() *//*$arr = [ 'beijing', 'shanghai', 'hangzhou', 'shenzhen'];$arr = implode('-',$arr);echo $arr; // beijing-shanghai-hangzhou-shenzhen*/ /** * 计算数组中的单元数目 * count() * 第二个参数可选,默认0,识别不了无限递归,1:可以识别无限递归 * 此例中,输出的count就是6 *//*$arr = [ 'beijing', 'shanghai'=&gt;[ 'pudong', 'jiaoda' ], 'hangzhou', 'shenzhen'];echo count($arr);//4echo "&lt;hr&gt;";echo count($arr,1);//6*/ /** * 数组当前单元和指针 * current(),next(),prev(),end(),reset() *//*$foods = ['banana','apple','orange'];var_dump(current($foods));var_dump(next($foods));//将数组指针向后移动一位var_dump(current($foods));*/ /** * 数组中的键名和值 * key() next() */ /** * 检查给定键名或索引是否存在于数组中 * array_key_exits */ /** * 获取数组中键名 * array_keys() */ /** * 获取数组中所有的值 * array_values *//*$arr = [ '12' =&gt; 'beijing', '25' =&gt; 'shanghai', '3' =&gt; 'hangzhou', '4' =&gt; 'shenzhen'];var_dump(array_values($arr));//获取数组所有键值*/ /** * 搜索给定值返回键名 * array_search *//*$arr = [ '0' =&gt; 'blue', '2' =&gt; 'red', '3' =&gt; 'green'];var_dump(array_search('red',$arr)); // 2*/ /** * 填补数组 * array_pad() * pad_size:填补后数组的长度(若为负数,则填补到左侧) * pad_value:填补的内容 *//*$arr = [ '0' =&gt; 'blue', '2' =&gt; 'red', '3' =&gt; 'green'];$arr = array_pad($arr,6,'orange');var_dump($arr);*/ /** * 使用指定的键和值填充数组 * array_fill_keys *//*$arr = ['banana','apple',2,5];$arr = array_fill_keys($arr,array('hangzhou','shanghai','beijing'));print_r($arr);*/ /* * 浏览器显示 Array( [banana] =&gt; Array ( [0] =&gt; hangzhou [1] =&gt; shanghai [2] =&gt; beijing ) [apple] =&gt; Array ( [0] =&gt; hangzhou [1] =&gt; shanghai [2] =&gt; beijing ) [2] =&gt; Array ( [0] =&gt; hangzhou [1] =&gt; shanghai [2] =&gt; beijing ) [5] =&gt; Array ( [0] =&gt; hangzhou [1] =&gt; shanghai [2] =&gt; beijing ))*/ /** * 从数组中随机取出一个或多个单元 * array_rand * 注:返回随机条目的一个或多个键 *//*$arr = [ '0' =&gt; 'blue', '2' =&gt; 'red', '3' =&gt; 'green', '4' =&gt; 'color'];$arrs = array_rand($arr,3);var_dump($arrs);*/ /** * 数组排序与打乱数组 * sort(),asort() shuffle() *//*$arr = range('a','z');shuffle($arr);foreach($arr as $k=&gt;$v)&#123; echo $v; echo " ";&#125;*/ /** * 遍历数组 * for,foreach(),each() list() *//*$arrs=['beijing','shanghai','guangzhou','hangzhou','shenzhen'];$arrss=['haerbin','zhengzhou'=&gt;'henan','nanjing'];//for循环写法for($i = 0; $i &lt; count($arrs); $i++)&#123; echo $arrs[$i]; echo '&lt;br&gt;';&#125;echo "&lt;hr&gt;";//foreach写法foreach($arrss as &amp;$v)&#123; echo $v; echo ' ';&#125;*/ /** * list() 将数组的值分给赋给变量 * *//*$arrs=['beijing','shanghai','guangzhou','hangzhou','shenzhen'];list($a[1], $a[2], $a[3]) = $arrs;var_dump($a);*/ /** *数组的拆分,拆分成几组，每组几个元素 * array_chunk() *//*$arrs = ['beijing','shanghai','guangzhou','hangzhou','shenzhen'];$arrs = array_chunk($arrs,2,true);var_dump($arrs);*/ //浏览器显示/**array(3) &#123; [0]=&gt; array(2) &#123; [0]=&gt; string(7) "beijing" [1]=&gt; string(8) "shanghai" &#125; [1]=&gt; array(2) &#123; [2]=&gt; string(9) "guangzhou" [3]=&gt; string(8) "hangzhou" &#125; [2]=&gt; array(1) &#123; [4]=&gt; string(8) "shenzhen" &#125;&#125; */ /** * 合并数组 * array_merge() *//*$arrs=['beijing','shanghai','guangzhou','hangzhou','shenzhen'];$arrss=['haerbin','zhengzhou'=&gt;'henan','nanjing','hangzhou'];$arr = array_merge($arrs,$arrss);var_dump($arr);*/ /** *增加删除数组中的元素 *array_shift() 可在数组开头插入一个1或多个单元 *array_unshift() 可将数组开头的单元移除数组 * array_push() 用来将一个或多个单元压入数组的末尾(入栈) * array_pop() 可将数组的最后一个单元弹出(出栈) */ /** * 从数组中取出一段 * array_slice() 字符串 substr *//*$arrs = ['beijing','shanghai','guangzhou','hangzhou','shenzhen'];var_dump(array_slice($arrs,2,3,true));//array(3) &#123; [2]=&gt; string(9) "guangzhou" [3]=&gt; string(8) "hangzhou" [4]=&gt; string(8) "shenzhen" &#125;*/ /** * 把数组中的一部分去掉,并用其他值取代 * array_splice() *//*$arrss = ['haerbin','zhengzhou'=&gt;'henan','nanjing','hangzhou'];array_splice($arrss,1,2,'code');var_dump($arrss); //array(3) &#123; [0]=&gt; string(7) "haerbin" [1]=&gt; string(4) "code" [2]=&gt; string(8) "hangzhou" &#125;*//*$arrss = ['haerbin','zhengzhou'=&gt;'henan','nanjing','hangzhou'];$arr3 = [3,6,9,12,13,1,21,22,4,23];array_splice($arrss,2);var_dump($arrss); //array(2) &#123; [0]=&gt; string(7) "haerbin" ["zhengzhou"]=&gt; string(5) "henan" &#125;echo array_sum($arr3);//获得数组内所有数的总和*/ 系统预定义数组 $_SERVER $_GET $_POST12345678//var_dump($_SERVER);//var_dump($_POST);//var_dump($_GET);/*$name = $_POST['name'];$pass = $_POST['pass'];var_dump($_POST);*/ 获取通过post方式上传文件的相关信息1234567891011 * $_FILESsession_start();session_id();var_dump(session_id());echo "&lt;hr&gt;";$_COOKIE['name'] = 'xiaobudiu';$_COOKIE['pass'] = '56611';var_dump($_COOKIE);setcookie('session_id','');*/ php常用时间处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171 /** * 获取当前时间 * time(); *///var_dump(date('Y-m-d H:i:s',time())); /** *取得日期时间信息 * getdate() *//*$arr=getdate();var_dump($arr);*//*array(11) &#123; ["seconds"]=&gt; int(57) ["minutes"]=&gt; int(58) ["hours"]=&gt; int(18) ["mday"]=&gt; int(4) ["wday"]=&gt; int(4) ["mon"]=&gt; int(1) ["year"]=&gt; int(2018) ["yday"]=&gt; int(3) ["weekday"]=&gt; string(8) "Thursday" ["month"]=&gt; string(7) "January" [0]=&gt; int(1515063537)&#125;*/ /** * 常用时间处理 * */ /** * 默认时区设置 * date_default_timezone_set() *///date_default_timezone_set('PRC'); /** * 计算两个日期的时间差 * 2017年1月4日20时28分30秒 2018年5月6日19时30分15秒 * @param $hour_start int 起始小时 (这里填20) * @param $minutes_start int 起始分钟数 (这里填28) * @param $seconds_start int 起始秒数 (这里填30) * @param $month_start int 起始月份 (这里填1) * @param $day_start int 起始日期(这里填4) * @param $year_start int 起始年份(这里填2017) * @param $hour_end * @param $minutes_end * @param $second_end * @param $month_end * @param $day_end * @param $year_end *//*function diff_time($year_start,$month_start,$day_start,$hour_start,$minutes_start,$seconds_start, $year_end,$month_end,$day_end,$hour_end,$minutes_end,$second_end)&#123; //2016年1月1日19点30分0秒时间戳 //$start=mktime(19,30,0,1,1,2016) $start=mktime($hour_start,$minutes_start,$seconds_start,$month_start,$day_start,$year_start); //2016年7月7日7点30分0秒时间戳 //$end=mktime(7,30,0,7,7,2016); $end=mktime($hour_end,$minutes_end,$second_end,$month_end,$day_end,$year_end); //时间戳之差 $diff_seconds=$end-$start; //一周的秒数是24*60*60*7=604800 $diff_weeks=floor($diff_seconds/604800); //一天的秒数是24*60*60=86400 $diff_days=floor($diff_seconds/86400); $diff_hours=floor($diff_seconds/3600); $diff_minutes=floor($diff_seconds/60); echo "两个时间相差"."：".$diff_weeks."个星期，".$diff_days."天，".$diff_hours."小时，".$diff_minutes."分，". $diff_seconds."秒";&#125;//示例: 2016年9月25日18时25分30秒 2017年1月4日20时36分15秒diff_time(2016,8,25,18,25,30,2017,1,4,20,36,15);*/ /** * 将具体时间日期转化为时间戳 *//*echo mktime(10,25,25,10,25,2016);echo "&lt;hr&gt;";echo strtotime('20161025102525');*/ /** * 求两个日期的时间差 * 求2016.9.4 10:32:33 与2017.1.4 21:22:23 * @param $start int 起始日期 20160904103233 * @param $end int 结束日期 20170104212223 * 注:也可以不用strtotime,用mktime()去转化时间戳,其他步骤一样 *//*function diff_time($start,$end)&#123; $start=strtotime($start); $end=strtotime($end); //计算两个时间的时间戳 $diff_seconds=$end-$start; //求相差多少个星期 $diff_weeks=floor($diff_seconds/(24*60*60*7)); //求相差多少天 $diff_days=floor($diff_seconds/(24*60*60)); //求相差多少小时 $diff_hours=floor($diff_seconds/(60*60)); //求相差多少分 $diff_minutes=floor($diff_seconds/60); //输出结果 echo "两个时间相差"."：".$diff_weeks."个星期，".$diff_days."天，".$diff_hours."小时，".$diff_minutes."分，". $diff_seconds."秒";&#125;diff_time('20160904103233','20170104212223');*/ /*$start = 'last Friday';$time1 = strtotime("$start + 1days");echo date('Y-m-d H:i:s',$time1);*/ /*$start = '20170430122531';$end = '20180104224925';//求两个时间戳的差$diff_time = strtotime($end) - strtotime($start);//求相差多少天$diff_days = floor($diff_time/(24*60*60));echo "两个时间相差".$diff_days."天";*/ /** * 验证日期 * checkdate() *///var_dump(checkdate(12,32,2016)); //bool(false) /** * 表单的种类 *input文本域 * */ /*var_dump($_POST);echo "&lt;hr&gt;";var_dump($_FILES);*/ 处理文件上传123456789101112131415161718192021222324252627282930313233343536/** * 处理文件上传 * 在html页面上传文件到本方法所在php文件,在php文件中,调用方法即可(html页面中type为file的input name值为file * 如果想更改,本方法中$_FILES['file']也要对应更改 */ //function upfiles()&#123;// if ($_FILES['file']['error'] &gt; 0) &#123;// echo "Error:".$_FILES['file']['error']."&lt;br /&gt;";// &#125; else &#123;// echo "&lt;pre&gt;";// print_r($_FILES['file']);// //将临时文件移动到永久文件// //判断文件是否是通过http post上传的// if(is_uploaded_file($_FILES['file']['tmp_name']))&#123;// $upfile = $_FILES['file'];// //获取数组里的值// $name = $upfile['name'];// $tmp_name = $upfile['tmp_name'];// //移动上传文件到指定目录(这里用绝对路径,也可以用相对路径,但要注意在文件夹前加上网站根目录)// /* define('ROOT',dirname(__FILE__)); //E:\PHP\phpstudy\WWW\Project\kk// //对移动临时文件是否成功做判断// if(!move_uploaded_file($tmp_name,ROOT."\Upload\\".$name))&#123;// echo "Error:移动文件失败,请确认文件名全为英文";// &#125;*/// if(@!move_uploaded_file($tmp_name,"E:\PHP\phpstudy\WWW\Project\kk\Upload\\".$name))&#123;// echo "Error:移动文件失败,请确认文件名全为英文";// &#125;//// &#125;// &#125;////&#125;//upfiles();//var_dump(__FILE__);//var_dump(dirname(__FILE__)); static静态属性与方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Class myclass * 静态属性(类属性) * 类内用self调用,类外使用类名调用 *//*class myclass &#123; static $staticVal = 10; function getStatic()&#123; echo self::$staticVal; echo "&lt;hr&gt;"; self::$staticVal++; &#125;&#125;echo myclass::$staticVal;//10echo "&lt;hr&gt;";$a = new myclass();var_dump($a-&gt;getStatic());//null*/ /** * 静态方法(类方法) * *///class myclass&#123;// static $staticVal = 10;// public $val = 100;//// /**// * 获取类属性(静态属性 $staticVal)// */// static function getStaticVal()&#123;// echo self::$staticVal;// &#125;////// /**// * 类内调用类属性,并对类属性进行改变// */// static function changeStaicVal()&#123;// self::$staticVal++;// echo self::$staticVal;//// &#125;//////&#125;////myclass::getStaticVal();//10//myclass::changeStaicVal();//11 文件名操作12345678910/** * 文件名操作 * basename() *//*echo __FILE__; //E:\PHP\phpstudy\WWW\Project\kk\index.phpecho "&lt;hr&gt;";$a = basename(__FILE__,".php");echo $a; //index*/ 构造方法与析构方法123456789101112131415161718192021222324252627282930313233343536373839/** * 构造方法 * 创建对象时自动调用的方法 * __construct * 构造方法常用的场景是在创建对象时给变量赋值 */ //class yourclass&#123;//// public $name;// public $age;//// /**// * yourclass constructor.// * 构造方法// * 创建对象时自动调用此方法// */// function __construct($name,$age)// &#123;// $this-&gt;name = $name;// $this-&gt;age = $age;// &#125;//// /**// * 析构方法// * __destruct// * 析构方法是在对象被销毁前自动执行的方法// *// */// function __destruct()// &#123;////// &#125;////&#125;////$a = new yourclass('xiaoming',25);//echo $a-&gt;name; 封装继承多态1234567891011121314151617181920212223242526272829303132 /** * 封装和继承 * public 任何地方都可以调用 * protected 本类和子类中可以被调用 * private 只有本类可以调用 */ /** * 封装,就是将类中的成员属性和方法内容细节尽量隐藏起来,确保类外部代码不能随意访问类内内容 */ /** * 继承 * extends */ /** * 多态 * 多态,通过继承,复用代码实现 可编写出健壮可扩展的的代码 减少流程控制语句的使用 * 在运行时,根据传递的对象参数,决定调用不用的方法 */ /** * 回顾函数总结: * 函数的三个特性:封装,继承,多态 * 封装:将函数的成员属性成员方法内容细节尽可能隐藏起来,确保类外部代码不能随意访问类中内容 * 继承:一个类作为公共基类,其他类继承这个类,则其他类都具有这个类的属性和方法 * 多态:通过继承复用代码而实现 运行时根据传递的参数对象,决定调用哪一个对象的方法 */ 魔术方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 /** * 魔术方法 * php提供了内置的拦截器,他可以'发送'到未定义方法和属性的消息 * __set() __get() __isset() __unset() __call() __toString() * */ /** * __set() * 在代码要给未定义的属性赋值时调用,或在类外部修改被private修饰的类属性时被调用 * 它会传递两个参数;属性名和属性值 * 通过__set()方法也可以实现对private关键词修饰的属性值进行更改 */ /** * __get() * 当在类外部访问被private或proteced修饰的属性或访问一个类中原本不存在的属性时被调用 */ /** * __isset() * 当在类外部对未定义的属性或者非公有属性使用isset()函数时,__isset()将会被调用 */ //注:结合 property_exists() property_exists()用来检测类中是否定义了该属性//用法:property_exists('magic',$key) 检测在magic类中是否定义了$key属性 /** * __unset() * 对类中未定义的属性或非公有属性进行unset()操作时,将会触发__unset()方法. * 如果属性存在,unset操作会销毁这个属性,释放该属性在内存中占用的空间 * 再用对象访问这个属性时,将会返回NULL */ /** * __call() * 当试图调用不存在的方法时会触发__call() * __call()有两个参数,即方法名和参数,参数以索引形式存在 */ //class magic&#123;// function __call($func,$param)// &#123;// echo "$func method not exists";// var_dump($param);// &#125;//&#125;//$obj = new magic();//$obj-&gt; register('param1','param2','param3'); //实例化的对象调用不存在的register()方法 /* * 浏览器结果显示: * register method not exist sarray(3) &#123; [0]=&gt; string(6) "param1" [1]=&gt; string(6) "param2" [2]=&gt; string(6) "param3" &#125; */ /** * toString() * 当使用echo或print打印对象时会被调用__toString()方法将对象转化为字符串 *//*class magic&#123; function __toString() &#123; return 'when you want to echo or print the object, __toString() will be called'; &#125;&#125;$obj = new magic();print $obj; //浏览器显示 when you want to echo or print the object, __toString() will be called*/ 自动加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /** * 自动加载 * __autoload() * 当在代码尝试加载未定义的类时会触发__autoload()函数 * 用法简单示例: *///假设有两个文件为myclass.php和yourclass.php,另外,在同一目录下写一个autoload.php文件,代码如下 //////////////////////中间代码不起作用,不用解除注释///////////////////////////myclass.php代码/* class myclass&#123; function myname()&#123; echo "My Name Is xiaobudiu"; &#125;&#125;//yourclass.php代码class yourclass&#123; function yourname()&#123; echo "Your Name Is pgone"; &#125;&#125;*//////////////////////中间代码不起作用,不用解除注释/////////////////////////////////*//autoload.php代码function __autoload($name)&#123; if(file_exists($name.".php"))&#123; require_once $name.'php'; &#125;else&#123; echo "The Path Is Error"; &#125;&#125;$my = new myclass();$my -&gt; myname();$your = new yourclass();$your -&gt; yourname();*/ /** * 自动加载 * spl_autoload_register(),和__autoload()方法功能相似,实现自动加载二选其一即可 * 可以实现自动加载以及注册给定的函数作为__autoload()的实现 * 两个参数 第一个参数autoload_function为要注册的自动装载函数,第二个参数throw为布尔值,true为默认,抛出异常;false不抛出异常 * 实例:假设当前目录下存在myclass.php和yourclass.php,并且代码和上面一样,autoload.php代码进行更改 *//*function my_autoloader($class)&#123; include $class.'.php';&#125;spl_autoload_register('my_autoloader');$my=new myclass();$my-&gt;myname();$your=new yourclass();$your-&gt;yourname();*///此时运行autoload.php 执行结果 My Name Is xiaobudiu Your Name Is pgone 抽象类与接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991.对接口的继承使用implements,抽象类使用extends.2.接口中不可以声明变量,但可以声明类常量.抽象类中可以声明各种变量3.接口没有构造函数,抽象类可以有4.接口中的方法默认为public,抽象类中的方法可以用public,protected,private修饰5.一个类可以继承多个接口,但只能继承一个抽象类 /** * 抽象类 * abstract * 一种对下级代码的规范 * 抽象类和接口都是不能被实例化的特殊类 * 可以在抽象类和接口中保留公共的方法,将抽象类和接口作为公共的基类 * 一个抽象类必须至少包含一个抽象方法,抽象类中的方法不能被定义为私有的(private),因为抽象类中的方法需要被子类覆盖 * 同样抽象类中的方法也不能用final修饰,因为其需要被子类继承 * 抽象类中的抽象方法不包括方法实体.如果一个类中包含了一个抽象方法,那么这个类也必须声明为抽象类 * 抽象方法不实现具体的功能，由子类来完成 * 子类必须实现抽象类中的所有方法,否则会报错 *语法:abstract class class_name&#123;abstract public function func_name1(arg1,arg2);abstract public function func_name2(arg1,arg2,arg3);&#125; * */ //示例:计算矩形的周长 /* abstract class Shape &#123; abstract protected function get_area();//和一般的方法不同的是，这个方法没有大括号//你不能创建这个抽象类的实例：$Shape_Rect = new Shape();&#125;class Rectangle extends Shape&#123; private $width; private $height; function __construct($width = 0, $height = 0) &#123; $this-&gt;width = $width; $this-&gt;height = $height; &#125; function get_area() &#123; echo ($this-&gt;width + $this-&gt;height) * 2; &#125;&#125;$Shape_Rect = new Rectangle(20,10);$Shape_Rect-&gt;get_area();*/ /** * 接口 * interface * 一种对下级代码的规范 * 与抽象类不同,一个子类可以继承自多个接口,接口之间用','隔开, * 接口实现了php的多重继承 * 接口需要被继承,所以接口中定义的方法不能为私有方法或被final修饰 * 接口中定义的全部方法都必须被子类实现,并且不能包含实体 * *///示例:定义database接口/*interface Database&#123; function connect($host,$username,$pwd,$db); function query($sql); function fetch(); function close(); function test();&#125;class mysql implements Database &#123; protected $conn; protected $query; function connect($host, $username, $pwd, $db) &#123; $this-&gt;conn = new mysqli($host,$username,$pwd,$db); &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function fetch() &#123; return $this-&gt;query-&gt;fetch(); &#125; function close() &#123; $this-&gt;conn-&gt;close(); &#125; function test() &#123; echo "test"; &#125;&#125;*/ 类中的关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 //类中的关键字 /** * final * 子类可覆写父类中的方法,但是在有些时候并不希望父类中的方法被重写,这时只要在父类中的方法前加上final控制符, * 该方法便不能被子类重写,否则会报错 */ //错误示范:/* class father&#123; final function test()&#123; echo "My Name Is xiaobudiu"; &#125;&#125;class son extends father&#123; function test()&#123; echo "My Name Is PGone"; &#125;&#125;*///执行程序,浏览器会报错 Fatal error: Cannot override final method father::test() /** * clone * 可通过clone关键字克隆一个对象,克隆后的对象相当于在内存中重新开辟了一个空间 * 克隆得到的对象拥有和原来对象相同的属性和方法 * 修改克隆得到的对象不会影响到原来的对象 *///示例:/*class father&#123; public $name='xiaobudiu'; function test()&#123; echo "test"; &#125;&#125;$obj = new father();$obj_clone = clone $obj;$obj_clone-&gt;name = 'PGone';echo $obj_clone-&gt;name; //PGoneecho $obj-&gt;name //xiaobudiu*//////////////////////////////////////////////注:如果使用"="将一个对象赋给一个变量,那么得到的将是一个对象得引用,通过这个变量改变属性的值将会影响原来的对象//示例:/*class father&#123; public $name = 'xiaobudiu'; function test() &#123; echo "test"; &#125;&#125;$obj = new father();$obj_clone = $obj;$obj_clone-&gt;name = 'PGone';echo $obj-&gt;name,$obj_clone-&gt;name;//PGonePGone*/ /** * __clone() * 可以使用__clone()魔术方法将克隆后的副本初始化 * 可以理解为当对象被克隆时自动调用这个方法 */ //示例:/*class father&#123; public $name = 'xiaobudiu'; function test()&#123; echo "test"; &#125; function __clone()&#123; echo "hi,shuaige"; $this-&gt;name = 'PGone'; //当克隆对象时,克隆后的对象得到的将是此处的name属性值 &#125;&#125;$obj = new father();$obj_clone = clone $obj; //触发__clone()方法 //hi,shuaigeecho $obj-&gt;name,$obj_clone-&gt;name;//xiaobudiuPGone*/ /** * instanceof关键字 * instanceof可以检测对象属于哪个类 * 也可以用于检测生成实例的类是否继承自某个接口 *///示例:/*class father &#123; public $name = 'xiaobudiu'; function test()&#123; echo "test"; &#125;&#125;interface Database &#123; function test();&#125;class mysql implements Database&#123; function test()&#123; echo "test"; &#125;&#125;$obj = new father();$mysql = new mysql();var_dump($obj instanceof father);var_dump($mysql instanceof Database);var_dump($obj instanceof Database);//bool(true) bool(true) bool(false)*/ 正则表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223 /** * 正则表达式 * php中有两套函数库支持正则表达式 * PCRE(Perl Compatible Regular Expression)库提供,与Perl语言兼容的正则表达式函数,以"preg_"为函数的前缀名称 * POSIX(Portable Operating System Interface)扩展语法正则表达式函数,以"ereg_"为函数的前缀名称 * PCRE的执行效率高于POSIX */ /** * 普通字符 * 如 'A','B','C'等 */ /** * 元字符 * 分为单字元字符和多字元字符 * 如;\d 与数字字符相匹配 */ /*单字符元字符//* 零次或多次匹配前面的字符或表达式 zo* 与"z"和"zoo"匹配 &#123;0,&#125;//+ 一次或多次匹配前面的字符或表达式 zo+ 与"zo"和"zoo"匹配,但与"z"不匹配 &#123;1,&#125;//? 零次或一次匹配前面的字符或表达式 zo? 与"z"和"zo"匹配,但与"zoo"不匹配 &#123;0,1&#125;//^ 匹配搜索字符串开始的位置 ^\d&#123;3&#125; 与搜索字符串开始处的3个数字匹配//^ 如果将^用作括号表达式的第一个字符,就会对字符集求反 比如: [^abc] 匹配除abc以外的任何字符//$ 匹配搜索字符串结尾的位置 \d&#123;3&#125;$ 与搜索字符串结尾处的3个数字匹配//. 匹配除换行符\n之外的任何单个字符 a.c与"abc","alc"和"a-c"匹配//. 若要匹配包括\n在内的任意字符,可以使用[\s\S]之类的模式(\s \S属于'非打印字符')//[] 标记括号表达式的开始和结尾 [1-4]与"1","2","3","4"匹配 [^aeiouAEIOU]与任何非元音字符匹配//&#123;&#125; 标记限定符表达式的开始和结尾 a&#123;2,3&#125;与"aa"和"aaa"匹配//() 标记子表达式的开始和结尾,可以保存子表达式,以备将来之用 A(\d)与"A0"至"A9"匹配//| 指示在两个或多个选项之间进行选择 z|food 与"z"或"food"匹配; (z|f)ood与"zood"或"food"匹配/// 表示JScript中的文本正则表达式模式的开始或结尾.在第二个"/"后添加单字符标志可以指定搜索行为/// /abc/gi 是与"abc"匹配的JScript文本正则表达式.g(全局)标志指定查找模式的所有匹配项,i(忽略大小写)标志使搜索不区分大小写//\ 转义字符 \\与"\"匹配, \(与"("匹配, \n与换行符匹配*/ /*多字符元字符\b 与一个字边界匹配(即字与空格间的位置) er\b与"never"中的"er"匹配,但与"verb"中的"er"不匹配\B 与非边界字匹配 er\B与"verb"中的er匹配,但与"never"中的er不匹配\d 与数字字符匹配,等效于[0-9] \d&#123;2&#125;与"12 345"中的"12"和"34"匹配\D 与非数字匹配,等效于[^0-9] \D+与"abc123 def"中的'abc"和"def"匹配\w 与a-z,A-Z,0-9,和下划线中的任意字符匹配 在"my name is xiaobudiu..."中，\w与"my","name","is","xiaobudiu"匹配\W 与除a-z,A-Z,0-9,和下划线中的任意字符匹配 等效于[^a-zA-Z0-9][xyz] 字符集,与任何一个指定字符匹配 [abc]与"plane"中的a匹配[^xyz] 反向字符集,与未指定的任何字符匹配[a-z] 字符范围,匹配指定范围内的任何字符[^a-z] 反向字符范围,与不在指定范围内的任何字符匹配&#123;n&#125; 正好匹配n次,n是非负整数 o&#123;2&#125;与'Bob'中的"o"不匹配,但与"food"中的"oo"匹配&#123;n,&#125; 至少匹配n次,n是非负整数 o&#123;2,&#125;与'Bob'中的'o'不匹配,但与"fooood"中的所有"o"匹配&#123;n,m&#125; 匹配至少n次,至多m次 在搜索字符串"1234567"中,\d&#123;1,3&#125;与"123","456"和"7"匹配(模式) 与模式匹配并保存匹配项 (Chapter|Section) [1-9]与"Chapter 5"匹配,保存"Chapter"以备将来之用(?:模式) 与模式匹配,但不保存匹配项以备将来之用 industr(?:y|ies)与industry|industries相等*/ /*非打印字符\f 换页符\n 换行符\r 回车符\t Tab字符\v 垂直制表符\s 任何空白字符,包括空格,制表符,换页符 等效于[\f\n\r\t\v]\S 任何非空白字符 等效于[^\f\n\r\t\v]*/ //////////////////////////////正则表达式正式部分///////////////////////////////** * php中使用正则表达式 * * 匹配与查找 * preg_match() * preg_match_all() * preg_grep() * * 搜索与替换 * preg_replace() * preg_filter() * * 分割与转义 * preg_split() * preg_quote() */ /** * 匹配与查找 * preg_match * 返回int * 语法: preg_match($pattern,$subject [array &amp; $matches[,$flags=0 [,$offset=0]]]) * pattern是要搜索的模式,例如'/^def/'; * subject是指定的被搜索的字符串 * 它的值是0或1,在匹配一次后就会停止搜索 */ /*$subject="abcdefghijkdef";$pattern_1='/def/';$num=preg_match($pattern_1,$subject);var_dump($num);*/// int(1) /** * 匹配与查找 * preg_match_all()函数 * 返回int * 与preg_match功能相似,只不过在搜索到一次结果之后会继续搜索,知道末尾 */ /** * 匹配与查找 * preg_grep()函数 * 返回array * 可返回匹配模式的数组条目 *//*//代码示例:$subject = ['abc','def','efg','hijk','abcdef','defabc'];$pattern = '/def$/';$grep_1 = preg_grep($pattern,$subject);//返回与$pattern匹配的元素组成的数组var_dump($grep_1);$grep_2 = preg_grep($pattern,$subject,PREG_GREP_INVERT);//返回与$pattern不匹配的元素组成的数组var_dump($grep_2);*/ /*//浏览器显示: array(2) &#123; [1]=&gt; string(3) "def" [4]=&gt; string(6) "abcdef"&#125;array(4) &#123; [0]=&gt; string(3) "abc" [2]=&gt; string(3) "efg" [3]=&gt; string(4) "hijk" [5]=&gt; string(6) "defabc"&#125;*/ /** * 搜索与替换 * preg_replace() * 返回替换之后的字符串 * 三个参数,第一个参数:$pattern 搜索模式(规则) 可以是一个字符串或字符串数组 * 第二个参数:$replacement 用于替换的字符串或字符串数组 * 第三个参数:$subject 要进行搜索和替换的字符串或字符串数组 * limit 每个模式在每个subject上进行替换的最大次数 默认-1(无限) * count 如果指定,就会被填充为完成的替换次数 *//*$string_1 = 'lily likes apple,no reason';$pattern_1 = ['/lily/','/likes/','/apple/'];$replacement_1 = ['tom','hates','orange'];echo preg_replace($pattern_1,$replacement_1,$string_1); //tom hates orange,no reason$arr = ['lily likes apple,no reason','Tom hates orange,no reason'];$pattern_2 = ['/no/','/reason/'];$replacement_2 = ['why','?'];var_dump(preg_replace($pattern_2,$replacement_2,$arr)); //array(2) &#123; [0]=&gt; string(22) "lily likes apple,why ?" [1]=&gt; string(22) "Tom hates orange,why ?" &#125;*/ /** * 搜索与替换 * preg_filter() * 与preg_replace()功能相似 * preg_filter()只返回执行替换的元素(替换后的)(没执行替换的不返回) * 而preg_replace()返回全部元素(替换后的)(替没替换都返回) */ /** * 分割 * preg_split * 通过一个正则表达式分割字符串 * array preg_split($pattern $subject[,$limit=-1 [,$flag=0]]) * $patern 用于搜索的模式(规则) * $subject 输入字符串 * $limit 如果指定,就将限制分隔得到的子串最多只有limit个,返回的最后一个子串将包含所有剩余部分 limit为-1,0,null时都代表不限制 *///示例: //$subject = "I LIKE APPLE,AND YOU";//$patern = '/[\s,]+/';//var_dump(preg_split($patern,$subject)); /* array(5) &#123; [0]=&gt; string(1) "I" [1]=&gt; string(4) "LIKE" [2]=&gt; string(5) "APPLE" [3]=&gt; string(3) "AND" [4]=&gt; string(3) "YOU"&#125; */ /** * 转义 * preg_quote() * 函数转义正则表达式 * preg_quote($str [,$delimiter]) * $str 函数会向字符串中的每一个特殊字符前增加一个反斜线 * 如果指定了$delimiter,则在指定的$delimiter前也加反斜线 * 正则表达式特殊字符包括 . \ + * ? [ ? ] $ ( ) &#123; &#125; = ! &lt; &gt; | : - *///示例:/*$keywords = "$40 for \a g3/400*10/x";$keywords = preg_quote($keywords,'x');echo $keywords; //\$40 for \\a g3/400\*10/\x*/ 异常处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 异常处理 * php自带的Exception异常类 */ /*error_reporting(0);//设置错误级别为0,不报错function theDatabaseObj() &#123; $mysql = mysqli_connect('127.0.0.1','root2','root'); if($mysql)&#123; return $mysql; &#125;else&#123; throw new Exception("could't connect to the database,try again"); &#125;&#125;function db()&#123; try&#123; $db = theDatabaseObj(); var_dump($db); &#125; catch (Exception $e)&#123; echo $e-&gt;getMessage();// echo $e-&gt;getCode();// echo $e-&gt;getLine(); &#125;&#125;db();*/ /** * 创建自己的异常类 * *//*class aException extends Exception&#123; function aEX()&#123; return "This is the bad way"; &#125;&#125;class aaa &#123; function a() &#123; if (2&lt;1) &#123; echo "wrong"; &#125; else &#123; throw new aException('你错了,太笨了le'); &#125; &#125; function b() &#123; try&#123; $b = $this-&gt;a(); var_dump($b); &#125;catch (Exception $E) &#123; echo $E-&gt;getMessage(); &#125; &#125;&#125;$obj = new aaa();$obj-&gt;b();*/ //实现的功能,调用exception异常处理/*function aaa()&#123; if($_GET['name'] == 'xiaobudiu')&#123; return "尊贵的管理员,请登录"; &#125;else&#123; throw new Exception('你没有权限登录'); &#125;&#125;function upload() &#123; try&#123; $upload = aaa(); var_dump($upload); &#125;catch (Exception $e) &#123; echo $e-&gt;getMessage(); &#125;&#125;upload();*/ /**. * php7中的错误处理 * 大多数错误开始被当做Error异常抛出,而不是Exception异常 * catch($Error $e) *//*try &#123; $a = new zoo();&#125;catch (Error $E)&#123; echo "error_msg:".$E-&gt;getMessage();&#125;*///error_msg:Class 'zoo' not found//注:这种Error异常处理方式只适用于php7,php5版本还是要用Exception异常类来处理错误及异常 图像处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 图像处理 * 图像处理要求GD库 *///使用函数查看一下当前安装没有GD库//echo "&lt;pre&gt;";//var_dump(get_loaded_extensions()); /** * 取得图像大小 * getimagesize() * 返回图像的尺寸以及文件类型 *///print_r(getimagesize('./Upload/IGS09651F94M.jpg')); /*浏览器结果Array( [0] =&gt; 740 //宽度像素值 [1] =&gt; 1166 //高度像素值 [2] =&gt; 2 //图像标记,gif是1,jpg是2,png是3,swf是4,psd是5.... [3] =&gt; width="740" height="1166" //文本字符串 [bits] =&gt; 8 //每种颜色的位数 [channels] =&gt; 3 //RGB图像是3,CMVK图像是4 [mime] =&gt; image/jpeg) */ /** * getimagesizefromstring() * 从字符串中获取图像尺寸信息 * 与getimagesize()函数的参数和返回结果相同,区别是getimagesizefromstring()的第一个参数是图像数据的字符串表达,而不是文件名 *///$img = file_get_contents('./Upload/IGS09651F94M.jpg');//var_dump(getimagesizefromstring($img)); /*浏览器结果: array(7) &#123; [0]=&gt; int(740) [1]=&gt; int(1166) [2]=&gt; int(2) [3]=&gt; string(25) "width="740" height="1166"" ["bits"]=&gt; int(8) ["channels"]=&gt; int(3) ["mime"]=&gt; string(10) "image/jpeg"&#125; */ /** * imagesx,imagesy * 取得图像的宽度和高度 *//*$img = imagecreatetruecolor(300,200);echo imagesx($img);//300echo imagesy($img);//200*/ /** * 图像绘制 * imagecreate(),可创建一个基于调色板的图像 * 与imagecreateturecolor()作用和参数相同 * 返回一个图像标识符,代表了一幅大小为x_size和y_size的空白图像 * 1.创建画布 * 2.在画布上绘制图形 * 3.保存并输出结果图像 * 4.销毁图像资源 */ /*//创建一个空白画布,并输出一个png格式的图片header("Content-type:image/png");//设置mime类型$image = @imagecreate(120,30) or die("Cannot Initialize new GD image stream"); //创建画布$background_color = imagecolorallocate($image,255,255,0);//定义颜色imagepng($image);//输出png格式图像imagedestroy($image);//销毁图像资源,释放内存*/ /** * 定义颜色 * imagecolorallocate() * 给图像的边框背景和文字等元素指定颜色 * 返回一个标识符,代表由给定的RGB成分组成的颜色 * 与imagecolorallocate()功能相似的第一个函数是imagecolorallocatealpha(),区别在于后者多了一个透明度参数0-127 127表示完全透明 */ /** * 绘制椭圆 * imageellipse() *///新建一个空白的图像/*$image = imagecreatetruecolor(400,300);//填充背景色$bg = imagecolorallocate($image,255,255,255);//选择椭圆的颜色$col_ellipse = imagecolorallocate($image,55,55,255);//画一个椭圆imageellipse($image,200,150,300,200,$col_ellipse);//输出图像header("Content-type:image/png");imagepng($image);*/ /** * 将文字写入图像 * imagefttext() */ //echo "&lt;img src=code.php&gt;";//生成图片 目录文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265/** * 判断文件类型 * filetype() * 返回文件的类型.可能值有fifo,char,dir,block,link,file和unknown,出错返回false *///echo filetype('code.php');//file//echo filetype('./Public');//filedir /** * 判断是否是一个目录 * is_dir() *///var_dump(is_dir('Upload'));//bool(true)//var_dump(is_dir('index.php'));//bool(false)//var_dump(is_dir('Upload/aa.jpg'));//bool(false) /** * 创建目录 * mkdir() * 创建成功返回true recursive值为true时,表示允许递归创建目录 *//*/error_reporting(0);function mkd($name)&#123; if (file_exists($name)) &#123; echo "file already exists"; &#125; else &#123; try&#123; mkdir($name,0777,true); echo "创建成功"; &#125;catch (Exception $e)&#123; throw new Exception('创建目录失败,请核查后重试'); &#125; &#125;&#125;mkd('./aa/bb');*/ /** * 删除目录 * rmdir * 尝试删除dir所指定的目录.该目录必须为空,并且要拥有相应权限 *//*error_reporting(0);$dir = './aa/bb';if (rmdir($dir)) &#123; echo "Remove Dir Successfuly";&#125; else &#123; die('failes to delete folders...');&#125;//注:只能删除一个文件夹,例如$dir中的'./aa/bb',就只删除了一个bb文件夹,aa仍在*/ /** * scandir * 列出指定路径中的文件和目录 * 第二个参数shorting可选,设为1,即按字母降序,默认升序 * *///$dir = './';//$dir1 = scandir($dir,1);//var_dump($dir1);/*array(16) &#123; [0]=&gt; tring(9) "test.html" [1]=&gt; tring(11) "option.html" [2]=&gt; tring(11) "indexx.html" [3]=&gt; string(9) "index.php" [4]=&gt; tring(5) "index" [5]=&gt; tring(11) "favicon.ico" [6]=&gt; tring(8) "code.php" [7]=&gt; tring(2) "aa" [8]=&gt; tring(6) "Upload" [9]=&gt; tring(6) "Public" [10]=&gt; string(5) "2.css" [11]=&gt; &gt;string(5) "1.php" [12]=&gt; string(5) "1.css" [13]=&gt; string(5) ".idea" [14]=&gt; string(2) ".." [15]=&gt; string(1) "."&#125; */ /** * dirname() * 返回路径中的目录部分 *///echo dirname('./Public/favicon.ico'); // ./Public /** * 查看磁盘空间 * disk_free_space(); 返回磁盘分区可用字节数 * disk_total_space();返回磁盘分区总容量 */ //echo disk_total_space('/');//191392714752 /** * 打开文件 * fopen() * 有参数r,r+,w,w+,a,a+,x,x+,c,c+ */ /** * 读取文件 * fgets() * 第一个参数表示资源 * 第二个参数表示读取多少字节,默认1kb(1024字节) *//*$file = fopen("code.php", "r");//输出文本中所有的行，直到文件结束为止。//feof() 函数检测是否已到达文件末尾 (eof)。//如果文件指针到了 EOF 或者出错时则返回 TRUE，否则返回一个错误（包括 socket 超时），其它情况则返回 FALSEwhile(! feof($file))&#123; echo fgets($file). "&lt;br /&gt;";&#125;fclose($file);*//*//要求:读取code.php中所有行数内容//打开文件$file = fopen('code.php',"r");//读取文件while(!feof($file))&#123;//只要不读到末尾,就输出本行 echo fgets($file)."&lt;br&gt;";&#125;fclose($file);*/ /** * 获取文件上次访问的时间 * fileatime() *//*$file = 'code.php';if(file_exists($file))&#123; echo $file."上次访问的时间是".date("Y-m-d H:i:s",fileatime($file));&#125;else&#123; echo "您所访问的文件不存在,请核查后重新操作";&#125;//code.php上次访问的时间是2018-01-08 00:17:28*/ /** * 获取文件上次被修改的时间 * filemtime() *//*$file = "code.php";if(file_exists($file))&#123; echo $file."上次修改的时间为".date("Y-m-d H:i:s",filemtime($file));&#125;else&#123; echo "您所访问的文件不存在,请核查后重新操作";&#125;//code.php上次修改的时间为2018-01-08 00:17:28*/ /** * filesize() *获取文件的大小 * 返回文件大小的字节数 *///echo filesize('./code.php');//1937 /** * filetype() * 返回文件的类型 *///echo filetype('./code.php');//file /** * stat() * 给出文件的详细信息 * 能返回上次访问,上次修改,文件大小等各种信息 *///var_dump(stat("./code.php"));/* array(26) &#123; [0]=&gt; int(4) [1]=&gt; int(0) [2]=&gt; int(33206) [3]=&gt; int(1) [4]=&gt; int(0) [5]=&gt; int(0) [6]=&gt; int(4) [7]=&gt; int(1937) [8]=&gt; int(1515341848) [9]=&gt; int(1515341848) [10]=&gt; int(1515334800) [11]=&gt; int(-1) [12]=&gt; int(-1) ["dev"]=&gt; int(4) ["ino"]=&gt; int(0) ["mode"]=&gt; int(33206) ["nlink"]=&gt; int(1) ["uid"]=&gt; int(0) ["gid"]=&gt; int(0) ["rdev"]=&gt; int(4) ["size"]=&gt; int(1937) ["atime"]=&gt; int(1515341848) ["mtime"]=&gt; int(1515341848) ["ctime"]=&gt; int(1515334800) ["blksize"]=&gt; int(-1) */ /** * 复制文件 * copy() * 第一个参数是resource,第二个参数dist表示复制到哪里 *//*$file = './code.php';$newfile = 'aa/code2.php';if (copy($file,$newfile))&#123; echo "复制文件".$file."到".$newfile."成功";&#125;else&#123; echo "复制文件".$file."失败";&#125;*/ /** * 删除文件 * unlink() *//*$file = './aa/code2.php';if(unlink($file))&#123; echo "删除文件".$file."成功";&#125;else&#123; echo "删除文件失败";&#125;*/ /** *移动或重命名文件 * rename() *//*error_reporting(0);if(rename('2.php','1.php'))&#123; echo "文件重命名成功";&#125;else&#123; echo "Rename Failed";&#125;*/ /** * 文件指针 * 可以实现文件指针的定位和 查询,从而实现所需信息的快速查询 * rewind() 将文件位置指针设为文件流的开头 * fseek() 在文件指针中定位 * ftell() 返回文件指针读写的位置 *//*$file = "./code.php";$file = fopen($file,"r");echo ftell($file);*/ COOKIE 及 SESSION 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354///////////////////////////////////////COOKIE 及 SESSION////////////////////////////** * COOKIE * 一种存储在客户端的数据,能存储cookie的客户端不只是浏览器,但绝大多数都是由浏览器来实现的 * 浏览器通过HTTP协议和服务端进行Cookie交互 * 在实现过程中,编程语言是通过指令通知浏览器,然后是浏览器实现设置Cookie的功能的 * 读取cookie则是通过浏览器请求服务端时携带的HTTP头部中的Cookie信息得来的 */ /** * 设置cookie * setcookie() * 第一个参数name是必选参数,表示cookie名称 * 第二个参数可选,value表示值 * 第三个参数可选,expire表示cookie的有效时间,以秒为单位,不设置此值,浏览器关闭,cookie随之失效 * 第四个参数可选,path,设置有效目录,设置为'/'表示当前目录下均可用,设置为'/aa'表示只有aa目录下可用 * 第五个参数可选,domain,设置cookie的作用域名,默认在本域名下有效,比如设置为example.com表示在example域名下的所有子域名都有效 * 第六个参数可选,secure,用来设置是否对Cookie进行加密传输,默认false,如果设置为true,则只有使用https时候才会设置Cookie * 第七个参数为true表示只能通过HTTP协议才能访问Cookie,意味着客户端javascipt不可以操作这个cookie,使用此参数可减少xss攻击的风险 * 注:php和javascript都可以设置cookie,不同的是,php设置的cookie需要刷新页面后的下一次请求中才有效,而javascript设置的cookie在本次请求中就有效 */ /** * cookie经常用来存储一些不敏感的信息,如用来防止刷票,记录用户名,限制重复提交等 * 示例:限制重复提交 * 原理:当用户第一次提交表单时,设置cookie有效时间1分钟,当再次提交时,判断cookie是否过期来限制用户的提交 */ /** * Session设置 * $_SESSION[key] = value * Session存储在服务器,本质上和Cookie没有区别,都是针对HTTP协议的局限性而提出的一种保持客户端和服务端间会话状态的机制. * *///开启session会话/*session_start();//设置session$_SESSION['name'] = 'xiaobudiu';session_id();var_dump($_SESSION);echo "&lt;hr&gt;";var_dump($_COOKIE);*/ //var_dump(get_loaded_extensions());/** * 使用Redis存储Session * 对于大访问量的网站来说,会有许多客户端和服务端建立连接,就会生成许多session文件,由于session文件是存储在硬盘上的,因此每次 * 服务器去读取这些session文件都要经过许多I/O操作. * PHP可以使用session_set_save_handle()函数自定义session保存函数(如打开,关闭,写入,读取等),如果想使用php内置的会话机制之外的方式, * 可以使用本函数.例如,可以自定义会话存储函数来将会话数据存储到数据库.函数参数说明如下: * */ Mysql数据库的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157///////////////////////Mysql数据库的使用///////////////////////////////** * 关系型数据库,数据以表格的形式出现 * 每行为各种记录名称 * 每列为记录名称所对应的数据域,许多的行和列构成一张数据表,许多的表构成一个数据库 * */ /** * MYSQLi连接操作数据库 * *//** * Mysqli执行插入数据操作 * *//*$db = new mysqli('localhost','root','root','test');$sql = "insert into `user` (`username`,`email`) VALUES (?,?)";//定义参数$username = "xiaobudiu";$email = "xiaobudiu163@126.com";//预处理$sm = $db-&gt;prepare($sql);//绑定参数$sm-&gt;bind_param('ss',$username,$email);//执行语句if($sm-&gt;execute())&#123; echo "Insert Successfully";&#125;$db-&gt;close();*/ /** *MYSQLi查询数据 *//*$db = new mysqli('localhost','root','root','test');$sql = "select * from user where uid&lt;4";$re = $db-&gt;query($sql);echo "&lt;pre&gt;";while($arr = $re-&gt;fetch_assoc())&#123; var_dump($arr);&#125;//释放查询结果$re-&gt;free();//断开数据库连接$db-&gt;close();*//* array(3) &#123; ["uid"]=&gt; string(1) "1" ["username"]=&gt; string(4) "kate" ["email"]=&gt; string(12) "kate@126.com"&#125;array(3) &#123; ["uid"]=&gt; string(1) "2" ["username"]=&gt; string(5) "admin" ["email"]=&gt; string(12) "admin@qq.com"&#125;array(3) &#123; ["uid"]=&gt; string(1) "3" ["username"]=&gt; string(4) "mary" ["email"]=&gt; string(14) "mary@itcast.cn"&#125; */ /** * pdo连接操作mysql数据库 *//*$dsn = 'mysql:dbname=test;host=127.0.0.1';$user = 'root';$pass = 'root';try&#123; $pdo = new PDO($dsn,$user,$pass);// var_dump($pdo);&#125;catch(PDOException $e)&#123; echo "Connection failed:".$e-&gt;getMessage();&#125;*//*//向数据表中插入数据$dsn='mysql:dbname=test;host=127.0.0.1';$user = 'root';$pass = 'root';//实例化pdo对象,连接数据库$pdo = new PDO($dsn,$user,$pass);//向数据库插入数据$sql = "insert into user (`username`,`email`) VALUES ('xiaowangba','sandjdsa@163.com')";$re = $pdo-&gt;exec($sql);if($re) &#123; echo "向数据库插入数据成功";&#125; else &#123; var_dump($pdo-&gt;errorInfo());&#125;*/ /** * 修改数据表数据 *//*$dsn='mysql:dbname=test;host=localhost';$user = 'root';$pass = 'root';$pdo = new PDO($dsn,$user,$pass);$sql = "update user set username='wangxiaoping' where uid=8";if($pdo-&gt;exec($sql)) &#123; echo "修改数据成功";&#125; else &#123; echo "&lt;pre&gt;"; var_dump($pdo-&gt;errorInfo());&#125;*/ /** * 删除数据表中的数据 * *//*$dsn='mysql:dbname=test;host=127.0.0.1';$user = 'root';$pass = 'root';$pdo = new PDO($dsn,$user,$pass);$sql = "delete from user where uid=7";if($pdo-&gt;exec($sql)) &#123; echo "删除数据成功";&#125; else &#123; var_dump($pdo-&gt;errorInfo());&#125;*/ /** * 查询数据表 *//**$dsn='mysql:dbname=test;host=localhost';$user = 'root';$pass = 'root';$pdo = new PDO($dsn,$user,$pass);$sql = "select `username`,`email` from user where `uid` BETWEEN 2 AND 8";//预处理$re = $pdo-&gt;prepare($sql);$re-&gt;execute();$arrs = $re-&gt;fetchAll();echo "&lt;pre&gt;";var_dump($arrs); */ PHP 与 Redis1234567891011121314151617181920212223242526272829//////////////////////////////////////PHP 与 Redis////////////////////////////////////////** * 关系型数据库能满足编程中一般的存储查询需求,随着网站业务量的增加,我们还需要存储许多数据,并且要求能够很快的将数据查询出来,这时,关系型数据库mysql * 就会稍显吃力. * 当网站用户并发性非常高(高并发读写往往达到每秒上万次请求)时,对于传统关系型数据库来说,硬盘I/O是一个很大的瓶颈,因为mysql的数据存储是写入磁盘上的. * 同时,网站每天产生的数据量是巨大的,对于关系型数据库来说,在一张包含海量数据表中查询效率也是非常低的 * 针对关系型数据库的不足,出现了很多NOSQL产品,这些数据库中很大一部分都是针对某些特定应用需求出现的,对于该类应用具有极高性能,依据结构化方法以及应用 * 场合不同,主要分为以下几类: * 面向高性能并发读写的key-value数据库,主要特点是具有极高的并发读写性能.Redis,TokyoCabinet,Flare是这类数据库的代表 * 面向海量数据访问的面向文档数据库,这类数据库的特点是可以在海量的数据中快速查询数据,典型代表为MongoDB和CouchDB * 面向可扩展性的分布式数据库,相对于传统数据库存在的可扩展性缺陷,这类数据库可以适应数据量的增加以及数据结构的变化 */ /** * Redis是一个高级开源的key-value数据库存储系统.支持string,list,set,zset,hash 5种数据存储类型,支持对数据的多种操作,能够满足绝大部分业务需求. * Redis中的数据都是缓存在内存中的,比读取存储在硬盘上的数据速度要快很多. * Redis支持数据的持久化操作,可通过配置,周期性的将内存中的数据写入磁盘,提高了数据的安全性 * Redis还支持主从同步,更好的解决了高并发的问题 * Redis支持在Linux,Windows,MacOS系统中运行,但在实际应用场景中,推荐使用Linux系统. */ /** * 在Linux系统使用Redis * http://redis.io/ 下载Redis安装包 * Redis采用"主版本号,次版本号,补丁版本号"的命名规则.次版本号的位置,偶数表示稳定版本,如1.2 2.0 ，奇数表示测试版本,如2.9代表测试版本,n那么3.0将会是2.9.x的稳定版本 *这里建议lnamp或者lnmp一键安装包 * lnamp默认网站根目录 /data/wwwroot/default/index.php */ XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115///////////////////////////XML////////////////////////** * 使用字符串生成xml * *//*header('Content-type:text/xml');$xmlstr=&lt;&lt;&lt;XML&lt;?xml version='1.0' standalone='yes'?&gt;&lt;movies&gt; &lt;movie&gt; &lt;title&gt;shanpaojincheng&lt;/title&gt; &lt;content&gt;Two shan pao jin cheng&lt;/content&gt; &lt;/movie&gt; &lt;plot&gt; &lt;name&gt;演的不错&lt;/name&gt; &lt;/plot&gt;&lt;/movies&gt;XML;echo $xmlstr;//注: &lt;&lt;&lt;xml 作用:将"&lt;&lt;&lt;xml"和最后的"xml"之间的内容转换成字符串;*//*&lt;movies&gt; &lt;movie&gt; &lt;title&gt;shanpaojincheng&lt;/title&gt; &lt;content&gt;Two shan pao jin cheng&lt;/content&gt; &lt;/movie&gt; &lt;plot&gt; &lt;name&gt;演的不错&lt;/name&gt; &lt;/plot&gt;&lt;/movies&gt; */ /** * 使用数组循环遍历生成xml * 与使用字符串生成xml相比,数组生成xml则不用写那么多&lt;&gt;标签,轻松很多 * *//*header('Content-type:text/xml');echo '&lt;?xml version="1.0" ?&gt;'."\n";echo "&lt;books&gt;\n";$books = array( array( 'bookname'=&gt;'微信小程序开发实战与应用实例', 'press'=&gt;'清华大学出版社', 'publishtime'=&gt;'2016-07' ), array( 'bookname'=&gt;'一周微信公众号开发入门到精通', 'press'=&gt;'延安出版社', 'publishtime'=&gt;'2017-5' ));foreach($books as $book)&#123; echo " &lt;book&gt;\n"; foreach ($book as $tag=&gt;$value)&#123; echo " &lt;$tag&gt;".htmlspecialchars($value)."&lt;/$tag&gt;\n"; &#125; echo " &lt;/book&gt;\n";&#125;echo "&lt;/books&gt;";*/ /*&lt;books&gt; &lt;book&gt; &lt;bookname&gt;微信小程序开发实战与应用实例&lt;/bookname&gt; &lt;press&gt;清华大学出版社&lt;/press&gt; &lt;publishtime&gt;2016-07&lt;/publishtime&gt; &lt;/book&gt; &lt;book&gt; &lt;bookname&gt;一周微信公众号开发入门到精通&lt;/bookname&gt; &lt;press&gt;延安出版社&lt;/press&gt; &lt;publishtime&gt;2017-5&lt;/publishtime&gt; &lt;/book&gt;&lt;/books&gt; */ /** * 通过PHP SimpleXML()解析xml,将字符串解析成对象,采用对象调用属性的方式获取值 * SimpleXML()是用来处理XML最便捷的方案 * 简化了与xml的交互,可以把元素转换成对象属性,位于标签之间的文本被指定给属性 * 如果同一个位置上有多个同名元素,n那么这些元素会被放在一个列表中.元素的属性会被转换成一个数组元素,其中 * 数组的键是属性名,键的值就是属性值 *///示例:/*$xmlstr=&lt;&lt;&lt;XML&lt;?xml version="1.0" standalone='yes' ?&gt;&lt;movies attr="qwe" ha="hahah属性值"&gt; &lt;movie a="shiyanshuxing"&gt; &lt;title tt="tt属性值"&gt;PHP从中阶进阶到大神&lt;/title&gt; &lt;characters&gt; &lt;character&gt; &lt;name age="22 years old" country="china"&gt;lixiaoming&lt;/name&gt; &lt;acter&gt;onlivia actora&lt;/acter&gt; &lt;/character&gt; &lt;character&gt; &lt;name&gt;Mr.coder&lt;/name&gt; &lt;acter&gt;xiaobudiu&lt;/acter&gt; &lt;/character&gt; &lt;/characters&gt; &lt;/movie&gt;&lt;/movies&gt;XML;$xml = simplexml_load_string($xmlstr);var_dump($xml);//将字符串变成xml对象echo $xml-&gt;movie-&gt;title;echo ":";echo $xml-&gt;movie-&gt;characters-&gt;character[0]-&gt;name;//获取属性值echo $xml-&gt;movie-&gt;title['tt']*/ JSON1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677////////////////////////////////////////json的使用/////////////////////////////////////////////** * json_encode() 将数组转换成json编码数据 * json_decode() 对json格式的字符串进行解码 * PHP作为一门服务端语言,常被用来写服务端接口逻辑,向客户端返回json格式的数据 * 与xml相比,在很多语言中,json数据的处理都比xml数据的处理简单得多,json数据和数组可以实现非常方便的转换 * 在包含同样信息的情况下,json数据字节数要比xml少很多 * json这种便捷性和简洁性使其可以取代xml成为互联网信息的规范数据格式 */ /** * json_encode() 将数组转换成json编码数据 *//*echo "连续数组";$a = array('foo','zoo','xiaoming','xiaodong');var_dump(json_encode($a));//连续数组string(35) "["foo","zoo","xiaoming","xiaodong"]"echo "非连续数组";$b = array( 1=&gt;'foo', 2=&gt;'zoo', 3=&gt;'XIAOMING', 4=&gt;'XIAODONG');var_dump(json_encode($b));//非连续数组string(51) "&#123;"1":"foo","2":"zoo","3":"XIAOMING","4":"XIAODONG"&#125;"echo "删除一个连续数组值的方式产生的非连续数组";unset($a[1]);var_dump(json_encode($a));//删除一个连续数组值的方式产生的非连续数组string(41) "&#123;"0":"foo","2":"xiaoming","3":"xiaodong"&#125;"echo "二维数组";$arr = array( array( 'name'=&gt;'xiaobudiu', 'age'=&gt;25, 'sex'=&gt;'man' ), array( 'name'=&gt;'PGone', 'age'=&gt;25, 'sex'=&gt;'woman' ));var_dump(json_encode($arr));//二维数组string(81) "[&#123;"name":"xiaobudiu","age":25,"sex":"man"&#125;,&#123;"name":"PGone","age":25,"sex":"woman"&#125;]"*/ /** * json_decode() * 将json格式的字符串解码 * 第二个参数可选,选择为true表示 将json字符串解码成数组 * 第二个参数默认false,解码成对象object *///$json = '&#123;"0":"foo","2":"xiaoming","3":"xiaodong"&#125;';//var_dump(json_decode($json));/*object(stdClass)#1 (3) &#123;["0"]=&gt; string(3) "foo"["2"]=&gt; string(8) "xiaoming"["3"]=&gt; string(8) "xiaodong"&#125;*///var_dump(json_decode($json,true));/*array(3) &#123; [0]=&gt; string(3) "foo" [2]=&gt; string(8) "xiaoming" [3]=&gt; string(8) "xiaodong"&#125;*/ mvc&amp;TP1234567891011121314151617181920212223/** * mvc 一种软件设计典范,用业务逻辑/数据/界面显示分离 的方法组织代码,将业务逻辑聚集到一个页面里面,使得各部分的代码做各自的事情, * 各个人员编写的代码负责特定的功能,降低了耦合度 * 由mvc架构系统的程序执行流程: * controller截获用户发出的请求,调用model完成状态的读写操作 * controller把数据传给view,view渲染最终效果并呈现给用户. * 另外,php经常用来写一些接口程序,提供接口返回特定格式的数据(一般是json),不同的客户端(网页前端,桌面客户端,手机客户端等)可通过调用接口 * 获得数据. */ /** * 常用的php开源框架 * ThinkPHP tp是为了简化企业级应用开发和敏捷Web应用开发而诞生. * Yii 用于开发大型web应用.基于组件的高性能php框架通过一个简单的命令行工具yiic可以快速创建一个web应用程序的代码框架. * CI 组件的导入和函数的执行只有在被要求执行的时候才执行,而不是在全局范围,因此默认的系统非常轻量级,为了达到最大的用途,每个类和它的功能都是高度自治的. * Laravel 一套简洁,优雅的php web开发框架 * Yaf (yet another framework) 提供了bootstrap,路由,分发,视图,插件 ,是一个全功能的php框架 */ /** * tp5支持使用composer安装 * */ 设计模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269////////////////////设计模式//////////////////////////////** * 分为3大类:创建型模式,结构型模式,行为型模式,还有一种J2EE设计模式,共23种设计模式(设计模式-可复用的面向对象软件元素) * 工厂模式以及单例模式属于创建型模式. * 创建型模式的描述:这些设计模式提供了一种在创建对象的同时,隐藏创建逻辑的方式,而不是使用新的运算符直接实例化对象. * 这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活 *//** * 工厂模式 * 工厂模式属于创建型模式,提供了一种创建对象的方式. * 工厂模式是先定义一个创建对象的接口,让其子类自己决定实例化哪一个工厂类. * 工厂模式的精髓就是可以根据不同的参数生成不同的类实例 *///示例:加减乘除工厂类实例//定义接口/*interface Calc&#123; public function getValue($num1,$num2);&#125;//创建实现接口的实体类class Add implements Calc &#123; public function getValue($num1, $num2) &#123; return $num1+$num2; &#125;&#125;class Sub implements Calc &#123; public function getValue($num1, $num2) &#123; return $num1-$num2; &#125;&#125;class Mul implements Calc &#123; public function getValue($num1, $num2) &#123; return $num1*$num2; &#125;&#125;class Div implements Calc &#123; public function getValue($num1, $num2) &#123; try &#123; if($num2==0)&#123; throw new Exception('除数不能为0'); &#125;else&#123; return $num1/$num2; &#125; &#125;catch (Exception $e)&#123; echo "错误信息:".$e-&gt;getMessage(); &#125; &#125;&#125;//创建一个工厂,生成基于给定信息的实体类的对象class Factory&#123; public static function creatObj($operate)&#123; switch ($operate)&#123; case '+': return new Add(); break; case '-': return new Sub(); break; case '*': return new Mul(); break; case '/': return new Div(); break; &#125; &#125;&#125;$test=Factory::creatObj('-');echo $test-&gt;getValue(1,4);//注:其实想实现本功能,定义一个类,一个公共方法,方法里采用switch也可以实现本功能,但为了代码的可读性以及代码的执行效率,所以采用工厂类;//注;这样,我们就实现了根据用户输入的操作符实例化相应的对象,进而完成接下来相应的操作.在软件开发中,php可能要链接mysql,也可能链接sqlserver.//或者其他数据库,这样我们就可以定义一个工厂类,动态生成不同的数据库连接对象;//再比如设计一个连接服务器的框架,需要三个协议,即pop3,imap,http,可以把这三个作为产品类,共同实现一个接口.工厂模式使用场景很多,需要在实//际开发中尝试1应用*/ /** * 单例模式 * 单例模式涉及一个单一的类,该类负责创建自己的对象,同时确保只有单个对象被创建 * 单例模式主要解决一个全局使用的类被频繁创建与销毁的问题 * 由于只创建了一个类的实例,因此减少了内存的开销,节省了系统资源 * php中,单例模式经常被用在数据库应用中. *///代码示例:/*class Student&#123; //私有的静态属性, 作用是为了存储对象的. private static $_instance=null; //私有的构造方法,保证不允许在类外 new private function __construct()&#123;&#125; //私有的克隆方法, 保证不允许在类外 通过 clone 来创建新对象 private function __clone()&#123;&#125; //公有的静态方法, 作用,就是用来实例化对象 public static function getIntance()&#123; //将创建的新对象存储到静态属性中 //判断静态属性中是否为空 if(is_null(self::$_instance))&#123; //如果为空,则创建新对象,并将新存储赋给静态属性$instance self::$_instance = new self; &#125; //如果$instance不为空,则直接将对象返回 return self::$_instance; &#125;&#125;//调用静态方法来创建对象$obj = Student::getIntance();$obj2 = Student::getIntance();//此行不再创建新对象//var_dump($obj);//var_dump($obj2);*/ /** * 观察者模式 * 一种事件系统.有两个类,a类和b类,a类允许b类观察,获取a类的状态,当a类状态发生改变的时候,b类可以收到通知,并作出相应的动作 * 观察者模式提供了避免组件之间紧密耦合的另一种方法 * 比如要实现用户注册后发送邮件通知管理员和用户自己填写的邮箱的功能,我们可以将发送邮件给管理员和用户自己都写在这个实现用户注册 * 的类里(使用观察者实现),这样,即使在以后更改了用户注册逻辑也不会影响到发送邮件的功能实现 * 再比如当用户下单购买一件商品时,我们需要将购买记录写入文本日志,数据库日志,还要发送短信,送抵兑换券积分等,我们可以在主体类中实 * 现下单购买的流程并定义一个观察者接口,当用户下单后通知各个观察者对象执行自己的业务逻辑. */ //示例1//观察者模式设计两个类//男人类和女人类//男人类对象 xiaoming 女人类对象 xiaohua mother/*class man&#123; //定义数组属性,用于存放观察者对象 protected $observers=[]; //将传进来的观察者对象存入观察者数组中的方法 function addObserver($observer)&#123; $this-&gt;observers[]=$observer; &#125; //删除观察者的方法 function delObserver($observer)&#123; //查找观察者在数组中的键值 $key=array_search($observer,$this-&gt;observers); //根据键值删除对应观察者 unset($this-&gt;observers[$key]); &#125; //男人buy()方法 function buy()&#123; foreach ($this-&gt;observers as $girl)&#123; //当被观察者作出buy()这个行为时,让观察者得到通知,并作出相应的反应 $girl-&gt;dongjie(); &#125; &#125;&#125;class woman&#123; function dongjie()&#123; echo "你的儿子或者男朋友正在花钱&lt;br&gt;"; &#125;&#125;//创建被观察着对象$xiaoming = new man();//创建观察者对象$xiaohua = new woman();$mother = new woman();//为xiaoming添加观察者$xiaoming-&gt;addObserver($mother);$xiaoming-&gt;addObserver($xiaohua);//$xiaoming-&gt;delObserver($xiaohua);//xiaomign执行buy()之后,看观察者xiaohua和mother是否能得到通知,并作出相应反应$xiaoming-&gt;buy();*/ //示例2:/** * 场景描述： * 哈票以购票为核心业务(此模式不限于该业务)，但围绕购票会产生不同的其他逻辑，如： * 1、购票后记录文本日志 * 2、购票后记录数据库日志 * 3、购票后发送短信 * 4、购票送抵扣卷、兑换卷、积分 * 5、其他各类活动等 * * 传统解决方案: * 在购票逻辑等类内部增加相关代码，完成各种逻辑。 * * 存在问题： * 1、一旦某个业务逻辑发生改变，如购票业务中增加其他业务逻辑，需要修改购票核心文件、甚至购票流程。 * 2、日积月累后，文件冗长，导致后续维护困难。 * * 存在问题原因主要是程序的"紧密耦合"，使用观察者模式将目前的业务逻辑优化成"松耦合"，达到易维护、易修改的目的， * 同时也符合面向接口编程的思想。 * * 观察者模式典型实现方式： * 1、定义2个接口：观察者（通知）接口、被观察者（主题）接口 * 2、定义2个类，观察者对象实现观察者接口、主题类实现被观者接口 * 3、主题类注册自己需要通知的观察者 * 4、主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。 */ #===================定义观察者、被观察者接口============/*//观察者接口(通知接口)interface guancha&#123; function onBuyTicketOver($sender, $args); //得到通知后调用的方法&#125;//被观察者接口(主题接口)interface beiguancha&#123; function addObserver($observer); //提供添加观察者的方法&#125;/////////////////////////主题类实现/////////////////////主题类（购票）class buyPiao implements beiguancha &#123; //实现主题接口（被观察者） private $_observers = []; //数组存放观察者对象 public function buyTicket($ticket) //购票核心类，处理购票流程 &#123; //购票逻辑 //循环通知，调用其onBuyTicketOver实现不同业务逻辑 foreach ( $this-&gt;_observers as $obs ) $obs-&gt;onBuyTicketOver ( $this, $ticket ); //$this 可用来获取主题类句柄，在通知中使用 &#125; //添加通知 public function addObserver($observer) //添加N个通知 &#123; $this-&gt;_observers [] = $observer; &#125;&#125;///////////////////////////////定义多个通知///////////////////////////短信日志通知class HipiaoMSM implements guancha &#123; public function onBuyTicketOver($sender, $ticket) &#123; echo (date ( 'Y-m-d H:i:s' ) . " 短信日志记录：购票成功:$ticket&lt;br&gt;"); &#125;&#125;//文本日志通知class HipiaoTxt implements guancha &#123; public function onBuyTicketOver($sender, $ticket) &#123; echo (date ( 'Y-m-d H:i:s' ) . " 文本日志记录：购票成功:$ticket&lt;br&gt;"); &#125;&#125;//抵扣卷赠送通知class HipiaoDiKou implements guancha &#123; public function onBuyTicketOver($sender, $ticket) &#123; echo (date ( 'Y-m-d H:i:s' ) . " 赠送抵扣卷：购票成功:$ticket 赠送10元抵扣卷1张。&lt;br&gt;"); &#125;&#125;/////////////////////////////用户购票///////////////////////////$buy = new buyPiao ();$buy-&gt;addObserver ( new HipiaoMSM () ); //根据不同业务逻辑加入各种通知$buy-&gt;addObserver ( new HipiaoTxt () );$buy-&gt;addObserver ( new HipiaoDiKou () );//购票$buy-&gt;buyTicket ( "一排一号" );*/ /** * 策略模式 * 与工厂模式实现的功能相似,区别是工厂模式关注的是对象的创建,提供创建对象的接口,是创建型的设计接口,接收指令,创建出符合要求的实例 * 策略模式是行为型的设计模式,接受已经创建好的实例,实现不同的行为 * */ ///////////////////////////////开始进入API的世界///////////////////////////////** * 随着移动网络的发展,多终端的出现,为了降低服务端的工作量,和以后的维护量,我们希望开发一套可适用于多个终端的接口. * 面向接口编程要求我们将定义和实现分开,尽可能编写粒度更细的接口,降低各个接口之间的依赖度,这些接口通过一定的组合能够对外提供一套系统服务 * */ 传输消息加解密12345678910111213141516171819202122232425262728293031323334353637383940414243444546/////////////////////////////////传输消息加解密///////////////////////////** * 单向散列加密 * 常用的单向散列加密:MD5,SHA等 * 单向加密是对不同输入长度的信息进行散列计算,得到固定长度的散列计算值.输入信息的任何微小变化都会导致散列的很大不同,并且这种计算是不可逆的 * 即无法根据散列值获得明文信息.这种单向散列加密可用于用户密码的保存.即不将用户输入的密码直接保存到数据库,而是对密码进行单向散列加密.将密文 * 存入数据库,用户登陆时进行密码验证,同样对输入的密码进行散列加密,与数据库中密码的密文进行对比,若一致,则验证通过 * 虽然不能通过算法从散列密文解出明文,但是由于人们设置的密码具有一定的模式(比如使用生日或名字作为密码),因此通过彩虹表(密码和对应的密文关系表) * 等手段都可以猜测式的1破解.为了增加单向散列被破解的难度,还可以给散列算法加盐值(salt),salt相当于加密时的钥匙,增加破解时的难度 */ /** * 对称加密 * 对称加密是指加密和解密使用的是同一个秘钥.对称加密类似接口签名验证,将明文和密钥按照一定的算法进行加密,同样使用密钥和一定的算法对密文进行解密 * 获得明文. * PHP提供了一个MCRYPT扩展,可用于对称加密. * 注:php7开始,已经对mcrypt加密方式进行删除,官方不推荐此方式了. * *//** * mycrpt加密需要以下几个步骤: * *///示例1/*$str = "我的名字是？一般人我不告诉他！"; //加密内容$key = "key25111"; //密钥$cipher = MCRYPT_DES; //密码类型$modes = MCRYPT_MODE_ECB; //密码模式$iv = mcrypt_create_iv(mcrypt_get_iv_size($cipher,$modes),MCRYPT_RAND);//初始化向量echo "加密明文：".$str."&lt;p&gt;";$str_encrypt = mcrypt_encrypt($cipher,$key,$str,$modes,$iv); //加密函数echo "加密密文：".$str_encrypt." &lt;p&gt;";$str_decrypt = mcrypt_decrypt($cipher,$key,$str_encrypt,$modes,$iv); //解密函数echo "还原：".$str_decrypt;*/ /** *非对称加密 * RSA是目前最有影响力的公钥加密算法 *与对称加密不同的是,非对称加密和解密使用的是不同的密钥,其中一个对外公开作为公钥,另一个只有私有者私有,成为私钥.用私钥加密的 *信息只有公钥能够解开,反之用公钥加密的信息只有私钥能够解开. *常用的非对称加密有RSA算法 *RSA算法基于一个非常简单的数论事实,将两个大质数相乘十分容易,但是想要对其乘积进行因式分解却极其困难,因此可以将乘积公开作为加密密钥 *PHP中,提供基于RSA算法的openssl扩展可实现对数据的非对称加密 */ 使用ajax进行交互123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/////////////////////////////////////使用ajax进行交互//////////////////////////////////////** * 把网页看成客户端,服务端以提供接口的形式向客户端提供数据的增删改查服务. * 在网页开发中,经常使用ajax技术实现客户端与服务端的数据交互 * ajax是一种在无须重新加载整个网页的情况下能够更新部分网页的技术. * ajax通过在后台与服务器进行少量的数据交换可以使网页实现异步更新. */ //检测用户名是否可用//假设用户名为zhangsan和lisi已经被使用了/** *html代码&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;检测用户名是否被使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;用户名:&lt;input type="text" name="name" id="name"&gt;&lt;span id="span"&gt;&lt;/span&gt;&lt;/body&gt;&lt;!--实现的功能是:当用户输入完用户名,失去焦点时,自动检测是否被使用了--&gt;&lt;script&gt;//获取input元素var input=document.getElementById('name');//给其绑定失去焦点事件input.onblur=function () &#123;//创建xhr对象xhr = new XMLHttpRequest();//获取用户输入的用户名var name = this.value;//状态确认后才接收数据xhr.onreadystatechange=function () &#123;if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;if(xhr.responseText == 1)&#123;document.getElementById('span').innerHTML = "&lt;font color='red'&gt;baoqian,您输入的用户名已经有人注册&lt;/font&gt;"&#125;else&#123;document.getElementById('span').innerHTML = "&lt;font color='#7fffd4'&gt;gongxi,可以注册此用户名&lt;/font&gt;"&#125;&#125;&#125;//设置请求xhr.open('get','index.php?name='+name,true);//发送请求xhr.send();&#125;&lt;/script&gt;&lt;/html&gt; *//** *php代码 *//*$name = $_GET['name'];if($name == 'zhangsan')&#123; echo 1;&#125;else&#123; echo 2;&#125;*/ --------------------- 作者：m_nanle_xiaobudiu 来源：CSDN 原文：https://blog.csdn.net/m_nanle_xiaobudiu/article/details/79251726 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinnkphp]]></title>
    <url>%2F2019%2F04%2F14%2Fhinnkphp%2F</url>
    <content type="text"><![CDATA[如何理解TP中的单一入口文件？ThinkPHP采用单一入口模式进行项目部署和访问，无论完成什么功能，一个项目都有一个统一（但不一定是唯一）的入口。应该说，所有项目都是从入口文件开始的，并且所有的项目的入口文件是类似的。 入口文件中主要包括：（1）定义框架路径、项目路径和项目名称（可选）（2）定义调试模式和运行模式的相关常量（可选）（3）载入框架入口文件（必须） ThinkPHP中的MVC分层是什么？（理解）MVC 是一种将应用程序的逻辑层和表现层进行分离的方法。ThinkPHP 也是基于MVC设计模式的。MVC只是一个抽象的概念，并没有特别明确的规定，ThinkPHP中的MVC分层大致体现在： 模型（M）：模型的定义由Model类来完成。 控制器（C）：应用控制器（核心控制器App类）和Action控制器都承担了控制器的角色，Action控制器完成业务过程控制，而应用控制器负责调度控制。 视图（V）：由View类和模板文件组成，模板做到了100％分离，可以独立预览和制作。 但实际上，ThinkPHP并不依赖M或者V ，也就是说没有模型或者视图也一样可以工作。甚至也不依赖C，这是因为ThinkPHP在Action之上还有一个总控制器，即App控制器，负责应用的总调度。在没有C的情况下，必然存在视图V，否则就不再是一个完整的应用。总而言之，ThinkPHP的MVC模式只是提供了一种敏捷开发的手段，而不是拘泥于MVC本身。 如何进行SQL优化？（1）选择正确的存储引擎MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 （2）优化字段的数据类型记住一个原则，越小的列会越快。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间。 （3）为搜索字段添加索引索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么最好是为其建立索引，除非你要搜索的字段是大的文本字段，那应该建立全文索引。 （4）避免使用Select 从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。即使你要查询数据表的所有字段，也尽量不要用通配符，善用内置提供的字段排除定义也许能给带来更多的便利。 （5）使用 ENUM 而不是 VARCHARENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。例如，性别、民族、部门和状态之类的这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。 （6）尽可能的使用 NOT NULL除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。 NULL其实需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。 （7）固定长度的表会更快如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。 如何理解 ThinkPHP 3.0 架构（核心 + 行为 + 驱动）中的行为？（1）核心（Core）：就是框架的核心代码，不可缺少的东西，TP本身是基于MVC思想开发的框架。 （2）行为（Behavior） ：行为在新版ThinkPHP的架构里面起着举足轻重的作用，在系统核心之上，设置了很多标签扩展位，而每个标签位置可以依次执行各自的独立行为。行为扩展就因此而诞生了，而且很多系统功能也是通过内置的行为扩展完成的，所有行为扩展都是可替换和增加的，由此形成了底层框架可组装的基础。 （3）驱动（ Driver ）：数据库驱动、缓存驱动、标签库驱动和模板引擎驱动，以及外置的类扩展。 什么是惯例配置？所谓的惯例配置，便是框架的自带的配置文件。该文件在核心框架目录下的convention.php中，配置内容如下。由于该文件属于框架自带的配置文件，在实际的开发过程中，主要给我们做参考实例使用，我们很少去修改该文件的配置内容，更多的是根据需求来按照惯例配置中的字段定义和注释来在模块或者Common中自定义配置内容。 什么是SQL注入？（理解）SQL注入攻击是黑客对数据库进行攻击的常用手段之一。 一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，注入者可以在表单中输入一段数据库查询代码并提交，程序将提交的信息拼凑生成一个完整sql语句，服务器被欺骗而执行该条恶意的SQL命令。注入者根据程序返回的结果，成功获取一些敏感数据，甚至控制整个服务器，这就是SQL注入。 ThinkPHP如何防止SQL注入？（理解）（1）查询条件尽量使用数组方式，这是更为安全的方式；（2）如果不得已必须使用字符串查询条件，使用预处理机制；（3）使用绑定参数（4）开启数据字段类型验证，可以对数值数据类型做强制转换；（3.1版本开始已经强制进行字段类型验证了）（5）使用自动验证和自动完成机制进行针对应用的自定义过滤；（6）使用字段类型检查、自动验证和自动完成机制等避免恶意数据的输入。 如何开启调试模式？调试模式有什么好处？开启调试模式很简单，只需要在入口文件中增加一行常量定义代码：// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为falsedefine(‘APP_DEBUG’, true);调试模式的优势在于： 开启日志记录，任何错误信息和调试信息都会详细记录，便于调试； 关闭模板缓存，模板修改可以即时生效； 记录SQL日志，方便分析SQL； 关闭字段缓存，数据表字段修改不受缓存影响； 严格检查文件大小写（即使是Windows平台），帮助你提前发现Linux部署问题； 可以方便用于开发过程的不同阶段，包括开发、测试和演示等任何需要的情况，不同的应用模式可以配置独立的项目配置文件。 TP中支持哪些配置模式？优先级？惯例配置-&gt;应用配置-&gt;模式配置-&gt;调试配置-&gt;状态配置-&gt;模块配置-&gt;扩展配置-&gt;动态配置 以上是配置文件的加载顺序，因为后面的配置会覆盖之前的同名配置（在没有生效的前提下），所以优先顺序从右到左。 TP中的URL模式有哪几种？默认是哪种？ThinkPHP支持四种URL模式，可以通过设置URL_MODEL参数来定义，包括普通模式、PATHINFO、REWRITE和兼容模式。默认模式为：PATHINFO模式，设置URL_MODEL 为1 TP中系统变量有哪些？如何获取系统变量？（1）系统变量：$_SERVER、$_ENV、 $_POST、 $_GET、 $_REQUEST、$_SESSION和 $_COOKIE变量 （2）获取系统变量： {$Think.server.script_name} // 输出$_SERVER[‘SCRIPT_NAME’]变量 {$Think.session.user_id} // 输出$_SESSION[‘user_id’]变量 {$Think.get.pageNumber} // 输出$_GET[‘pageNumber’]变量 {$Think.cookie.name} // 输出$_COOKIE[‘name’]变量 ThinkPHP框架中D函数与M函数的区别是什么？M方法实例化模型无需用户为每个数据表定义模型类，D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会自动调用M方法去实例化Model基类。同时对于已实例化过的模型，不会重复去实例化（单例模式）。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php mysql函数]]></title>
    <url>%2F2019%2F04%2F14%2Fp-mysql%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[mysql_affected_rows： 得到 MySQL 最后操作影响的列数目。 mysql_close： 关闭 MySQL 服务器连接。 mysql_connect： 打开 MySQL 服务器连接。 mysql_create_db： 建立一个 MySQL 新数据库。 mysql_data_seek： 移动内部返回指针。 mysql_db_query： 送查询字符串 (query) 到 MySQL 数据库。 mysql_drop_db： 移除数据库。 mysql_errno： 返回错误信息代码。 mysql_error： 返回错误信息。 mysql_fetch_array： 返回数组资料。 mysql_fetch_field： 取得字段信息。 mysql_fetch_lengths： 返回单列各栏资料最大长度。 mysql_fetch_object： 返回类资料。 mysql_fetch_row： 返回单列的各字段。 mysql_field_name： 返回指定字段的名称。 mysql_field_seek： 配置指针到返回值的某字段。 mysql_field_table： 获得目前字段的资料表 (table) 名称。 mysql_field_type： 获得目前字段的类型。 mysql_field_flags： 获得目前字段的标志。 mysql_field_len： 获得目前字段的长度。 mysql_free_result： 释放返回占用内存。 mysql_insert_id： 返回最后一次使用 INSERT 指令的 ID。 mysql_list_fields： 列出指定资料表的字段 (field)。 mysql_list_dbs： 列出 MySQL 服务器可用的数据库 (database)。 mysql_list_tables： 列出指定数据库的资料表 (table)。 mysql_num_fields： 取得返回字段的数目。 mysql_num_rows： 取得返回列的数目。 mysql_pconnect： 打开 MySQL 服务器持续连接。 mysql_query： 送出一个 query 字符串。 mysql_result： 取得查询 (query) 的结果。 mysql_select_db： 选择一个数据库。 mysql_tablename： 取得资料表名称。 mysql_affected_rows 得到 MySQL 最后操作影响的列数目。 语法： int mysql_affected_rows(int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可得到 MySQL 最后查询操作 INSERT、UPDATE 或 DELETE 所影响的列 (row) 数目。若最后的查询 (query) 是使用 DELETE 而且没有使用 WHERE 命令，则会删除全部资料，本函数将返回 0。若最后使用的是 SELECT，则用本函数不会得到预期的数目，因为要改变 MySQL 数据库本函数才有效，欲得到 SELECT 返回的数目需使用 mysql_num_rows() 函数。 mysql_close 关闭 MySQL 服务器连接。 语法： int mysql_close(int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数关闭与 MySQL 数据库服务器的连接。若无指定参数 link_identifier 则会关闭最后的一笔连接。用 mysql_pconnect() 连接则无法使用本函数关闭。实际上本函数不是一定需要的，当 PHP 整页程序结束后，将会自动关闭与数据库的非永久性 (non-persistent) 连接。成功返回 true、失败返回 false 值。 参考： mysql_connect() mysql_pconnect() mysql_connect 打开 MySQL 服务器连接。 语法： int mysql_connect(string [hostname] [：port], string [username], string [password]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数建立与 MySQL 服务器的连接。其中所有的参数都可省略。当使用本函数却不加任何参数时，参数 hostname 的默认值为 localhost、参数 username 的默认值为 PHP 执行行程的拥有者、参数 password 则为空字符串 (即没有密码)。而参数 hostname 后面可以加冒号与埠号，代表使用那个埠与 MySQL 连接。当然在使用数据库时，早点使用 mysql_close() 将连接关掉可以节省资源。 使用范例 &lt;?php $dbh = mysql_connect(‘localhost：3306’,’mcclain’,’standard’); mysql_select_db(‘admreqs’); $query = “insert into requests(date, request, email, priority,status) values (NOW(),’$description’, ‘$email’, ‘$priority’, ‘NEW’)”; $res = mysql_query($query, $dbh); $query = “select max(id) from requests”; $res = mysql_query($query, $dbh); $err = mysql_error(); if($err){ echo “发生错误，请通知站长“; } $row = mysql_fetch_row($res); echo “未来您使用的号码为： “.$row[0]; ?&gt; 参考： mysql_close() mysql_pconnect() mysql_create_db 建立一个 MySQL 新数据库。 语法： int mysql_create_db(string database name, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数用来建立新的数据库 (database)。在建立前，必须先与服务器连接。 参考： mysql_drop_db() mysql_data_seek 移动内部返回指针。 语法： int mysql_data_seek(int result_identifier, int row_number); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可移动内部返回的列指针到指定的 row_number 去。之后若使用 mysql_fetch_row() 可以返回新列的值。成功返回 true、失败则返回 false。 mysql_db_query 送查询字符串 (query) 到 MySQL 数据库。 语法： int mysql_db_query(string database, string query, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数用来送出查询字符串 (query) 到后端的 MySQL 数据库中。而可省略的参数 link_identifier 若不存在，程序会自动寻找其它 mysql_connect() 连接后的连接代码。发生错误时会返回 false，其它没错误时则返回它的返回代码。 参考： mysql_connect() mysql_drop_db 移除数据库。 语法： int mysql_drop_db(string database_name, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数移除已存在的数据库。成功返回 true、失败则返回 false。 参考： mysql_create_db() mysql_errno 返回错误信息代码。 语法： int mysql_errno(int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到 MySQL 数据库服务器的错误代码。通常用在 PHP 网页程序开发阶段，作为 PHP 与 MySQL 的除错用。 使用范例 &lt;?php mysql_connect(“marliesle”); echo mysql_errno().”： “.mysql_error().”“; mysql_select_db(“nonexistentdb”); echo mysql_errno().”： “.mysql_error().”“; $conn = mysql_query(“SELECT * FROM nonexistenttable”); echo mysql_errno().”： “.mysql_error().”“; ?&gt; 参考： mysql_error() mysql_error 返回错误信息。 语法： string mysql_error(int [link_identifier]); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数可以得到 MySQL 数据库服务器的错误信息。通常用在 PHP 网页程序开发阶段，与 mysql_errno() 一起作为PHP 与 MySQL 的除错用。 参考： mysql_errno() mysql_fetch_array 返回数组资料。 语法： array mysql_fetch_array(int result, int [result_typ]); 返回值： 数组 函数种类： 数据库功能 内容说明： 本函数用来将查询结果 result 拆到数组变量中。若 result 没有资料，则返回 false 值。而本函数可以说是 mysql_fetch_row() 的加强函数，除可以将返回列及数字索引放入数组之外，还可以将文字索引放入数组中。若是好几个返回字段都是相同的文字名称，则最后一个置入的字段有效，解 决方法是使用数字索引或者为这些同名的字段 (column) 取别名 (alias)。治募注意的是使用本函数的处理速度其实不会比 mysql_fetch_row() 函数慢，要用哪个函数还是看使用的需求决定。参数 result_typ 是一个常量值，有以下几种常量 MYSQL_ASSOC、MYSQL_NUM 与 MYSQL_BOTH。 使用范例 &lt;?php mysql_connect($host,$user,$password); $result = mysql_db_query(“database”,”select * from table”); while($row = mysql_fetch_array($result)) { echo $row[“user_id”]; echo $row[“fullname”]; } mysql_free_result($result); ?&gt; mysql_fetch_field 取得字段信息。 语法： object mysql_fetch_field(int result, int [field_offset]); 返回值： 类 函数种类： 数据库功能 内容说明： 本函数返回的类资料为 result 的字段 (Column) 信息。返回类的属性如下： name - 字段名称 table - 字段所在表格的资料表名称 max_length - 字段的最大长度 not_null - 若为 1 表示本字段不能是空的 (null) primary_key - 若为 1 表示本字段是主要键 (primary key) unique_key - 若为 1 表示本字段为不可重覆键 (unique key) multiple_key - 若为 1 表示本字段为可重覆键 (non-unique key) numeric - 若为 1 表示本字段为数字类型 (numeric) blob - 若为 1 表示本字段为位类型 (BLOB) type - 字段类型 unsigned - 若为 1 表示本字段为无记号 (unsigned) zerofill - 若为 1 表示本字段为被零填满 (zero-filled) 参考： mysql_field_seek() mysql_fetch_lengths 返回单列各栏资料最大长度。 语法： array mysql_fetch_lengths(int result); 返回值： 数组 函数种类： 数据库功能 内容说明： 本函数将 mysql_fetch_row() 处理过的最后一列资料的各字段资料最大长度放在数组变量之中。若执行失败则返回 false 值。返回数组的第一笔资料索引值是 0。 参考： mysql_fetch_row() mysql_fetch_object 返回类资料。 语法： object mysql_fetch_object(int result, int [result_typ]); 返回值： 类 函数种类： 数据库功能 内容说明： 本函数用来将查询结果 result 拆到类变量中。使用方法和 mysql_fetch_array() 几乎相同，不同的地方在于本函数返回资料是类而不是数组。若 result 没有资料，则返回 false 值。另外治募注意的地方是，取回的类资料的索引只能是文字而不能用数字，这是因为类的特性。类资料的特性中所有的属性 (property) 名称都不能是数字，因此只好乖乖使用文字字符串当索引了。参数 result_typ是一个常量值，有以下几种常量 MYSQL_ASSOC、MYSQL_NUM 与 MYSQL_BOTH。关于速度方面，本函数的处理速度几乎和 mysql_fetch_row() 及 mysql_fetch_array() 二函数差不多，要用哪个函数还是看使用的需求决定。 使用范例，下面的例子示范如使用返回的类。 &lt;?php mysql_connect($host,$user,$password); $result = mysql_db_query(“MyDatabase”,”select * from test”); while($row = mysql_fetch_object($result)) { echo $row-&gt;user_id; echo $row-&gt;fullname; } mysql_free_result($result); ?&gt; 参考： mysql_fetch_array() mysql_fetch_row() mysql_fetch_row 返回单列的各字段。 语法： array mysql_fetch_row(int result); 返回值： 数组 函数种类： 数据库功能 内容说明： 本函数用来将查询结果 result 之单列拆到数组变量中。数组的索引是数字索引，第一个的索引值是 0。若 result 没有资料，则返回 false 值。参考： mysql_fetch_array() mysql_fetch_object() mysql_data_seek() mysql_fetch_lengths() mysql_result() mysql_field_name 返回指定字段的名称。 语法： string mysql_field_name(int result, int field_index); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数用来取得指定字段的名称。 使用范例 mysql_field_name($result,2); mysql_field_seek 配置指针到返回治募某字段。 语法： int mysql_field_seek(int result, int field_offset); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数配置目前的指针到返回治募特定字段中。 参考： mysql_fetch_field() mysql_field_table 获得目前字段的资料表 (table) 名称。 语法： string mysql_field_table(int result, int field_offset); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数可以得到目前所在字段的资料表名。 mysql_field_type 获得目前字段的类型。 语法： string mysql_field_type(int result, int field_offset); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数可以得到目前所在字段的类型格式。返回的字符串为字段的类型，包括了 int、real、string、blob….等等，详见 MySQL 的相关文件中有关于类型的部份。 使用范例 &lt;?php mysql_connect(“localhost：3306”); mysql_select_db(“wisconsin”); $result = mysql_query(“SELECT * FROM onek”); $fields = mysql_num_fields($result); $rows = mysql_num_rows($result); $i = 0; $table = mysql_field_table($result, $i); echo “资料表 ‘“.$table.”‘ 有 “.$fields.” 栏及 “.$rows.” 列。“; echo “本资料表的字段如下“; while ($i &lt; $fields) { $type = mysql_field_type ($result, $i); $name = mysql_field_name ($result, $i); $len = mysql_field_len ($result, $i); $flags = mysql_field_flags ($result, $i); echo $type.” “.$name.” “.$len.” “.$flags.”“; $i++; } mysql_close(); ?&gt; mysql_field_flags 获得目前字段的标志。 语法： string mysql_field_flags(int result, int field_offset); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数可以得到目前所在字段的标志。若一个字段有数种属性标志，则返回的标志为这些属性连起来的字符串，每个属性都用空格隔开，可以使用 explode() 切开这些字符串。返回的标志可能是：not_null、primary_key、unique_key、multiple_key、blob、 unsigned、zerofill、binary、enum、auto_increment、timestamp。 mysql_field_len 获得目前字段的长度。 语法： int mysql_field_len(int result, int field_offset); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到目前所在字段的长度。 mysql_free_result 释放返回占用内存。 语法： boolean mysql_free_result(int result); 返回值： 布尔值 函数种类： 数据库功能 内容说明： 本函数可以释放目前 MySQL 数据库 query 返回所占用的内存。一般只有在非常担心在内存的使用上可能会不足的情形下才会用本函数。PHP 程序会在结束时自动释放。 mysql_insert_id 返回最后一次使用 INSERT 指令的 ID。 语法： int mysql_insert_id(int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到最后一次使用 INSERT 到 MySQL 数据库的执行 ID。sleibowitz@btcwcu.org (13-May-1999) 指出在 PHP 3.0.7版用 REPLACE 也和使用 INSERT 一样，可以使用本函数获得 ID。 mysql_list_fields 列出指定资料表的字段 (field)。 语法： int mysql_list_fields(string database_name, string table_name, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到指定的资料表的所有字段。返回的字段信息可以供 mysql_field_flags()、mysql_field_len()、mysql_field_name() 及 mysql_field_type() 等函数使用。若有错误则返回 -1。 mysql_list_dbs 列出 MySQL 服务器可用的数据库 (database)。 语法： int mysql_list_dbs(int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到 MySQL 服务器的可用数据库。 mysql_list_tables 列出指定数据库的资料表 (table)。 语法： int mysql_list_tables(string database, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到指定数据库中的所有资料表名称。 mysql_num_fields 取得返回字段的数目。 语法： int mysql_num_fields(int result); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到返回字段的数目。 参考： mysql_db_query() mysql_query() mysql_fetch_field() mysql_num_rows() mysql_num_rows 取得返回列的数目。 语法： int mysql_num_rows(int result); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数可以得到返回列的数目。 参考： mysql_db_query() mysql_query() mysql_fetch_row() mysql_pconnect 打开 MySQL 服务器持续连接。 语法： int mysql_pconnect(string [hostname] [：port], string [username], string [password]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数和 mysql_connect() 雷同。不同的地方在于使用本函数打开数据库时，程序会先寻找是否曾经执行过本函数，若执行过则返回先前执行的 ID。另一个不同的地方是本函数无法使用 mysql_close() 关闭数据库。 mysql_query 送出一个 query 字符串。 语法： int mysql_query(string query, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数送出 query 字符串供 MySQL 做相关的处理或者执行。若没有指定 link_identifier 参数，则程序会自动寻找最近打开的 ID。当 query 查询字符串是 UPDATE、INSERT 及 DELETE 时，返回的可能是 true 或者 false；查询的字符串是 SELECT 则返回新的 ID 值。joey@samaritan.com (09-Feb-1999) 指出，当返回 false 时，并不是执行成功但无返回值，而是查询的字符串有错误。 参考： mysql_db_query() mysql_select_db() mysql_connect() mysql_result 取得查询 (query) 的结果。 语法： int mysql_result(int result, int row, mixed field); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数取得一格 query 的结果。参数 field 可以是字段名称、顺序或者是 FieldName.TableName 的格式。在返回资料量少时，可以使用本函数来处理。当数据库大时，本函数的效率就有待考量了，这时可以使用较有效率的 mysql_fetch_row()、mysql_fetch_array() 及 mysql_fetch_object() 等函数。 mysql_select_db 选择一个数据库。 语法： int mysql_select_db(string database_name, int [link_identifier]); 返回值： 整数 函数种类： 数据库功能 内容说明： 本函数选择 MySQL 服务器中的数据库以供之后的资料查询作业 (query) 处理。成功返回 true，失败则返回 false。 参考： mysql_connect() mysql_pconnect() mysql_query() mysql_tablename 取得资料表名称。 语法： string mysql_tablename(int result, int i); 返回值： 字符串 函数种类： 数据库功能 内容说明： 本函数可取得资料表名称字符串，一般配合 mysql_list_tables() 函数使用，取得该函返回的数字的名称字符串。 使用范例 &lt;?php mysql_connect (“localhost：3306”); $result = mysql_list_tables (“wisconsin”); $i = 0; while ($i &lt; mysql_num_rows ($result)) { $tb_names[$i] = mysql_tablename ($result, $i); echo $tb_names[$i] . ““; $i++; } ?&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql主从复制与读写分离]]></title>
    <url>%2F2019%2F04%2F14%2Fysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[读写分离第一种：php程序上自己做逻辑判断，写php代码的时候，自己在程序上做逻辑判读写匹配。select，insert、update、delete做正则匹配，根据结果选择写服务器（主服务器）。如果是select操作则选择读服务器（从服务器器） mysql_connect(‘读写的区分’) 第二种：MySQL- Proxy是实现”读写分离(Read/Write Splitting)”的一个软件（MySQL官方提供 ，也叫中间件）基本的原理让主数据库处理写操作（insert、update、delete），而从数据库处理查询操作（select）。而数据库的一致性则通过主从复制来实现。 主从复制在一主多从的数据库体系中，多个从服务器采用异步的方式更新主数据库的变化，业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，读操作则是在各从服务器上进行。 MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php面试题]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/m_nanle_xiaobudiu/article/details/79251726 php常用框架、模板引擎框架：如CI、Yii、Laravel，thinkphp模板引擎：smarty AJAX的优势？ajax是异步传输技术，可以通过javascript实现，也可以通过JQuery框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。 程序的开发中提高程序的运行效率？（1）优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询。（2）数据表中创建索引。（3）对程序中经常用到的数据生成缓存（比如使用redis缓存数据，比如使用ob进行动态页面静态化等等）。（4）对mysql做主从复制，读写分离。（提高mysq执行效率和查询速度）（5）使用nginx做负载均衡。（将访问压力平均分配到多态服务器） MVC①可以实现代码的重用性，避免产生代码冗余；②M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式 jsonJSON(JavaScript Object Notation)是一种轻量级的数据交换格式，json数据格式固定，可以被多种语言用作数据的传递。PHP中处理json格式的函数为json_decode( string $json [, bool $assoc ] ) ，接受一个 JSON格式的字符串并且把它转换为PHP变量，Json_encode：将PHP变量转换成json格式。 Print、echo、print_r区别（1） echo和print都可以做输出，不同的是，echo不是函数，没有返回值，而print是一个函数有返回值，所以相对而言如果只是输出echo会更快，而print_r通常用于打印变量的相关信息，通常在调试中使用。（2） print 是打印字符串（3）print_r 则是打印复合类型 如数组 对象 SESSION与COOKIE的区别？（1）存储位置：session存储于服务器，cookie存储于浏览器（2）安全性：session安全性比cookie高（3）session为‘会话服务’，在使用时需要开启服务，cookie不需要开启，可以直接用 PHP操作文件的常用函数？（重点看函数的‘参数’和‘返回值’） （1）打开文件 fopen()$file = fopen(“/home/test/test.txt”,”r”);http://www.w3school.com.cn/php/func_filesystem_fopen.asp（2）读取文件 fgets() ; 注：file_get_contents()也是读取文件fgets() 函数从文件指针中读取一行。fgets(file,length)（3）写入文件fwrite() ; 注：file_put_contents()同样可以写入文件（4）关闭文件句柄 fclose()（5）移动 / 重命名文件 rename()（6）复制文件 copy()（7）创建文件 vim 或 touch（8）删除文件 unlink()（9）获取文件上次访问的时间 fileatime()（10）获取文件上次修改的时间 filemtime()（11）获取文件大小 filesize()（12）获取文件类型 filetype()（13）获取文件详细信息 state()（14）判断是否是目录 is_dir() 试述视图的优点？(1) 视图能够简化用户的操作(2) 视图使用户能以多种角度看待同一数据；(3) 视图为数据库提供了一定程度的逻辑独立性；(4) 视图能够对机密数据提供安全保护。 优化MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？（1）设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。（2） 选择合适的表字段数据类型和存储引擎，适当的添加索引。（3） 做mysql主从复制读写分离。（4）对数据表进行分表，减少单表中的数据量提高查询速度。（5）添加缓存机制，比如redis，memcached等。（6）对不经常改动的页面，生成静态页面（比如做ob缓存）。（7）书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 简述 private、 protected、 public修饰符的访问权限。private : 私有成员, 在类的内部才可以访问。 protected : 保护成员，该类内部和继承类中可以访问。 public : 公共成员，完全公开，没有访问限制。 堆和栈的区别？栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义； 堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。 XML 与 HTML 的主要区别语法要求不同： （1）在html中不区分大小写，在xml中严格区分。 （2）在HTML中，有时不严格，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略或者之类的结束标记。在XML中，是严格的树状结构，绝对不能省略掉结束标记。 （3） 在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个/ 字符作为结尾。这样分析器就知道不用查找结束标记了。 （4）在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。 （5）在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。 （6） 在XML文档中，空白部分不会被解析器自动删除；但是html是过滤掉空格的。 标记不同： （1）html使用固有的标记；而xml没有固有的标记。 （2）Html标签是预定义的；XML标签是免费的、自定义的、可扩展的。 作用不同： （1）html是用来显示数据的；xml是用来描述数据、存放数据的，所以可以作为持久化的介质！Html将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。 XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。 （2）xml不是HTML的替代品，xml和html是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同HTML 的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。 （3）对于XML最好的形容可能是: XML是一种跨平台的，与软、硬件无关的，处理与传输信息的工具。 （4）XML未来将会无所不在。XML将成为最普遍的数据处理和数据传输的工具。 抽象类和接口的概念以及区别？抽象类：它是一种特殊的，不能被实例化的类，只能作为其他类的父类使用。使用abstract关键字声明。接口：它是一种特殊的抽象类，也是一个特殊的类，使用interface声明。 区别：（1）抽象类的操作通过继承关键字extends实现，而接口的使用是通过implements关键字来实现。（2）抽象类中有数据成员，可以实现数据的封装，但是接口没有数据成员。（3）抽象类中可以有构造方法，但是接口没有构造方法。（4）抽象类的方法可以通过private、protected、public关键字修饰（抽象方法不能是private），而接口中的方法只能使用public关键字修饰。（5）一个类只能继承于一个抽象类，而一个类可以同时实现多个接口。（6）抽象类中可以有成员方法的实现代码，而接口中不可以有成员方法的实现代码。 什么是构造函数，什么是析构函数，作用是什么？构造函数（方法）是对象创建完成后第一个被对象自动调用的方法。它存在于每个声明的类中，是一个特殊的成员方法。作用是执行一些初始化的任务。Php中使用__construct()声明构造方法，并且只能声明一个。 析构函数（方法）作用和构造方法正好相反，是对象被销毁之前最后一个被对象自动调用的方法。是PHP5中新添加的内容作用是用于实现在销毁一个对象之前执行一些特定的操作，诸如关闭文件和释放内存等。]]></content>
      <tags>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B+树]]></title>
    <url>%2F2019%2F04%2F12%2F-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B+树 节点中有重复元素，而且叶子节点还用指针连在一起每一个父节点的元素都出现在子节点中，是子节点的最大（或最小元素） 根节点元素8是子节点2,5,8的最大元素，也是子节点6,8的最大元素根节点15是11,15的最大元素，也是叶子节点13,15的最大元素 根节点的最大元素（15），以后无论插入删除多少元素，始终保持最大元素在根节点当中。B+树的叶子节点包含了根节点的全部元素信息 并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。 卫星数据，指的是索引元素锁指向的数据记录，不如数据库中的某一行。B-树中，无论中间节点还是叶子节点都带有卫星数据。B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树的查询速度为什么快单元素查询中，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。找3，第一次磁盘IO： 第二次磁盘IO： 第三次磁盘IO： B+树比B-树更加矮胖（中间节点不存卫星可以容纳更多数据），查询IO更小，更加稳定 B+树范围查找 只需要在链表上遍历即可，以下为查找3-11 自顶向下，查找到范围的下限（3）：通过链表指针，遍历到元素6, 8： 通过链表指针，遍历到元素9, 11，遍历结束： B+树的特征：1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。B+树的优势：1.单一节点存储更多的元素，使得查询的IO次数更少。2.所有查询都要查找到叶子节点，查询性能稳定。3.所有叶子节点形成有序链表，便于范围查询。]]></content>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树、二叉排序树、完全二叉树、满二叉树]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树来自二叉排序树的旋转为了保证树不至于台倾斜，尽量保证两边平衡。1、平衡二叉树要么是一棵空树2、要么保证左右子树的高度之差不大于 13、子树也必须是一颗平衡二叉树平衡二叉树在添加和删除时需要进行旋转保证整个树的平衡，使用平衡二叉树时，插入、查找时间复杂度都是O(logn) 完全二叉树完全二叉树：对于一个树高为h的二叉树，如果其第0层至第h-1层的节点都满。如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。这样的二叉树就是一棵完全二叉树。完全二叉树最重要的性质：如果n个节点的完全二叉树的节点按照层次并按从左到右的顺序从0开始编号，对于人一个绩点都有： ·序号为0的节点是根·对于i&gt;0，其父节点的编号为(i-1)/2。·若2i+1&lt;n，其左子节点的序号为2i+1，否则没有左子节点。·若2i+2&lt;n，其右子节点的序号为2i+2，否则没有右子节点。 满二叉树满二叉树：树中每个分支结点（非叶结点）都有两棵非空子树 使二叉树可以方便的存入表或者数组，直接根绝元素下标就可以找到一个节点的子节点或者父节点(也就是可以完全确定二叉树的结构)，无须用额外的形式记录树结构信息。使其可以方便地存入一系列连续位置，一般二叉树不能方便地映射到线性结构，完全二叉树到线性结构有定义非常自然的双向映射，可以方便地从其线性结构恢复完全二叉树。 二叉排序树在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；]]></content>
  </entry>
  <entry>
    <title><![CDATA[mvcc多版本并发控制]]></title>
    <url>%2F2019%2F04%2F12%2Fcc%2F</url>
    <content type="text"><![CDATA[https://www.jianshu.com/p/cef49aeff36bhttps://www.cnblogs.com/phpper/p/6937650.html MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。MVCC可以看作一种乐观锁的实现方式 基本特征每行数据都存在一个版本，每次数据更新时都更新该版本。修改时Copy出当前版本随意修改，各个事务之间无干扰。保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback） InnoDB存储引擎MVCC的实现策略在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。 每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。 MVCC优缺点MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。 mvcc如何解决幻读保证一个事务读不了在它之后插入的数据，读不了在它之前删除的数据读的了在它之前插入的数据，读的了在它之后删除的数据 查询条件1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)。不能读取&lt;=当前事务版本号的被删除数据 2) 创建版本号&lt;=当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。 不能读取在当前事务之后创建的数据 当前事务版本号为100，能够读取：数据的删除版本号&gt;100且创建版本号&lt;=100 多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号+1。在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号&lt;=当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。例如：此时books表中有5条数据，版本号为1事务A，系统版本号2：select from books；因为1&lt;=2所以此时会读取5条数据。事务B，系统版本号3：insert into books …，插入一条数据，新插入的数据版本号为3，而其他的数据的版本号仍然是2，插入完成之后commit，事务结束。事务A，系统版本号2：再次select from books；只能读取&lt;=2的数据，事务B新插入的那条数据版本号为3，因此读不出来，解决了幻读的问题。 1：当前读:给改条数据加锁(悲观锁),即读取的时候就加锁，防止其他事务读取该数据().它能保证读取的都是最新数据2：快照读:mvcc，多版本并发控制，详细的原理就不说了，它使得读写不冲突，由于读的都是事务的当前版本的数据，因此重复读也不会发现数据被修改 DELETEInnoDB会为删除的每一行保存当前事务的ID作为删除标识. UPDATEInnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树红黑树（Red Black Tree） 是一种自平衡二叉查找树红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。 (1) 每个节点或者是黑色，或者是红色。(2) 根节点是黑色。(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！](4) 如果一个节点是红色的，则它的子节点必须是黑色的。(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 由于父节点22是红色节点，因此这种情况打破了红黑树的规则4，必须作出调整，两种方式：变色，旋转 变色为了符合红黑树的规则，会把节点红变黑，或者黑变红。下图节点25并非根节点，因为21和22连接出现红色，不符合规则4，所以把22红变黑例子：但是这样还是不符合规则5，所以需要把25黑变红： 25和27又是两个连续的红色节点（规则4），所以需要将27红变黑 结束 左旋转逆时针旋转两个节点，使父节点被自己的右孩子取代，而自己成为自己的左孩子： 右旋转顺时针旋转两个节点，使自己的父节点被左孩子取代，而自己成为自己的右孩子： 还是以刚才的例子为例 首先开始变色，把节点25及以下的节点变色 由于17和25是连续的两个红色节点，那么把节点17变黑吗？这样会与规则4冲突，根据规则2也不能将13变成红色，变色已经不能解决问题了，所以只能进行旋转。13当成X，17当成Y，左旋转试试： 由于根节点必须是黑色，所以需要变色 其中有两条路径（17-6-null）的黑色节点个数不是3，不符合规则，这时需要把13当做X，8当做Y，进行右旋转； 最后根据规则变色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529&lt;?php/** * author:zhongjin * time:2016/10/20 11:53 * description: 红黑树 *///结点class Node&#123; public $key; public $parent; public $left; public $right; public $IsRed; //分辨红节点或黑节点 public function __construct($key, $IsRed = TRUE) &#123; $this-&gt;key = $key; $this-&gt;parent = NULL; $this-&gt;left = NULL; $this-&gt;right = NULL; //插入结点默认是红色 $this-&gt;IsRed = $IsRed; &#125;&#125;//红黑树class Rbt&#123; public $root; /** * 初始化树结构 * @param $arr 初始化树结构的数组 * @return null */ public function init($arr) &#123; //根节点必须是黑色 $this-&gt;root = new Node($arr[0], FALSE); for ($i = 1; $i &lt; count($arr); $i++) &#123; $this-&gt;Insert($arr[$i]); &#125; &#125; /** * （对内）中序遍历 * @param $root （树或子树的）根节点 * @return null */ private function mid_order($root) &#123; if ($root != NULL) &#123; $this-&gt;mid_order($root-&gt;left); echo $root-&gt;key . "-" . ($root-&gt;IsRed ? 'r' : 'b') . ' '; $this-&gt;mid_order($root-&gt;right); &#125; &#125; /** * （对外）中序遍历 * @param null * @return null */ public function MidOrder() &#123; $this-&gt;mid_order($this-&gt;root); &#125; /** * 查找树中是否存在$key对应的节点 * @param $key 待搜索数字 * @return $key对应的节点 */ function search($key) &#123; $current = $this-&gt;root; while ($current != NULL) &#123; if ($current-&gt;key == $key) &#123; return $current; &#125; elseif ($current-&gt;key &gt; $key) &#123; $current = $current-&gt;left; &#125; else &#123; $current = $current-&gt;right; &#125; &#125; //结点不存在 return $current; &#125; /** * 将以$root为根节点的最小不平衡二叉树做右旋处理 * @param $root（树或子树）根节点 * @return null */ private function R_Rotate($root) &#123; $L = $root-&gt;left; if (!is_null($root-&gt;parent)) &#123; $P = $root-&gt;parent; if($root == $P-&gt;left)&#123; $P-&gt;left = $L; &#125;else&#123; $P-&gt;right = $L; &#125; $L-&gt;parent = $P; &#125; else &#123; $L-&gt;parent = NULL; &#125; $root-&gt;parent = $L; $root-&gt;left = $L-&gt;right; $L-&gt;right = $root; //这句必须啊！ if ($L-&gt;parent == NULL) &#123; $this-&gt;root = $L; &#125; &#125; /** * 将以$root为根节点的最小不平衡二叉树做左旋处理 * @param $root（树或子树）根节点 * @return null */ private function L_Rotate($root) &#123; $R = $root-&gt;right; if (!is_null($root-&gt;parent)) &#123; $P = $root-&gt;parent; if($root == $P-&gt;right)&#123; $P-&gt;right = $R; &#125;else&#123; $P-&gt;left = $R; &#125; $R-&gt;parent = $P; &#125; else &#123; $R-&gt;parent = NULL; &#125; $root-&gt;parent = $R; $root-&gt;right = $R-&gt;left; $R-&gt;left = $root; //这句必须啊！ if ($R-&gt;parent == NULL) &#123; $this-&gt;root = $R; &#125; &#125; /** * 查找树中的最小关键字 * @param $root 根节点 * @return 最小关键字对应的节点 */ function search_min($root) &#123; $current = $root; while ($current-&gt;left != NULL) &#123; $current = $current-&gt;left; &#125; return $current; &#125; /** * 查找树中的最大关键字 * @param $root 根节点 * @return 最大关键字对应的节点 */ function search_max($root) &#123; $current = $root; while ($current-&gt;right != NULL) &#123; $current = $current-&gt;right; &#125; return $current; &#125; /** * 查找某个$key在中序遍历时的直接前驱节点 * @param $x 待查找前驱节点的节点引用 * @return 前驱节点引用 */ function predecessor($x) &#123; //左子节点存在，直接返回左子节点的最右子节点 if ($x-&gt;left != NULL) &#123; return $this-&gt;search_max($x-&gt;left); &#125; //否则查找其父节点，直到当前结点位于父节点的右边 $p = $x-&gt;parent; //如果x是p的左孩子，说明p是x的后继，我们需要找的是p是x的前驱 while ($p != NULL &amp;&amp; $x == $p-&gt;left) &#123; $x = $p; $p = $p-&gt;parent; &#125; return $p; &#125; /** * 查找某个$key在中序遍历时的直接后继节点 * @param $x 待查找后继节点的节点引用 * @return 后继节点引用 */ function successor($x) &#123; if ($x-&gt;left != NULL) &#123; return $this-&gt;search_min($x-&gt;right); &#125; $p = $x-&gt;parent; while ($p != NULL &amp;&amp; $x == $p-&gt;right) &#123; $x = $p; $p = $p-&gt;parent; &#125; return $p; &#125; /** * 将$key插入树中 * @param $key 待插入树的数字 * @return null */ public function Insert($key) &#123; if (!is_null($this-&gt;search($key))) &#123; throw new Exception('结点' . $key . '已存在，不可插入！'); &#125; $root = $this-&gt;root; $inode = new Node($key); $current = $root; $prenode = NULL; //为$inode找到合适的插入位置 while ($current != NULL) &#123; $prenode = $current; if ($current-&gt;key &gt; $inode-&gt;key) &#123; $current = $current-&gt;left; &#125; else &#123; $current = $current-&gt;right; &#125; &#125; $inode-&gt;parent = $prenode; //如果$prenode == NULL， 则证明树是空树 if ($prenode == NULL) &#123; $this-&gt;root = $inode; &#125; else &#123; if ($inode-&gt;key &lt; $prenode-&gt;key) &#123; $prenode-&gt;left = $inode; &#125; else &#123; $prenode-&gt;right = $inode; &#125; &#125; //将它重新修正为一颗红黑树 $this-&gt;InsertFixUp($inode); &#125; /** * 对插入节点的位置及往上的位置进行颜色调整 * @param $inode 插入的节点 * @return null */ private function InsertFixUp($inode) &#123; //情况一：需要调整条件，父节点存在且父节点的颜色是红色 while (($parent = $inode-&gt;parent) != NULL &amp;&amp; $parent-&gt;IsRed == TRUE) &#123; //祖父结点： $gparent = $parent-&gt;parent; //如果父节点是祖父结点的左子结点，下面的else与此相反 if ($parent == $gparent-&gt;left) &#123; //叔叔结点 $uncle = $gparent-&gt;right; //case1:叔叔结点也是红色 if ($uncle != NULL &amp;&amp; $uncle-&gt;IsRed == TRUE) &#123; //将父节点和叔叔结点都涂黑，将祖父结点涂红 $parent-&gt;IsRed = FALSE; $uncle-&gt;IsRed = FALSE; $gparent-&gt;IsRed = TRUE; //将新节点指向祖父节点（现在祖父结点变红，可以看作新节点存在） $inode = $gparent; //继续while循环，重新判断 continue; //经过这一步之后，组父节点作为新节点存在（跳到case2） &#125; //case2:叔叔结点是黑色，且当前结点是右子节点 if ($inode == $parent-&gt;right) &#123; //以父节点作为旋转结点做左旋转处理 $this-&gt;L_Rotate($parent); //在树中实际上已经转换，但是这里的变量的指向还没交换， //将父节点和字节调换一下，为下面右旋做准备 $temp = $parent; $parent = $inode; $inode = $temp; &#125; //case3:叔叔结点是黑色，而且当前结点是父节点的左子节点 $parent-&gt;IsRed = FALSE; $gparent-&gt;IsRed = TRUE; $this-&gt;R_Rotate($gparent); &#125; //如果父节点是祖父结点的右子结点，与上面完全相反 else &#123; //叔叔结点 $uncle = $gparent-&gt;left; //case1:叔叔结点也是红色 if ($uncle != NULL &amp;&amp; $uncle-&gt;IsRed == TRUE) &#123; //将父节点和叔叔结点都涂黑，将祖父结点涂红 $parent-&gt;IsRed = FALSE; $uncle-&gt;IsRed = FALSE; $gparent-&gt;IsRed = TRUE; //将新节点指向祖父节点（现在祖父结点变红，可以看作新节点存在） $inode = $gparent; //继续while循环，重新判断 continue; //经过这一步之后，组父节点作为新节点存在（跳到case2） &#125; //case2:叔叔结点是黑色，且当前结点是左子节点 if ($inode == $parent-&gt;left) &#123; //以父节点作为旋转结点做右旋转处理 $this-&gt;R_Rotate($parent); //在树中实际上已经转换，但是这里的变量的指向还没交换， //将父节点和字节调换一下，为下面右旋做准备 $temp = $parent; $parent = $inode; $inode = $temp; &#125; //case3:叔叔结点是黑色，而且当前结点是父节点的右子节点 $parent-&gt;IsRed = FALSE; $gparent-&gt;IsRed = TRUE; $this-&gt;L_Rotate($gparent); &#125; &#125; //情况二：原树是根节点（父节点为空），则只需将根节点涂黑 if ($inode == $this-&gt;root) &#123; $this-&gt;root-&gt;IsRed = FALSE; return; &#125; //情况三：插入节点的父节点是黑色，则什么也不用做 if ($inode-&gt;parent != NULL &amp;&amp; $inode-&gt;parent-&gt;IsRed == FALSE) &#123; return; &#125; &#125; /** * （对外）删除指定节点 * @param $key 删除节点的key值 * @return null */ function Delete($key) &#123; if (is_null($this-&gt;search($key))) &#123; throw new Exception('结点' . $key . "不存在，删除失败！"); &#125; $dnode = $this-&gt;search($key); if ($dnode-&gt;left == NULL || $dnode-&gt;right == NULL) &#123; #如果待删除结点无子节点或只有一个子节点，则c = dnode $c = $dnode; &#125; else &#123; #如果待删除结点有两个子节点，c置为dnode的直接后继，以待最后将待删除结点的值换为其后继的值 $c = $this-&gt;successor($dnode); &#125; //为了后面颜色处理做准备 $parent = $c-&gt;parent; //无论前面情况如何，到最后c只剩下一边子结点 if ($c-&gt;left != NULL) &#123; //这里不会出现，除非选择的是删除结点的前驱 $s = $c-&gt;left; &#125; else &#123; $s = $c-&gt;right; &#125; if ($s != NULL) &#123; #将c的子节点的父母结点置为c的父母结点，此处c只可能有1个子节点，因为如果c有两个子节点，则c不可能是dnode的直接后继 $s-&gt;parent = $c-&gt;parent; &#125; if ($c-&gt;parent == NULL) &#123; #如果c的父母为空，说明c=dnode是根节点，删除根节点后直接将根节点置为根节点的子节点，此处dnode是根节点，且拥有两个子节点，则c是dnode的后继结点，c的父母就不会为空，就不会进入这个if $this-&gt;root = $s; &#125; else if ($c == $c-&gt;parent-&gt;left) &#123; #如果c是其父节点的左右子节点，则将c父母的左右子节点置为c的左右子节点 $c-&gt;parent-&gt;left = $s; &#125; else &#123; $c-&gt;parent-&gt;right = $s; &#125; $dnode-&gt;key = $c-&gt;key; $node = $s; //c的结点颜色是黑色，那么会影响路径上的黑色结点的数量，必须进行调整 if ($c-&gt;IsRed == FALSE) &#123; $this-&gt;DeleteFixUp($node,$parent); &#125; &#125; /** * 删除节点后对接点周围的其他节点进行调整 * @param $key 删除节点的子节点和父节点 * @return null */ private function DeleteFixUp($node,$parent) &#123; //如果待删结点的子节点为红色，直接将子节点涂黑 if ($node != NULL &amp;&amp; $node-&gt;IsRed == TRUE) &#123; $node-&gt;IsRed = FALSE; return; &#125; //如果是根节点，那就直接将根节点置为黑色即可 while (($node == NULL || $node-&gt;IsRed == FALSE) &amp;&amp; ($node != $this-&gt;root)) &#123; //node是父节点的左子节点，下面else与这里相反 if ($node == $parent-&gt;left) &#123; $brother = $parent-&gt;right; //case1:兄弟结点颜色是红色（父节点和兄弟孩子结点都是黑色） //将父节点涂红，将兄弟结点涂黑，然后对父节点进行左旋处理（经过这一步，情况转换为兄弟结点颜色为黑色的情况） if ($brother-&gt;IsRed == TRUE) &#123; $brother-&gt;IsRed = FALSE; $parent-&gt;IsRed = TRUE; $this-&gt;L_Rotate($parent); //将情况转化为其他的情况 $brother = $parent-&gt;right; //在左旋处理后，$parent-&gt;right指向的是原来兄弟结点的左子节点 &#125; //以下是兄弟结点为黑色的情况 //case2:兄弟结点是黑色，且兄弟结点的两个子节点都是黑色 //将兄弟结点涂红，将当前结点指向其父节点，将其父节点指向当前结点的祖父结点。 if (($brother-&gt;left == NULL || $brother-&gt;left-&gt;IsRed == FALSE) &amp;&amp; ($brother-&gt;right == NULL || $brother-&gt;right-&gt;IsRed == FALSE)) &#123; $brother-&gt;IsRed = TRUE; $node = $parent; $parent = $node-&gt;parent; &#125; else &#123; //case3:兄弟结点是黑色，兄弟结点的左子节点是红色，右子节点为黑色 //将兄弟结点涂红，将兄弟节点的左子节点涂黑，然后对兄弟结点做右旋处理（经过这一步，情况转换为兄弟结点颜色为黑色，右子节点为红色的情况） if ($brother-&gt;right == NULL || $brother-&gt;right-&gt;IsRed == FALSE) &#123; $brother-&gt;IsRed = TRUE; $brother-&gt;left-&gt;IsRed = FALSE; $this-&gt;R_Rotate($brother); //将情况转换为其他情况 $brother = $parent-&gt;right; &#125; //case4:兄弟结点是黑色，且兄弟结点的右子节点为红色，左子节点为任意颜色 //将兄弟节点涂成父节点的颜色，再把父节点涂黑，将兄弟结点的右子节点涂黑，然后对父节点做左旋处理 $brother-&gt;IsRed = $parent-&gt;IsRed; $parent-&gt;IsRed = FALSE; $brother-&gt;right-&gt;IsRed = FALSE; $this-&gt;L_Rotate($parent); //到了第四种情况，已经是最基本的情况了，可以直接退出了 $node = $this-&gt;root; break; &#125; &#125; //node是父节点的右子节点 else &#123; $brother = $parent-&gt;left; //case1:兄弟结点颜色是红色（父节点和兄弟孩子结点都是黑色） //将父节点涂红，将兄弟结点涂黑，然后对父节点进行右旋处理（经过这一步，情况转换为兄弟结点颜色为黑色的情况） if ($brother-&gt;IsRed == TRUE) &#123; $brother-&gt;IsRed = FALSE; $parent-&gt;IsRed = TRUE; $this-&gt;R_Rotate($parent); //将情况转化为其他的情况 $brother = $parent-&gt;left; //在右旋处理后，$parent-&gt;left指向的是原来兄弟结点的右子节点 &#125; //以下是兄弟结点为黑色的情况 //case2:兄弟结点是黑色，且兄弟结点的两个子节点都是黑色 //将兄弟结点涂红，将当前结点指向其父节点，将其父节点指向当前结点的祖父结点。 if (($brother-&gt;left == NULL || $brother-&gt;left-&gt;IsRed == FALSE) &amp;&amp; ($brother-&gt;right == NULL || $brother-&gt;right-&gt;IsRed == FALSE)) &#123; $brother-&gt;IsRed = TRUE; $node = $parent; $parent = $node-&gt;parent; &#125; else &#123; //case3:兄弟结点是黑色，兄弟结点的右子节点是红色，左子节点为黑色 //将兄弟结点涂红，将兄弟节点的左子节点涂黑，然后对兄弟结点做左旋处理（经过这一步，情况转换为兄弟结点颜色为黑色，右子节点为红色的情况） if ($brother-&gt;left == NULL || $brother-&gt;left-&gt;IsRed == FALSE) &#123; $brother-&gt;IsRed = TRUE; $brother-&gt;right = FALSE; $this-&gt;L_Rotate($brother); //将情况转换为其他情况 $brother = $parent-&gt;left; &#125; //case4:兄弟结点是黑色，且兄弟结点的左子节点为红色，右子节点为任意颜色 //将兄弟节点涂成父节点的颜色，再把父节点涂黑，将兄弟结点的右子节点涂黑，然后对父节点左左旋处理 $brother-&gt;IsRed = $parent-&gt;IsRed; $parent-&gt;IsRed = FALSE; $brother-&gt;left-&gt;IsRed = FALSE; $this-&gt;R_Rotate($parent); $node = $this-&gt;root; break; &#125; &#125; &#125; if ($node != NULL) &#123; $this-&gt;root-&gt;IsRed = FALSE; &#125; &#125; /** * （对内）获取树的深度 * @param $root 根节点 * @return 树的深度 */ private function getdepth($root) &#123; if ($root == NULL) &#123; return 0; &#125; $dl = $this-&gt;getdepth($root-&gt;left); $dr = $this-&gt;getdepth($root-&gt;right); return ($dl &gt; $dr ? $dl : $dr) + 1; &#125; /** * （对外）获取树的深度 * @param null * @return null */ public function Depth() &#123; return $this-&gt;getdepth($this-&gt;root); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql面试题]]></title>
    <url>%2F2019%2F04%2F12%2Fsql%E9%94%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[什么是锁？加锁可以实现数据库并发控制。事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。 mysql有哪几种锁？Myisam支持表锁，innodb支持行锁与表锁，默认为行锁（需要索引） 表锁行锁区别？表锁：开销小，加锁快，不会出现死锁，锁粒度大，发送锁冲突概率最高，并发量最低。行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高 Mysql数据库表类型？MyISAM（MySQL的默认数据表类型 事务不安全 不支持外键 假如忽略事务以及访问并发性的话，并且需要执行大量的SELECT检索语句的话，MyISAM将是最好的选择）Heap（MySQL中存取数据最快的表。这是因为他们使用存储在动态内存中的一个散列索引，不过如果MySQL或服务器崩溃，这些内存数据将会丢失。）Merge（MERGE表实际上是又一个MyISAM表的集合）INNODB（事务安全，支持外键）ISAM（早期MySQL版本的缺省表类型，直到MyIASM开发出来。建议不要再使用它）DBD（支持事务处理的表） MyISAM是Mysql的默认存储引擎。 简述在MySQL数据库中MyISAM和InnoDB的区别存储引擎是基于表的，而不是数据库。InnoDB存储引擎: 行锁设计、支持外键,支持事务，支持并发，锁粒度是支持mvcc的行级锁；MyISAM存储引擎: MySQL官方存储引擎，主要面向在线分析处理方面的应用，不支持事务，锁粒度是支持并发插入得表级锁，支持表锁和全文索引。操作速度快，不能读写操作太频繁。 四种事务隔离级别read uncommited ：读到未提交数据read committed：脏读，不可重复读repeatable read：可重读serializable ：串行事物 事务特性：事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。（2）一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态（3）隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，（4）持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 要将组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 CHAR和VARCHAR的区别？1、CHAR（M）定长，M取值0-2552、当保存char值时，在它们的右边填充空格以达到指定的长度3、当检索到char值时，尾部的空格被删除掉，char字段上的索引效率很高。4、varchar的数据类型长度支持到了65535。起始位和结束位占去了3个字节，所以其整体最大长度为65532字节5、varchar值保存时只保存需要的字符数，另加一个字节来记录长度（长度超过255时需要2个字节） LIKE声明中的％和_是什么意思？％对应于0个或更多字符，_只是LIKE语句中的一个字符。 如何在Unix和Mysql时间戳之间进行转换？UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令 列对比运算符是什么？在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。 BLOB和TEXT有什么区别？BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。 mysql_fetch_array和mysql_fetch_object的区别是什么？mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。mysql_fetch_object – 从数据库返回结果行作为对象。 MyISAM表格将在哪里存储，并且还提供其存储格式？每个MyISAM表格以三种格式存储在磁盘上：·“.frm”文件存储表定义·数据文件具有“.MYD”（MYData）扩展名·索引文件具有“.MYI”（MYIndex）扩展名 可以使用多少列创建索引？任何标准表最多可以创建16个索引列。 如果一个表有一列定义为TIMESTAMP，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。 为表中得字段选择合适得数据类型字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 NOW（）和CURRENT_DATE（）有什么区别？NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。 MySQL数据库作发布系统的存储，数据量增大的情况，怎么优化？ 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 选择合适的表字段数据类型和存储引擎，适当的添加索引。 mysql库主从读写分离。 找规律分表，减少单表中的数据量提高查询速度。 添加缓存机制，比如memcached，apc等。 不经常改动的页面，生成静态页面。 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE. 锁的优化策略 读写分离 分段加锁 减少锁持有的时间 多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 什么情况下设置了索引但无法使用1.以“%”开头的LIKE语句，模糊匹配 OR语句前后没有同时使用索引 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型） 实践中如何优化MySQLhttps://www.toutiao.com/i6599796228886626829/?group_id=6599796228886626829最好是按照以下顺序优化： 1.SQL语句及索引的优化2.数据库表结构的优化3.系统配置的优化4.硬件的优化 优化数据库的方法选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 SQL注入漏洞产生的原因？如何防止？SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。防止SQL注入的方式：开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置执行sql语句时使用addslashes进行sql语句转换Sql语句书写尽量不要省略双引号和单引号。过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 索引的底层实现原理和优化B+树，经过优化的B+树主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。 索引的目的是什么？快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 索引类型1普通索引是最基本的索引，它没有任何限制。 2唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。3组合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。 4主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 5全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。 索引优化只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引尽量使用短索引，如果可以，应该制定一个前缀长度对于经常在where子句使用的列，最好设置索引，这样会加快查找速度对于有多个列where或者order by子句的，应该建立复合索引对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引尽量不要在列上进行运算（函数操作和表达式操作）尽量不要使用not in和&lt;&gt;操作 索引对数据库系统的负面影响是什么？负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 什么情况下不宜建立索引？1、对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。2、对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 Mysql中的事务回滚机制概述事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 SQL语言包括哪几部分？每部分都有哪些操作关键字？SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等数据操纵：Select ,insert,update,delete,数据控制：grant,revoke数据查询：select 完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 1) 实体完整性：规定表的每一行在表中是惟一的实体。2) 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。3) 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。4) 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 什么叫视图？游标是什么？答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 什么是存储过程？用什么来调用？答：存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。 如何通俗地理解三个范式？第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。 范式化设计优缺点:优点:可以尽量得减少数据冗余，使得更新快，体积小缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化 反范式化:优点:可以减少表得关联，可以更好得进行索引优化缺点:数据冗余以及数据异常，数据得修改需要更多的成本 什么是基本表？什么是视图？答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 试述视图的优点？答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； (3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。 NULL是什么意思答：NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。 使用IS NULL来进行NULL判断 主键、外键和索引的区别？定义：主键–唯一标识一条记录，不能有重复的，不允许为空外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值索引–该字段没有重复值，但可以有一个空值 作用：主键–用来保证数据完整性外键–用来和其他表建立联系用的索引–是提高查询排序的速度 个数：主键–主键只能有一个外键–一个表可以有多个外键索引–一个表可以有多个唯一索引 你可以用什么来确保表格里的字段只接受特定范围里的值?Check限制，它在数据库表格里被定义，用来限制输入该列的值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[php生成器函数]]></title>
    <url>%2F2019%2F04%2F11%2Fhp%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成器函数的核心是yield关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数12345678function my_range($start,$limit)&#123; for($i=$start;$i&lt;=$limit;$i++)&#123; yield $i; &#125;&#125;foreach($arr as $num)&#123; echo $num.PHP_EOL;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[php闭包]]></title>
    <url>%2F2019%2F04%2F10%2Fp%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包函数闭包函数也叫匿名函数,是个无需函数名称的函数。也可以当函数参数使用,并且在做行参是无需分号结尾 不是所有的匿名函数都是闭包。必须是使用use的匿名才属于闭包闭包函数也可以当变量使用闭包函数其实是自动化初始化Closure类闭包函数拥有继承 代码示例12345$test = function()&#123; echo 'nihao'. PHP_EOL;&#125;;$test();var_dump($test); 输出nihaoobject(Closure)#1 (0) {} 闭包函数继承闭包函数可以采拥use接受父作用域的变量php7.1后,不可传递 superglobals , $this 和 自己重名的变量12345678910$global = 'global';$unUse = function()&#123; echo 'unUse_'.$global;&#125;;$Use = function() use($global )&#123; echo 'Use_'.$global;&#125;;echo $unUse();echo PHP_EOL;echo $Use(); 由此可见使用了use的可以进行变量值传递]]></content>
  </entry>
  <entry>
    <title><![CDATA[http1.0/1.x/2.0]]></title>
    <url>%2F2019%2F04%2F10%2Ftp1-0-2-0%2F</url>
    <content type="text"><![CDATA[线头阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 HTTP1.0和HTTP1.1缓存新特性当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活 节约带宽(100status)1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础 新增错误状态响应码在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 host字段一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，但是HTTP1.0认为每台服务器都绑定一个唯一的IP地址。web server上的多个虚拟站点可以共享同一个ip和端口。HTTP1.0是没有host域的，HTTP1.1才支持这个参数。 长连接HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段)。 请求流水线请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。 HTTPS与HTTP的一些区别HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 https不是绝对安全的HTTPS能保证的是连接的安全但https保护不了中间人攻击，这个是由不可信的用户在客户机器与服务器之间伪造一个假的站点。 SPDYSPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：1、多路复用，通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。2、请求优先级。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。如浏览器加载首页，首页的html-静态资源文件-脚本文件等加载第一时间看到网页内容。3、HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。4、基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。5、服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 HTTP2.0基于SPDY协议1、采用二进制格式而非文本格式（二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少）2、是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行3、使用报头压缩，HTTP/2降低了开销4、2.0让服务器可以将响应主动“推送”到客户端缓存中 HTTP2.0与SPDYHTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPSHTTP2.0 消息头的压缩算法采用 HPACK 而非 SPDY 采用的 DEFLATE 为什么 HTTP2.0 需要多路传输?HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。 HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 消息头为什么需要压缩?假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。 多路复用与长连接复用区别HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图： 服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：普通的客户端请求过程： 服务端推送的过程：]]></content>
      <categories>
        <category>面试必考</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试题]]></title>
    <url>%2F2019%2F04%2F10%2Fedis%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/jasontec/p/9699242.htmlhttps://www.jianshu.com/p/36a646cef11a 什么是Redis？简述它的优缺点？Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis持久化持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。两种持久化方式:RDB（默认） 和AOFRDB：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF:AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 RDB存在哪些优势呢？1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。RDB又存在哪些劣势呢？1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 AOF的优势有哪些呢？1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。AOF的劣势有哪些呢？1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。 存储结构:内容是redis通讯协议(RESP )格式的命令文本存储。比较：1、aof文件比rdb更新频率高，优先使用aof还原数据。2、aof比rdb更安全也更大3、rdb性能比aof好4、如果两个都配了优先加载AOF resphttps://www.cnblogs.com/tommy-huang/p/6051577.htmlRESP 是redis客户端和服务端之间使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好For Simple Strings the first byte of the reply is “+” 回复For Errors the first byte of the reply is “-“ 错误For Integers the first byte of the reply is “:” 整数For Bulk Strings the first byte of the reply is “$” 字符串For Arrays the first byte of the reply is “*” 数组 使用过Redis做异步队列么，你是怎么用的？有什么缺点？一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。 能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 缓存穿透一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。 如何避免？ 1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。 2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。 如何避免？1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 缓存击穿缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 Redis有哪些适合的场景？（1）会话缓存（Session Cache）最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 （2）全页缓存（FPC）除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 （3）队列Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。 （4）排行榜/计数器Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：ZRANGE user_scores 0 10 WITHSCORESAgora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 （5）发布/订阅最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！ Redis如何设置密码及验证密码？设置密码：config set requirepass 123456 授权密码：auth 123456 淘汰策略MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 怎么测试Redis的连通性？ping Redis中的管道有什么用？一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 怎么理解Redis事务？事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 Redis如何做内存优化？尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。 Redis回收进程如何工作的？一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 说说Redis哈希槽的概念？Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 Redis集群方案什么情况下会导致整个集群不可用？有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。 Redis集群方案应该怎么做？都有哪些方案？1.codis。目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。 Redis有哪几种数据淘汰策略？noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。allkeys-random: 回收随机的键使得新添加的数据有空间存放。volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据类型与应用场景]]></title>
    <url>%2F2019%2F04%2F10%2Fredis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[String字符串：格式: set key valuestring类型是Redis最基本的数据类型，一个键最大能存储512MB，string类型是二进制安全的。所以redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 应用场景：string 类型是 Redis 中最基本的数据类型，最常用的数据类型，甚至被很多玩家当成 redis 唯一的数据类型去使用。string 类型在 redis 中是二进制安全(binary safe)的,这意味着 string 值关心二进制的字符串，不关心具体格式，你可以用它存储 json 格式或 JPEG 图片格式的字符串。 Hash（哈希）Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 应用场景：hash 类型十分适合存储对象类数据，相对于在 string 中介绍的把对象转化为 json 字符串存储，hash 的结构可以任意添加或删除‘字段名’，更加高效灵活。 List（列表）list 是按照插入顺序排序的字符串链表，可以在头部和尾部插入新的元素（双向链表实现，两端添加元素的时间复杂度为 O(1)）。插入元素时，如果 key 不存在，redis 会为该 key 创建一个新的链表，如果链表中所有的元素都被移除，该 key 也会从 redis 中移除。 lpush 命令在 list 头部插入元素， 用 rpop 命令在 list 尾取出数据。 应用场景：(1)消息队列 redis 的 list 数据类型对于大部分使用者来说，是实现队列服务的最经济，最简单的方式。(2)最新内容 因为 list 结构的数据查询两端附近的数据性能非常好，所以适合一些需要获取最新数据的场景，比如新闻类应用的 “最近新闻”。 注：list 是链表结构，所有如果在头部和尾部插入数据，性能会非常高，不受链表长度的影响；但如果在链表中插入数据，性能就会越来越差。 Set（集合）格式: sadd name valueRedis的Set是string类型的无序集合，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 set 数据类型是一个string类型集合（没有排序，不重复），可以对set类型的数据进行添加、删除、判断是否存在等操作（时间复杂度是 O(1)）set 集合不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。set 类型提供了多个 set 之间的聚合运算，如求交集、并集、补集，这些操作在 redis 内部完成，效率很高。set 类型的特点是——不重复且无序的一组数据，并且具有丰富的计算功能，在一些特定的场景中可以高效的解决一般关系型数据库不方便做的工作。 应用场景：共同好友列表 社交类应用中，获取两个人或多个人的共同好友，两个人或多个人共同关注的微博这样类似的功能，用 MySQL 的话操作很复杂，可以把每个人的好友 id 存到集合中，获取共同好友的操作就可以简单到一个取交集的命令就搞定。123456789101112131415161718192021222324// 这里为了方便阅读，把 id 替换成姓名sadd user:wade james melo paul kobesadd user:james wade melo paul kobesadd user:paul wade james melo kobesadd user:melo wade james paul kobe// 获取 wade 和 james 的共同好友sinter user:wade user:james/* 输出： * 1) "kobe" * 2) "paul" * 3) "melo" */ // 获取香蕉四兄弟的共同好友 sinter user:wade user:james user:paul user:melo /* 输出： * 1) "kobe" */ /* 类似的需求还有很多 , 必须把每个标签下的文章 id 存到集合中，可以很容易的求出几个不同标签下的共同文章； 把每个人的爱好存到集合中，可以很容易的求出几个人的共同爱好。 */ zset(sorted set：有序集合)格式: zadd name score valueRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数，往有序集合中插入数据时会自动根据这个分数排序。zset的成员是唯一的,但分数(score)却可以重复。 应用场景：在集合类型的场景上加入排序就是有序集合的应用场景了。比如根据好友的“亲密度”排序显示好友列表。1234567891011121314151617181920212223/** * 输出： * 1) "wade" * 2) "paul" * 3) "melo" * 4) "james" */ // 增加好友的亲密度zincrby user:kobe 15 james// 再次根据“亲密度”给好友排序zrevrange user:kobe 0 -1/** * 输出： * 1) "james" * 2) "wade" * 3) "paul" * 2) "melo" */ //类似的需求还出现在根据文章的阅读量或点赞量对文章列表排序]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 有哪些架构模式？讲讲各自的特点]]></title>
    <url>%2F2019%2F04%2F10%2Fedis%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[单机版特点：简单问题：1、内存容量有限 2、处理能力有限 3、无法高可用。 主从复制Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。 特点：1、master/slave 角色2、master/slave 数据相同3、降低 master 读压力在转交从库 问题：无法保证高可用没有解决 master 写的压力 哨兵Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：1、监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。2、提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。3、自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。 特点：1、保证高可用2、监控各个节点3、自动故障迁移缺点：主从模式，切换需要时间丢数据没有解决 master 写的压力 集群（proxy 型）Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins2、支持失败节点自动删除3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致缺点：增加了新的 proxy，需要维护其高可用。failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预 集群（直连型）：从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。 特点：1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。 缺点：1、资源隔离性较差，容易出现相互影响的情况。2、数据通过异步复制,不保证数据的强一致性]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁]]></title>
    <url>%2F2019%2F04%2F10%2Fdis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[分布式锁一般有三种实现方式： 数据库乐观锁 基于Redis的分布式锁 基于ZooKeeper的分布式锁 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：1.互斥性。在任意时刻，只有一个客户端能持有锁。2.不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。3.具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。4.解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 Q:使用过Redis分布式锁么，它是怎么实现的？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 Q:如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！ SETNX命令简介命令格式SETNX key value 将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。SETNX 是SET if Not eXists的简写。 返回值返回整数，具体为-1，当 key 的值被设置-0，当 key 的值没被设置 例子1234567redis&gt; SETNX mykey “hello” (integer) 1 redis&gt; SETNX mykey “hello” (integer) 0 redis&gt; GET mykey “hello” redis&gt; 使用SETNX实现分布式锁多个进程执行以下Redis命令： SETNX lock.foo 如果 SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）。如果 SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。 解决死锁考虑一种情况，如果进程获得锁后，断开了与 Redis 的连接（可能是进程挂掉，或者网络中断），如果没有有效的释放锁的机制，那么其他进程都会处于一直等待的状态，即出现“死锁”。 上面在使用 SETNX 获得锁时，我们将键 lock.foo 的值设置为锁的有效时间，进程获得锁后，其他进程还会不断的检测锁是否已超时，如果超时，那么等待的进程也将有机会获得锁。 然而，锁超时时，我们不能简单地使用 DEL 命令删除键 lock.foo 以释放锁。考虑以下情况，进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。进程P2，P3正在不断地检测锁是否已释放或者已超时，执行流程如下： P2和P3进程读取键 lock.foo 的值，检测锁是否已超时（通过比较当前时间和键 lock.foo 的值来判断是否超时）P2和P3进程发现锁 lock.foo 已超时P2执行 DEL lock.foo命令P2执行 SETNX lock.foo命令，并返回1，即P2获得锁P3执行 DEL lock.foo命令将P2刚刚设置的键 lock.foo 删除（这步是由于P3刚才已检测到锁已超时）P3执行 SETNX lock.foo命令，并返回1，即P3获得锁P2和P3同时获得了锁从上面的情况可以得知，在检测到锁超时后，进程不能直接简单地执行 DEL 删除键的操作以获得锁。 为了解决上述算法可能出现的多个进程同时获得锁的问题，我们再来看以下的算法。我们同样假设进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。接下来的情况： 进程P4执行 SETNX lock.foo 以尝试获取锁由于进程P1已获得了锁，所以P4执行 SETNX lock.foo 返回0，即获取锁失败P4执行 GET lock.foo 来检测锁是否已超时，如果没超时，则等待一段时间，再次检测如果P4检测到锁已超时，即当前的时间大于键 lock.foo 的值，P4会执行以下操作GETSET lock.foo 由于 GETSET 操作在设置键的值的同时，还会返回键的旧值，通过比较键 lock.foo 的旧值是否小于当前时间，可以判断进程是否已获得锁假如另一个进程P5也检测到锁已超时，并在P4之前执行了 GETSET 操作，那么P4的 GETSET 操作返回的是一个大于当前时间的时间戳，这样P4就不会获得锁而继续等待。注意到，即使P4接下来将键 lock.foo 的值设置了比P5设置的更大的值也没影响。另外，值得注意的是，在进程释放锁，即执行 DEL lock.foo 操作前，需要先判断锁是否已超时。如果锁已超时，那么锁可能已由其他进程获得，这时直接执行 DEL lock.foo 操作会导致把其他进程已获得的锁释放掉。 12345678910111213141516171819202122232425262728293031public static boolean acquireLock(String lock) &#123; // 1. 通过SETNX试图获取一个lock boolean success = false; Jedis jedis = pool.getResource(); long value = System.currentTimeMillis() + expired + 1; System.out.println(value); long acquired = jedis.setnx(lock, String.valueOf(value)); //SETNX成功，则成功获取一个锁 if (acquired == 1) success = true; //SETNX失败，说明锁仍然被其他对象保持，检查其是否已经超时 else &#123; long oldValue = Long.valueOf(jedis.get(lock)); //超时 if (oldValue &lt; System.currentTimeMillis()) &#123; String getValue = jedis.getSet(lock, String.valueOf(value)); // 获取锁成功 if (Long.valueOf(getValue) == oldValue) success = true; // 已被其他进程捷足先登了 else success = false; &#125; //未超时，则直接返回失败 else success = false; &#125; pool.returnResource(jedis); return success; &#125;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中间件（middleware）]]></title>
    <url>%2F2019%2F04%2F10%2Fp%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[什么是中间件？中间件顾名思义是指在请求和响应中间,进行请求数据的拦截处理，数据校验，并且进行逻辑处理后判断是否允许进入下一个中间件。中间件分为前缀中间件，后置中间件。可以用于权限认证。日志记录等 中间件是一个闭包，而且返回一个闭包。中间件为过滤进入应用的HTTP请求提供了一套便利的机制，可以分为前置中间件和后置中间件。常用于验证用户是否经过认证，添加响应头（跨域），记录请求日志等。 如果你想修改请求，例如被传送到view中的HttpRequest对象。 或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现。 中间件应用场景1.做IP访问频率限制某些IP访问服务器的频率过高，进行拦截，比如限制每分钟不能超过20次。2.URL访问过滤如果用户访问的是login视图（放过）如果访问其他视图，需要检测是不是有session认证，已经有了放行，没有返回login，这样就省得在多个视图函数上写装饰器了！ 图样 thinkphp5.1中间件thinkphp中间件主要用于拦截或过滤应用的HTTP请求，并进行必要的业务处理。https://www.kancloud.cn/manual/thinkphp5_1/564279 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// 框架核心应用层application$application = function($name) &#123; echo "this is a &#123;$name&#125; 应用层\n";&#125;;// 前置校验中间件auth$auth = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; 需要一个校验中间件\n"; return $handler($name); &#125;;&#125;;// 前置过滤中间件filter$filter = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; 需要一个过滤中间件\n"; return $handler($name); &#125;;&#125;;// 后置日志中间件log$log = function($handler) &#123; return function($name) use ($handler) &#123; $return = $handler($name); echo "&#123;$name&#125; 需要一个后置日志中间件\n"; return $return; &#125;;&#125;;// 中间件栈$stack = [];// 打包function pack_middleware($handler, $stack)&#123; foreach (array_reverse($stack) as $key =&gt; $middleware)&#123; $handler = $middleware($handler); &#125; return $handler;&#125;// 注册中间件//// 这里用的都是全局中间件，实际应用时还可以为指定路由注册局部中间件$stack['log'] = $log;$stack['filter'] = $filter;$stack['auth'] = $auth;$run = pack_middleware($application, $stack);$run('wtf'); 输出： wtf 需要一个过滤中间件wtf 需要一个校验中间件this is a wtf 应用层wtf 需要一个后置日志中间件 打包程序中间件的执行顺序是由打包函数(pack_middleware)决定，这里返回的闭包实际上相当于: $run = $log($filter($auth($application)));$run(&apos;Laravle&apos;); 编写规范中间件要要满足一定的规范：总是返回一个闭包，闭包中总是传入相同的参数（由主要逻辑决定）， 闭包总是返回句柄(handler)的执行结果；如果中间件的逻辑在返回句柄return $handler($name)前完成，就是前置中间件，否则为后置中间件。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F04%2F09%2Fdis%2F</url>
    <content type="text"><![CDATA[Redis实际应用场景 StringString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规key-value缓存应用；常规计数：微博数，粉丝数等。注意：一个键最大能存储512MB。 hash1、Redis hash是一个键值(key =&gt; value)对集合,是一个string类型的field和value的映射表2、hash特别适合用于存储对象。3、存储部分变更的数据，如用户信息等。应用场景：如要存储一个用户信息对象数据，包含以下信息：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式： 第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 第二种方法是这个用户信息对象有多少成员就存成多少个key-value，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图： Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题，很好的解决了问题。 listRedis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 消息队列：可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。使用sorted set甚至可以构建有优先级的队列系统。 Redis提供了操作List中某一段的api，可以直接查询，删除List中某一段的元素。 例子：将Redis用作日志收集器，实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。 取最新N个数据的操作123456//把当前登录人添加到链表里ret = r.lpush("login:last_login_times", uid)//保持链表只有N位ret = redis.ltrim("login:last_login_times", 0, N-1)//获得前N个最新登陆的用户Id列表last_login_list = r.lrange("login:last_login_times", 0, N-1) 比如sina微博:在Redis中最新微博ID使用了常驻缓存，这是一直更新的。但是做了限制不能超过5000个ID，因此获取ID的函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 set集合，集合的概念就是一堆不重复值的组合。set中的元素是没有顺序的。案例：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。交集，并集，差集 //book表存储book名称123456789101112131415set book:1:name "The Ruby Programming Language"set book:2:name "Ruby on rail"set book:3:name "Programming Erlang"//tag表使用集合来存储数据，因为集合擅长求交集、并集sadd tag:ruby 1sadd tag:ruby 2sadd tag:web 2sadd tag:erlang 3//即属于ruby又属于web的书？ inter_list = redis.sinter("tag:web", "tag:ruby")//即属于ruby，但不属于web的书？ diff_list = redis.sdiff("tag:ruby", "tag:web")//属于ruby和属于web的书的合集？ union_list = redis.sunion("tag:ruby", "tag:web") 获取某段时间所有数据去重值只需要不断地将数据往set中扔就行了，set为集合，所以会自动排重。 sorted set和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。排行榜应用，取TOP N操作这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。123456789//将登录次数和用户统一存储在一个sorted set里zadd login:login_times 5 1zadd login:login_times 1 2zadd login:login_times 2 3//当用户登录时，对该用户的登录次数自增1ret = r.zincrby("login:login_times", 1, uid)//那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户ret = r.zrevrange("login:login_times", 0, N-1) 比如在线游戏的排行榜，根据得分你通常想要： 列出前100名高分选手 列出某用户当前的全球排名 这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。模式是这样的，每次获得新得分时，我们用这样的代码：ZADD leaderboard 你可能用userID来取代username，这取决于你是怎么设计的。得到前100名高分用户很简单：ZREVRANGE leaderboard 0 99 用户的全球排名也相似，只需要：ZRANK leaderboard 需要精准设定过期时间的应用 比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。范围查找来自Redis在Google Group上的一个问题，有一位同学发贴求助，说要解决如下的一个问题：他有一个IP范围对应地址的列表，现在需要给出一个IP的情况下，迅速的查找到这个IP在哪个范围，也就是要判断此IP的所有地。 Pub/SubPub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。使用场景Pub/Sub构建实时消息系统Redis的Pub/Sub系统可以构建实时的消息系统比如很多用Pub/Sub构建的实时聊天系统的例子。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php设计模式]]></title>
    <url>%2F2019%2F04%2F09%2Fphp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。策略模式的三个角色：1．抽象策略角色2．具体策略角色3．环境角色（对抽象策略角色的引用）实现步骤：1．定义抽象角色类（定义好各个实现的共同抽象方法）2．定义具体策略类（具体实现父类的共同方法）3．定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）就在编程领域之外，有许多例子是关于策略模式的。例如：如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。策略模式的代码实例：123456789101112131415161718192021222324&lt;?php abstract class baseAgent &#123; //抽象策略类 abstract function PrintPage(); &#125; //用于客户端是IE时调用的类（环境角色） class ieAgent extends baseAgent &#123; function PrintPage() &#123; return 'IE'; &#125; &#125; //用于客户端不是IE时调用的类（环境角色） class otherAgent extends baseAgent &#123; function PrintPage() &#123; return 'not IE'; &#125; &#125; class Browser &#123; //具体策略角色 public function call($object) &#123; return $object-&gt;PrintPage (); &#125; &#125; $bro = new Browser (); echo $bro-&gt;call ( new ieAgent () );?&gt; 工厂模式工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpheader('Content-Type:text/html;charset=utf-8');/** *简单工厂模式（静态工厂方法模式） *//** * Interface people 人类 */interface people&#123; public function say();&#125;/** * Class man 继承people的男人类 */class man implements people&#123; // 具体实现people的say方法 public function say() &#123; echo '我是男人&lt;br&gt;'; &#125;&#125;/** * Class women 继承people的女人类 */class women implements people&#123; // 具体实现people的say方法 public function say() &#123; echo '我是女人&lt;br&gt;'; &#125;&#125;/** * Class SimpleFactoty 工厂类 */class SimpleFactoty&#123; // 简单工厂里的静态方法-用于创建男人对象 static function createMan() &#123; return new man(); &#125; // 简单工厂里的静态方法-用于创建女人对象 static function createWomen() &#123; return new women(); &#125;&#125;/** * 具体调用 */$man = SimpleFactoty::createMan();$man-&gt;say();$woman = SimpleFactoty::createWomen();$woman-&gt;say(); 单例模式单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式是一种常见的设计模式，在计算机系统中，线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序常被设计成单例。单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。单例模式有以下3个特点：1．只能有一个实例。2．必须自行创建这个实例。3．必须给其他对象提供这一实例。那么为什么要使用PHP单例模式？PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。123456789101112131415161718class Single &#123; private $name;//声明一个私有的实例变量 private function __construct()&#123;//声明私有构造方法为了防止外部代码使用new来创建对象。 &#125; static public $instance;//声明一个静态变量（保存在类中唯一的一个实例） static public function getinstance()&#123;//声明一个getinstance()静态方法，用于检测是否有实例对象 if(!self::$instance) self::$instance = new self(); return self::$instance; &#125; public function setname($n)&#123; $this-&gt;name = $n; &#125; public function getname()&#123; return $this-&gt;name; &#125;&#125;$oa = Single::getinstance();$ob = Single::getinstance();$oa-&gt;setname('hello world');$ob-&gt;setname('good morning');echo $oa-&gt;getname();//good morningecho $ob-&gt;getname();//good morning 单例模式-懒汉1234567891011121314151617181920212223package Singleton;public class LazySingleton &#123; //懒汉式单例模式 //比较懒，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢 private static LazySingleton intance = null;//静态私用成员，没有初始化 private LazySingleton() &#123; //私有构造函数 &#125; public static synchronized LazySingleton getInstance() //静态，同步，公开访问点 &#123; if(intance == null) &#123; intance = new LazySingleton(); &#125; return intance; &#125;&#125; （类加载时不初始化）1）构造函数定义为私有—-不能在别的类中来获取该类的对象，只能在类自身中得到自己的对象 2）成员变量为static的，没有初始化—-类加载快，但访问类的唯一实例慢，static保证在自身类中获取自身对象 3）公开访问点getInstance： public和synchronized的—–public保证对外公开，同步保证多线程时的正确性（因为类变量不是在加载时初始化的） 单例模式-饿汉（在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快）1234567891011121314151617181920package Singleton;public class EagerSingleton &#123; //饿汉单例模式 //在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快 private static EagerSingleton instance = new EagerSingleton();//静态私有成员，已初始化 private EagerSingleton() &#123; //私有构造函数 &#125; public static EagerSingleton getInstance() //静态，不用同步（类加载时已初始化，不会有多线程的问题） &#123; return instance; &#125; &#125; 注册模式注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。12345678910111213141516&lt;?phpclass Register&#123; protected static $objects; function set($alias,$object)//将对象注册到全局的树上 &#123; self::$objects[$alias]=$object;//将对象放到树上 &#125; static function get($name)&#123; return self::$objects[$name];//获取某个注册到树上的对象 &#125; function _unset($alias) &#123; unset(self::$objects[$alias]);//移除某个注册到树上的对象。 &#125;&#125; 适配器模式将各种截然不同的函数接口封装成统一的API。PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。 接口 IDatabase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace IMooc;interface IDatabase&#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125;MySQL&lt;?phpnamespace IMooc\Database;use IMooc\IDatabase;class MySQL implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname, $conn); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125;&#125;MySQLi&lt;?phpnamespace IMooc\Database;use IMooc\IDatabase;class MySQLi implements IDatabase&#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125; 观察者模式1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。3：观察者模式实现了低耦合，非侵入式的通知与更新机制。定义一个事件触发抽象类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748EventGenerator.php&lt;?phprequire_once 'Loader.php';abstract class EventGenerator&#123; private $observers = array(); function addObserver(Observer $observer)&#123; $this-&gt;observers[]=$observer; &#125; function notify()&#123; foreach ($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125;定义一个观察者接口Observer.php&lt;?phprequire_once 'Loader.php';interface Observer&#123; function update();//这里就是在事件发生后要执行的逻辑&#125;//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件实现require 'Loader.php';class Event extends EventGenerator&#123; function triger()&#123; echo "Event&lt;br&gt;"; &#125;&#125;class Observer1 implements Observer&#123; function update()&#123; echo "逻辑1&lt;br&gt;"; &#125;&#125;class Observer2 implements Observer&#123; function update()&#123; echo "逻辑2&lt;br&gt;"; &#125;&#125;$event = new Event();$event-&gt;addObserver(new Observer1());$event-&gt;addObserver(new Observer2());$event-&gt;triger();$event-&gt;notify();]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php抽象类]]></title>
    <url>%2F2019%2F04%2F09%2Fp%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类与接口紧密相关，它们不能实例化，并且常常部分实现或根本不实现。抽象类和接口之间的一个主要差别是：类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承。从抽象类派生的类仍可实现接口。可以在创建组件时使用抽象类，因为它们使您得以在某些方法中指定不变级功能，但直到需要该类的特定实现之后才实现其他方法。抽象类也制定版本，因为如果在派生类中需要附加功能，则可以将其添加到基类而不中断代码。PHP抽象类应用的定义：abstract class ClassName{} 什么是抽象方法我们在类里面定义的没有方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰； 什么是php抽象类只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。 PHP抽象类应用要点： 1.定义一些方法，子类必须完全实现这个抽象中所有的方法 2.不能从抽象类创建对象，它的意义在于被扩展 3.抽象类通常具有抽象方法，方法中没有大括号 PHP抽象类应用重点： 1.抽象方法不必实现具体的功能，由子类来完成 2.在子类实现抽象类的方法时，其子类的可见性必须大于或等于抽象方法的定义 3.抽象类的方法可以有参数，也可以为空 4.如果抽象方法有参数，那么子类的实现也必须有相同的参数个数 PHP抽象类应用示例：abstract public function_name(); //注意没有大括号 PHP抽象类规则：某个类只要至少含有一个抽象方法，就必须声明为抽象类抽象方法，不能够含有函数体继承抽象类的子类，实现抽象方法的，必须跟该抽象方法具有相同或者更低的访问级别继承抽象类的子类，如果不实现所有抽象方法，那么该子类也为抽象类 计算矩形的周长12345678910111213141516171819202122&lt; ?PHP abstract class Shape &#123; abstract protected function get_area(); //和一般的方法不同的是，这个方法没有大括号 //你不能创建这个抽象类的实例：$Shape_Rect= new Shape(); &#125; class Rectangle extends Shape&#123; private $width; private $height; function __construct($width=0,$height=0)&#123; $this-&gt;width=$width; $this-&gt;height=$height; &#125; function get_area()&#123; echo ($this-&gt;width+$this-&gt;height)*2; &#125; &#125; $Shape_Rect = new Rectangle(20,30); $Shape_Rect-&gt;get_area(); ?&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基础操作]]></title>
    <url>%2F2019%2F04%2F08%2Finux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[find操作将目前目录及其子目录下所有延伸档名是 c 的文件列出来。find . -name “*.c”将目前目录其其下子目录中所有一般文件列出find . -type f 递归查找find . -r -name “*.txt” grep操作grep查找字符（利用递归查找在后缀为md的文件中查找字符为1的文件）grep -r 1 *.md 找出程序运行的端口netstat -ap | grep ssh]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与sesseion]]></title>
    <url>%2F2019%2F04%2F07%2Fookie%E4%B8%8Esesseion%2F</url>
    <content type="text"><![CDATA[cookie位于用户的计算机上，用来维护用户计算机中的信息，直到用户删除。比如我们在网页上登录某个软件时输入用户名及密码时如果保存为cookie，则每次我们访问的时候就不需要登录网站了。我们可以在浏览器上保存任何文本，而且我们还可以随时随地的去阻止它或者删除。我们同样也可以禁用或者编辑cookie，但是有一点需要注意不要使用cookie来存储一些隐私数据，以防隐私泄露。 sessionsession称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站 （1）Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。（2）cookie的存储限制了数据量，只允许4KB，而session是无限量的（3）我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全（4）设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。 总结：如果我们需要经常登录一个站点时，最好用cookie来保存信息，要不然每次登陆都特别麻烦，如果对于需要安全性高的站点以及控制数据的能力时需要用会话效果更佳，当然我们也可以结合两者，使网站按照我们的想法进行运行]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库垂直切分与水平切分]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%8D%AE%E5%BA%93%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86%E4%B8%8E%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/firstdream/p/6728106.html当我们使用读写分离、缓存后，数据库的压力还是很大的时候，这就需要使用到数据库拆分了。数据库拆分简单来说，就是指通过某种特定的条件，按照某个维度，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面以达到分散单库（主机）负载的效果。 切分模式： 垂直（纵向）拆分、水平拆分。 垂直拆分-专库专用一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图： 优点： 1. 拆分后业务清晰，拆分规则明确。 2. 系统之间整合或扩展容易。 3. 数据维护简单。 缺点： 1. 部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。 2. 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。 3. 事务处理复杂。 水平拆分垂直拆分后遇到单机瓶颈，可以使用水平拆分。相对于垂直拆分的区别是：垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。 相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中 的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中，主要有分表，分库两种模式，如图： 优点： 1. 不存在单库大数据，高并发的性能瓶颈。 2. 对应用透明，应用端改造较少。 3. 按照合理拆分规则拆分，join操作基本避免跨库。 4. 提高了系统的稳定性跟负载能力。 缺点： 1. 拆分规则难以抽象。 2. 分片事务一致性难以解决。 3. 数据多次扩展难度跟维护量极大。 4. 跨库join性能较差。 垂直拆分： 解决问题： 表与表之间的io竞争 不解决问题： 单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上水平拆分： 解决问题： 单表中数据量增长出现的压力 不解决问题： 表与表之间的io争夺 方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php PDO]]></title>
    <url>%2F2019%2F04%2F06%2Fhp-PDO%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/jiuyue9561/article/details/80379910 什么是PDO？PDO就是PHP data Object 提供了PHP操作多种1（12种）数据库的统一的接口 为什么使用PDO？PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可；]]></content>
  </entry>
  <entry>
    <title><![CDATA[三次握手四次挥手]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[https://www.nowcoder.com/ta/review-network 三次握手第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 三次握手（细）1、TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。2、TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。3、TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 为什么TCP客户端最后还要发送一次确认呢？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 四次挥手（细）1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。]]></content>
      <categories>
        <category>面试必考</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表反转]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627&lt;?php/*class ListNode&#123; var $val; var $next = NULL; function __construct($x)&#123; $this-&gt;val = $x; &#125;&#125;*/function ReverseList($pHead)&#123; // write code here if($pHead==NULL||$pHead-&gt;next==NULL)&#123; return $pHead; &#125; //将原链表的元素一个个插入到新链表的头部 $pPre = NULL; $pCur = $pHead; while ($pCur-&gt;next != NULL) &#123; $pNext = $pCur-&gt;next; $pCur-&gt;next = $pPre; $pPre = $pCur; $pCur = $pNext; &#125; $pCur-&gt;next = $pPre; return $pCur;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的层次遍历]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1、把根节点A放入队列，此时队列为：A，队列头指针指向A，也就是队列第一个元素2、把当前队列头指针所指元素的左右儿子放入队列，即将B C放入队列，此时队列为A B C ，队列头指针向下移一格，此时指向B3、不断重复2步骤。此时把B的左右儿子取出来放入队尾，队列变为A B C D E，队列头指针后移，指向c，c没有子节点，队列不再延长；4、结束条件，队列头指针和为指针重合时，输出最后一个元素，算法结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125;&#125;function reConstructBinaryTree($pre, $vin)&#123; // write code here if($pre &amp;&amp; $vin)&#123; $treeRoot = new TreeNode($pre[0]); $index = array_search($pre[0],$vin); $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125;&#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$re = reConstructBinaryTree($pre, $vin);PrintFromTopToBottom($re);function PrintFromTopToBottom($re)&#123; $quene=array(); $res=array(); if($re==null) return $res; array_push($quene,$re); while(!empty($quene))&#123; // quene出队，队头值赋值给tmp，最后打印tmp的val //这里使队列出队是为了将quene的指针右移，使tmp成为quene右移指针之后的树，如ABC，下一步要将B的孩子DE入队，那么就需要使tmp指向B $tmp=array_shift($quene); //左右节点依次入队 if($tmp-&gt;left!=null)&#123; array_push($quene,$tmp-&gt;left); &#125; if($tmp-&gt;right!=null)&#123; array_push($quene,$tmp-&gt;right); &#125; //将tmp的val入队 array_push($res,$tmp-&gt;val); &#125; print_r($res) ;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历与对比]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%81%8D%E5%8E%86%E4%B8%8E%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpclass TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125;&#125;function reConstructBinaryTree($pre, $vin)&#123; // write code here if($pre &amp;&amp; $vin)&#123; $treeRoot = new TreeNode($pre[0]); $index = array_search($pre[0],$vin); $treeRoot-&gt;left = reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125;&#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$pre1 = [1,2,4,7];$vin1 = [4,7,2,1];$pRoot1 = reConstructBinaryTree($pre, $vin);$pRoot2 = reConstructBinaryTree($pre1,$vin1);echo HasSubtree($pRoot1, $pRoot2);function HasSubtree($pRoot1, $pRoot2)&#123; $re = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if($pRoot1!=NULL&amp;&amp;$pRoot2!=NULL)&#123; //如果找到了对应Tree2的根节点的点 if($pRoot1-&gt;val==$pRoot2-&gt;val)&#123; //以这个根节点为为起点判断是否包含Tree2 $re = judge($pRoot1,$pRoot2); &#125; if(!$re)&#123; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 $re = HasSubtree($pRoot1-&gt;left,$pRoot2); &#125; if(!$re)&#123; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 $re = HasSubtree($pRoot1-&gt;right,$pRoot2); &#125; &#125; if($re == false)&#123; return 0; &#125;else&#123; return 1; &#125; return $re;&#125;function judge($pRoot1, $pRoot2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if($pRoot2 == NULL)&#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if($pRoot1 == NULL)&#123; return false; &#125; //如果其中有一个点没有对应上，返回false if($pRoot1-&gt;val != $pRoot2-&gt;val)&#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return judge($pRoot1-&gt;left,$pRoot2-&gt;left)&amp;&amp;judge($pRoot1-&gt;right,$pRoot2-&gt;right);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算加法]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%AE%97%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213&lt;?phpfunction Add($num1, $num2)&#123; // write code here while($num2)&#123; //相加之后的进位 $tmp = $num1 ^ $num2; //相加之后没有进位 $num2 = ($num1 &amp; $num2) &lt;&lt; 1; $num1 = $tmp; &#125; return $num1;&#125; 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql千行笔记]]></title>
    <url>%2F2019%2F03%2F30%2Fysql%E5%8D%83%E8%A1%8C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Windows服务 -- 启动MySQL net start mysql -- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格) 连接与断开服务器 mysql -h 地址 -P 端口 -u 用户名 -p 密码 SHOW PROCESSLIST -- 显示哪些线程正在运行 SHOW VARIABLES -- 显示系统变量信息 数据库操作 -- 查看当前数据库 SELECT DATABASE(); -- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version(); -- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name -- 查看已有库 SHOW DATABASES[ LIKE &apos;PATTERN&apos;] -- 查看当前库信息 SHOW CREATE DATABASE 数据库名 -- 修改库的选项信息 ALTER DATABASE 库名 选项信息 -- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作 -- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;] -- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &apos;目录&apos; -- 索引文件目录 INDEX DIRECTORY = &apos;目录&apos; -- 表注释 COMMENT = &apos;string&apos; -- 分区选项 PARTITION BY ... (详细见手册) -- 查看所有表 SHOW TABLES[ LIKE &apos;pattern&apos;] SHOW TABLES FROM 表名 -- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;] SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;] -- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键 -- 删除表 DROP TABLE[ IF EXISTS] 表名 ... -- 清空表数据 TRUNCATE [TABLE] 表名 -- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名 -- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名 -- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... -- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... -- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM] -- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作 -- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...] -- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部 -- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码 -- MySQL、数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 SHOW VARIABLES LIKE &apos;character_set_%&apos; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码 SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk; SET NAMES GBK; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;] 查看所有字符集 SHOW COLLATION [LIKE &apos;pattern&apos;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型（列类型） 1. 数值类型 -- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&apos;123&apos;，补填后为&apos;00123&apos; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 2. 字符串类型 -- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime YYYY-MM-DD hh:mm:ss timestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmss date YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDD time hh:mm:ss hhmmss hhmmss year YYYY YY YYYY YY 4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) ); insert into tab values (&apos;男, 女&apos;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 选择类型 -- PHP角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- IP存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&apos;192.168.3.134&apos;)); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON(&apos;127.0.0.1&apos;) 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP 列属性（列约束） 1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &apos;val&apos;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &apos;val&apos;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. COMMENT 注释 例：create table tab ( id int ) comment &apos;注释内容&apos;; 7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范 -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3; c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;,&gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。 g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询 - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join) 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; 导出 select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &apos; &apos; enclosed by &apos;&apos; escaped by &apos;\&apos; terminated by &apos;string&apos; -- 终止 enclosed by &apos;char&apos; -- 包裹 escaped by &apos;char&apos; -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos; FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos; &apos; FROM test_table; lines 控制行格式 默认：lines terminated by &apos; &apos; terminated by &apos;string&apos; -- 终止 INSERT select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …; DELETE DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 TRUNCATE TRUNCATE [TABLE] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 备份与还原 备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database DB1 [DB2 DB3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql) 可以-w携带WHERE条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图 什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务(transaction) 事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。 -- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 -- 事务提交 COMMIT; -- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 -- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表 表锁定只用于防止其它客户端进行不正当地读取和写入 MyISAM 支持表锁，InnoDB 支持行锁 -- 锁定 LOCK TABLES tbl_name [AS alias] -- 解锁 UNLOCK TABLES 触发器 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROWtrigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构 -- 删除 DROP TRIGGER [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 SQL语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程 --// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取日期部分 time(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取时间部分 date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 DROP FUNCTION [IF EXISTS] function_name; -- 查看 SHOW FUNCTION STATUS LIKE &apos;partten&apos; SHOW CREATE FUNCTION function_name; -- 修改 ALTER FUNCTION function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 CREATE PROCEDURE sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 IN，表示输入型 OUT，表示输出型 INOUT，表示混合型 注意，没有返回值。 /* 存储过程 */ ------------------ 存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：CALL 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 IN|OUT|INOUT 参数名 数据类型 IN 输入：在调用过程中，将数据输入到过程体内部的参数 OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端 INOUT 输入输出：既可输入，也可输出 -- 语法 CREATE PROCEDURE 过程名 (参数列表) BEGIN 过程体 END 用户和权限管理 -- root密码重置 1. 停止MySQL服务 2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables 3. use mysql; 4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;; 5. FLUSH PRIVILEGES; 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES; -- 增加用户 CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD(&apos;密码&apos;) -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码 -- 删除用户 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;; -- 查看权限 SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 表维护 -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 &apos; 5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;G&quot;, &quot;g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 7. 清除已有语句：c]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php实现0-1背包问题]]></title>
    <url>%2F2019%2F03%2F29%2F1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526&lt;? phpfunction back()&#123; $a['w'] = [0, 2, 3, 4, 5, 9]; $a['v'] = [0, 3, 4, 5, 8, 10]; $b =array(); $n = 6; $w = 21; for($i=0;$i &lt; $n;$i++)&#123; for($j=0;$j &lt; $w;$j++)&#123; $b[$i][$j] = 0; &#125; &#125; for($k = 1; $k &lt; $n ;$k++)&#123; for($c = 1; $c &lt; $w ;$c++)&#123; if($a['w'][$k] &gt; $c)&#123; $b[$k][$c] = $b[$k-1][$c]; &#125;else&#123; $value1 = $b[$k-1][$c-$a['w'][$k]] + $a['v'][$k]; // 拿第k件物品 $value2 = $b[$k-1][$c]; // 不拿第k件物品 $b[$k][$c] = max($value1,$value2); &#125; &#125; &#125; print_r($b);&#125;back(); JAVA实现 1234567891011121314151617181920 class Main &#123; public static void main(String[] args) &#123; int[] w = &#123; 0, 2, 3, 4, 5, 9 &#125;; int[] v = &#123; 0, 3, 4, 5, 8, 10 &#125;; int N = 6, W = 21; int[][] b = new int[N][W]; for (int k = 1; k &lt; N; k++) &#123; for (int c = 1; c &lt; W; c++) &#123; if (w[k] &gt; c) &#123; b[k][c] = b[k - 1][c]; &#125; else &#123; int value1 = b[k - 1][c - w[k]] + v[k]; // 拿第k件物品 int value2 = b[k - 1][c]; // 不拿第k件物品 b[k][c] = Math.max(value1, value2); &#125; &#125; &#125; System.out.println(b[5][20]); &#125;&#125;]]></content>
      <categories>
        <category>高级算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与贪心算法的区别与联系]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划的路径规划：https://blog.csdn.net/xgf415/article/details/52662389 0-1背包问题： https://www.jianshu.com/p/b86148c10142动态规划和贪心算法都是一种递推算法均有局部最优解来推导全局最优解背包问题可以由贪心算法求解，但是0-1背包问题不能而需要采取动态规划。 不同点： 贪心算法：1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。2.由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。 贪心法的基本思路：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。实现该算法的过程：从问题的某一初始解出发； while 能朝给定总目标前进一步 do求出可行解的一个解元素；由所有解元素组合成问题的一个可行解 贪心算法最经典的例子，给钱问题。比如中国的货币，只看元，有1元2元5元10元20、50、100 如果我要16元，可以拿16个1元，8个2元，但是怎么最少呢？如果用贪心算，就是我每一次拿那张可能拿的最大的。比如16，我第一次拿20拿不起，拿10元，OK，剩下6元，再拿个5元，剩下1元也就是3张 10、5、1。 每次拿能拿的最大的，就是贪心。 但是一定注意，贪心得到的并不是最优解，也就是说用贪心不一定是拿的最少的张数贪心只能得到一个比较好的解，而且贪心算法很好想得到。再注意，为什么我们的钱可以用贪心呢？因为我们国家的钱的大小设计，正好可以使得贪心算法算出来的是最优解（一般是个国家的钱币都应该这么设计）。如果设计成别的样子情况就不同了比如某国的钱币分为 1元3元4元如果要拿6元钱 怎么拿？贪心的话 先拿4 再拿两个1 一共3张钱实际最优呢？ 两张3元就够了 贪心算法两个最重要的性质：（1）贪心选择性质；（2）最优子结构性质； 其中，贪心选择性质：自顶向下进行决策，每次做出的决策都是局部最优解，且每次做出决策后问题规模都变小了；最优子结构性质：即问题的最优解结构中包含子问题的最优解； 动态规划算法的两个最重要的性质：（1）重叠子问题性质；（2）最优子结构性质； 其中最优解子结构性质和贪心算法相似，唯一不同的是重叠子问题性质，因为动态规划算法是自底向上的算法，它需要首先将原始问题分解为若干个相互有联系的子问题，在计算的时候有的子问题可能会被计算很多次，所以动态规划算法会将这些子问题的解存在一个表格中，使得最终对于这些子问题只需要求解一次（可以使原来需要再指数时间内解决的问题可以在多项式问题中得到解决）]]></content>
      <categories>
        <category>高级算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[music]]></title>
    <url>%2F2019%2F03%2F29%2Fnew%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前序与中序还原树]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425&lt;?php class TreeNode&#123; var $val; var $left = NULL; var $right = NULL; function __construct($val)&#123; $this-&gt;val = $val; &#125; &#125; function reConstructBinaryTree($pre, $vin) &#123; // write code here if($pre &amp;&amp; $vin)&#123; //前序遍历的第一个节点一定是根节点 $treeRoot = new TreeNode($pre[0]); //index判断根节点在中序中是否存在,并返回根节点在vin中的键名 $index = array_search($pre[0],$vin); $treeRoot-&gt;left=reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; &#125; &#125;$pre = [1,2,4,7,3,5,6,8];$vin = [4,7,2,1,5,3,8,6];$re = reConstructBinaryTree($pre, $vin);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序遍历与中序遍历与后续遍历的php实现]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php class Node&#123; public $value; public $left; public $right; &#125; //先序遍历 根节点 ---&gt; 左子树 ---&gt; 右子树 function preorder($root)&#123; $stack=array(); array_push($stack,$root); while(!empty($stack))&#123; $center_node=array_pop($stack); echo $center_node-&gt;value.' ';//先输出根节点 if($center_node-&gt;right!=null)&#123; array_push($stack,$center_node-&gt;right);//压入左子树 &#125; if($center_node-&gt;left!=null)&#123; array_push($stack,$center_node-&gt;left); &#125; &#125; &#125; //中序遍历，左子树---&gt; 根节点 ---&gt; 右子树 function inorder($root)&#123; $stack = array(); $center_node = $root; while (!empty($stack) || $center_node != null) &#123; while ($center_node != null) &#123; array_push($stack, $center_node); $center_node = $center_node-&gt;left; &#125; $center_node = array_pop($stack); echo $center_node-&gt;value . " "; $center_node = $center_node-&gt;right; &#125; &#125; //后序遍历，左子树 ---&gt; 右子树 ---&gt; 根节点 function tailorder($root)&#123; $stack=array(); $outstack=array(); array_push($stack,$root); while(!empty($stack))&#123; $center_node=array_pop($stack); array_push($outstack,$center_node);//最先压入根节点，最后输出 if($center_node-&gt;left!=null)&#123; array_push($stack,$center_node-&gt;left); &#125; if($center_node-&gt;right!=null)&#123; array_push($stack,$center_node-&gt;right); &#125; &#125; while(!empty($outstack))&#123; $center_node=array_pop($outstack); echo $center_node-&gt;value.' '; &#125; &#125; $a=new Node(); $b=new Node(); $c=new Node(); $d=new Node(); $e=new Node(); $f=new Node(); $a-&gt;value='A'; $b-&gt;value='B'; $c-&gt;value='C'; $d-&gt;value='D'; $e-&gt;value='E'; $f-&gt;value='F'; $a-&gt;left=$b; $a-&gt;right=$c; $b-&gt;left=$d; $c-&gt;left=$e; $c-&gt;right=$f; preorder($a);//A B D C E F echo '&lt;hr/&gt;'; inorder($a);//D B A E C F echo '&lt;hr/&gt;'; tailorder($a);//D B E F C A]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php十进制二进制算法题]]></title>
    <url>%2F2019%2F03%2F28%2Fhp%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[负数需要先置反为反码，然后再加1，并且循环需要32位 floor()舍去法取整 ceil – 进一法取整 round – 对浮点数进行四舍五入 %取余数 array_count_values()表示$v出现次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction NumberOf1($n)&#123; $arr = array(); if ($n &gt; 0)&#123; while($n != 0) &#123; $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); &#125; $judge = array_count_values($arr); if(isset($judge[1]))&#123; return $judge[1]; &#125;else&#123; return 0; &#125; &#125;else&#123; $n = -1 * $n; while($n &gt; 0)&#123; $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); &#125; for($i=0;$i &lt; 32;$i++)&#123; if($arr[$i] == 1)&#123; $arr[$i] = 0; &#125;elseif($arr[$i] == 0) &#123; $arr[$i] = 1; &#125;else&#123; $arr[$i] = 1; &#125; &#125; $length = count($arr); for($i = 0;$i &lt; $length;$i++)&#123; if($arr[$i]==0)&#123; $arr[$i] = 1; break; &#125;else&#123; $arr[$i] = 0; &#125; &#125; $judge = array_count_values($arr); if(isset($judge[1]))&#123; return $judge[1]; &#125;else&#123; return 0; &#125; &#125;&#125;?&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php多线程]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展，而要安装 pthread 扩展，必须使用 –enable-maintainer-zts 参数重新编译 PHP，这个参数是指定编译 PHP 时使用线程安全方式。 什么是线程安全?如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找总结]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析： 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ; 当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。 二分查找 说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)； 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》 123456789101112131415161718/二分查找（折半查找），版本1int BinarySearch1(int a[], int value, int n) &#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1; &#125; 1234567891011//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high) &#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high); &#125; 插值查找 在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？ 打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。 同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。 经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下： mid=(low+high)/2, 即mid=low+1/2(high-low); 通过类比，我们可以将查找的点改进为如下： mid=low+(key-a[low])/(a[high]-a[low])(high-low)， 也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。 C++实现源码：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[http协议的状态码 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误）Internal Server Error服务器遇到错误，无法完成请求。 501（尚未实施）Not Implemented服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）Bad Gateway服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）Service Unavailable服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时）Gateway Timeout服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）HTTP Version Not Supported服务器不支持请求中所用的 HTTP 协议版本。1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续）continue请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议）switch protocols请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx（成功）表示成功处理了请求的状态码。 200（成功）OK服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。201（已创建）Created请求成功并且服务器创建了新的资源。 202（已接受）Accepted服务器已接受请求，但尚未处理。 203（非授权信息）Non-Authoriative Information服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）No Content服务器成功处理了请求，但没有返回任何内容。 205（重置内容）Reset Content服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）Partial Content服务器成功处理了部分 GET 请求。 3xx（重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google建议您在每次请求中使用重定向不要超过5次。您可以使用网站管理员工具查看一下 Googlebot在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 300（多种选择）Multiple Choices针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）Moved Permanently请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置）see other请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）Not Modified自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。. 305（使用代理）Use Proxy请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）Temporary Redirect服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）Bad Request服务器不理解请求的语法。 401（未授权）Unauthorized请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）Forbidden服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）File Not Found服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用）Method Not Allowed禁用请求中指定的方法。 406（不接受）Not Acceptable无法使用请求的内容特性响应请求的网页。 407（需要代理授权）Proxy Authentication Required此状态码与 401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）Request Time-out服务器等候请求时发生超时。 409（冲突）conflict服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）Gone如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）Length Required服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）Precondition Failed服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）Request Entity Too Large服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）Request-URL Too Large请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）Unsupported Media Type请求的格式不受请求页面的支持。 416（请求范围不符合要求）Requested range not statifiable如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值）Expectation Failed服务器未满足”期望”请求标头字段的要求。]]></content>
      <categories>
        <category>面试必考</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET与POST区别]]></title>
    <url>%2F2019%2F03%2F27%2FET%E4%B8%8EPOST%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[get post本质：HTTP协议里两种发送请求的方法 1、get放在url里面 post放在body里面不可见2、get请求url有限制（字符串，2k-4k） post根据php.ini设定，可以无限大3、get 方式是可以缓存的，post 方式不可以缓存4、后退页面反应：get无影响，post需要返回重新提交数据 get产生一个TCP数据包 而post产生两个：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 建议：1、get式安全性较Post式要差些包含机密信息建议用Post数据提交式；2、做数据查询建议用Get式；做数据添加、修改或删除建议用Post方式；百度使用的get方式，因为可以从它的URL中看出]]></content>
      <categories>
        <category>面试必考</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试必考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双栈实现队列]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223&lt;?php $pushV = [1,2,3,4,5]; $popV = [4,5,3,2,1]; function IsPopOrder($pushV, $popV) &#123; // $stack = new SplStack(); $stack = []; $len = count($pushV); $j = 0; for($i=0;$i&lt;$len;$i++)&#123; array_push($stack,$pushV[$i]); while($j&lt;$len &amp;&amp; $popV[$j]==end($stack))&#123; array_pop($stack); $j++; &#125; &#125; if($stack)&#123; return false; &#125;else &#123; return true; &#125; &#125; echo IsPopOrder($pushV, $popV);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法时间复杂度空间复杂度]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[注：1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念：1、时间复杂度 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2) 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),2、空间复杂度 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1) 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ax=N，则x=logaN， 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试必考</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环队列叫号问题]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[有m个猴子，按顺时针方向围成一个圈选大王。从第1号开始报数1，2，……，数到n号时该猴子退出到圈外，如此报数直到圈内只剩下一个猴子时，此猴子便是大王。由键盘输入m，n，打印出猴子大王序号。输入 10 3输出 4 12345678910111213141516171819202122 &lt;?php echo monkey(4,1);//5function monkey($m,$n)&#123; //定义arr猴子数组， $arr=range(1,$m); $i=0; while(count($arr)&gt;1)&#123; //出队 if(($i+1)%$n==0)&#123; //如果猴子序号/猴王号n余数为0，踢走 unset($arr[$i]); &#125;else&#123; //否则将该序号放在猴子数组队尾 $arr[]=$arr[$i]; unset($arr[$i]); &#125; echo $i."\n"; $i++; &#125; //最后key i所对应的就是猴王 return $arr[$i];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>队列</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php垃圾回收机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/u011957758/article/details/76864400 refcount：多少个变量是一样的用了相同的值，这个数值就是多少。is_ref：bool类型，当refcount大于2的时候，其中一个变量用了地址&amp;的形式进行赋值，好了，它就变成1了。 unset并非一定会释放内存，当有两个变量指向的时候，并非会释放变量占用的内存，只是refcount减1. 如果unset（$a） 如果在小于php5.3的版本就会出现一个问题：$a已经不在符号表了，没有变量再指向此zval容器，用户已无法访问，但是由于数组的refcount变为1而不是0，导致此部分内存不能被回收从而产生了内存泄漏。 5.3之后版本处理垃圾判断处理过程1.如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾2.如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾3.如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾 白话文版：就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾 A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。 B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。 C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性） D：遍历zval节点，将C中标记成白色的节点zval释放掉。 &lt;?php $a = [&apos;one&apos;]; --- zval_a（将$a对应的zval，命名为zval_a） $a[] = &amp;$a; --- step1 unset($a); --- step2 为进行unset之前(step1)，进行算法计算，对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样说明zval_a不是一个垃圾不进行回收。 当执行unset的时候(step2)，进行算法计算，由于环形引用，上文得出会有垃圾的结构体，zval_a的refcount是1(zval_a中的索引1指向zval_a)，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就认为zval_a是一个需要回收的垃圾。 算法总的套路:对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。 unsetunset只是断开一个变量到一块内存区域的连接，同时将该内存区域的引用计数-1；内存是否回收主要还是看refount是否到0了，以及gc算法判断。 = null 操作；a=null是直接将a 指向的数据结构置空，同时将其引用计数归0。 脚本执行结束脚本执行结束，该脚本中使用的所有内存都会被释放，不论是否有引用环。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用数组操作]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、数组操作的基本函数 数组的键名和值array_values($arr); 获得数组的值array_keys($arr); 获得数组的键名array_flip($arr); 数组中的值与键名互换（如果有重复前面的会被后面的覆盖）in_array(“apple”,$arr); 在数组中检索applearray_search(“apple”,$arr); 在数组中检索apple ，如果存在返回键名array_key_exists(“apple”,$arr); 检索给定的键名是否存在数组中isset($arr[apple]): 检索给定的键名是否存在数组中 数组的内部指针current($arr); 返回数组中的当前单元pos($arr); 返回数组中的当前单元key($arr); 返回数组中当前单元的键名prev($arr); 将数组中的内部指针倒回一位next($arr); 将数组中的内部指针向前移动一位end($arr); 将数组中的内部指针指向最后一个单元reset($arr; 将数组中的内部指针指向第一个单元each($arr); 将返回数组当前元素的一个键名/值的构造数组，并使数组指针向前移动一位list($key,$value)=each($arr); 获得数组当前元素的键名和值 数组和变量之间的转换extract($arr);用于把数组中的元素转换成变量导入到当前文件中，键名当作变量名，值作为变量值注：（第二个参数很重要，可以看手册使用）使用方法 echo $a;compact(var1,var2,var3);用给定的变量名创建一个数组 二、数组的分段和填充 数组的分段array_slice($arr,0,3); 可以将数组中的一段取出，此函数忽略键名array_splice($arr,0,3，array(“black”,”maroon”)); 可以将数组中的一段取出，与上个函数不同在于返回的序列从原数组中删除 分割多个数组array_chunk($arr,3,TRUE); 可以将一个数组分割成多个，TRUE为保留原数组的键名 数组的填充array_pad($arr,5,’x’); 将一个数组填补到制定长度 三、数组与栈 array_push($arr,”apple”,”pear”); 将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数array_pop($arr); 将数组栈的最后一个元素弹出（出栈） 四、数组与列队 array_shift($arr);数组中的第一个元素移出并作为结果返回（数组长度减1，其他元素向前移动一位，数字键名改为从零技术，文字键名不变）array_unshift($arr,”a”,array(1,2));在数组的开头插入一个或多个元素 五、回调函数 array_walk($arr,’function’,’words’); 使用用户函数对数组中的每个成员进行处理（第三个参数传递给回调函数function）array_mpa(“function”,$arr1,$arr2); 可以处理多个数组（当使用两个或更多数组时，他们的长度应该相同）array_filter($arr,”function”); 使用回调函数过滤数组中的每个元素，如果回调函数为TRUE，数组的当前元素会被包含在返回的结果数组中，数组的键名保留不变array_reduce($arr,”function”,”“); 转化为单值函数（为数组的第一个值） 六、数组的排序 通过元素值对数组排序sort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序rsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序usort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）忽略键名的数组排序asort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序arsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序uasort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）保留键名的数组排序 通过键名对数组排序ksort($arr); 按照键名正序排序krsort($arr); 按照键名逆序排序uksort($arr,”function”); 使用用户自定义的比较函数对数组中的键名进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个） 自然排序法排序natsort($arr); 自然排序（忽略键名）natcasesort($arr); 自然排序（忽略大小写，忽略键名） 七、数组的计算 数组元素的求和array_sum($arr); 对数组内部的所有元素做求和运算 数组的合并array_merge($arr1,$arr2); 合并两个或多个数组（相同的字符串键名，后面的覆盖前面的，相同的数字键名，后面的不会做覆盖操作，而是附加到后面）“+”$arr1+$arr2; 对于相同的键名只保留后一个array_merge_recursive($arr1,$arr2); 递归合并操作，如果数组中有相同的字符串键名，这些值将被合并到一个数组中去。如果一个值本身是一个数组，将按照相应的键名把它合并为另一个数组。当数组 具有相同的数组键名时，后一个值将不会覆盖原来的值，而是附加到后面 数组的差集array_diff($arr1,$arr2); 返回差集结果数组array_diff_assoc($arr1,$arr2,$arr3); 返回差集结果数组，键名也做比较 数组的交集array_intersect($arr1,$arr2); 返回交集结果数组array_intersect_assoc($arr1,$arr2); 返回交集结果数组，键名也做比较 八、其他的数组函数 range(0,12); 创建一个包含指定范围单元的数组array_unique($arr); 移除数组中重复的值，新的数组中会保留原始的键名array_reverse($arr,TRUE); 返回一个单元顺序与原数组相反的数组，如果第二个参数为TRUE保留原来的键名//srand((float)microtime()*10000000); 随机种子触发器array_rand($arr,2); 从数组中随机取出一个或 多个元素shuffle($arr); 将数组的顺序打乱]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>基础函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用字符串函数]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[strlen($str);//返回字符串长度 mb_strlen($str) 可以返回中文字符长度 strtolower($str);//字母转小写 strtoupper($str);//字母转大写 ucwords($str);//每一个单词的首字母转大写 ucfirst($str);//首字母转大写 str_replace(‘a’,’b’,$str);//b替换$str 中的a 区分大小写 ; str_ireplace(‘a’,’b’,$str);//替换 不区分大小写 htmlspecialchars($str,ENT_NOQUOTES);//字符串转换为html 实体 ENT_COMPT(默认只编译双引号)ENT_QUOTES单引号双引号都编译,ENT_NOQUOTES不编译任何引号 trim($str);//删除字符串前后（左右）空格 ltrim($str);//只删除字符串左侧的空格 rtrim($str);//只删除字符串右侧的空格//trim加第二个参数 就是移除指定的字符集 如ltrim($str,’0..9’) 移除左侧数字开头的字符 strpos($str,’a’);//字符串a 在$str 第一次出现的位置 索引0开始 没有出现返回false 区分大小写 stripos($str,’a’);//同上 但是不区分大小写 strrpos($str,’a’);//字符串a 在$str 最后一次出现的位置 索引0开始 没有出现返回false 区分大小写 strripos($str,’a’);//同上 但是不区分大小写 substr($str,0,3);//截取字符串 $str 的第一个字符 截取长度3 长度不填默认截取到最后 参数为负数则倒数 strstr($str,’a’);//截取字符串 $str 中的第一个字符’a’后的字符串 如 sabc -&gt; abc strrchr($str,’a’);//截取字符串 $str 中最后一一个字符’a’后的字符串 strrev($str);//字符串反转 abcd-&gt;dcba md5($str);//字符串MD5加密 str_shuffle($str);//随机打乱字符串顺序 explode(‘-‘,$str);//指定分隔符分割字符串 返回数组 ‘-’ 分割$str implode(‘-‘,$str);//数组拼接字符串 与explode()相反]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>基础函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php拷贝机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号）php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
