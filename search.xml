<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php实现0-1背包问题]]></title>
    <url>%2F2019%2F03%2F29%2F1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&lt;? php function back(){ $a[&apos;w&apos;] = [0, 2, 3, 4, 5, 9]; $a[&apos;v&apos;] = [0, 3, 4, 5, 8, 10]; $b =array(); $n = 6; $w = 21; for($i=0;$i &lt; $n;$i++){ for($j=0;$j &lt; $w;$j++){ $b[$i][$j] = 0; } } for($k = 1; $k &lt; $n ;$k++){ for($c = 1; $c &lt; $w ;$c++){ if($a[&apos;w&apos;][$k] &gt; $c){ $b[$k][$c] = $b[$k-1][$c]; }else{ $value1 = $b[$k-1][$c-$a[&apos;w&apos;][$k]] + $a[&apos;v&apos;][$k]; // 拿第k件物品 $value2 = $b[$k-1][$c]; // 不拿第k件物品 $b[$k][$c] = max($value1,$value2); } } } print_r($b); } back(); JAVA实现 class Main { public static void main(String[] args) { int[] w = { 0, 2, 3, 4, 5, 9 }; int[] v = { 0, 3, 4, 5, 8, 10 }; int N = 6, W = 21; int[][] b = new int[N][W]; for (int k = 1; k &lt; N; k++) { for (int c = 1; c &lt; W; c++) { if (w[k] &gt; c) { b[k][c] = b[k - 1][c]; } else { int value1 = b[k - 1][c - w[k]] + v[k]; // 拿第k件物品 int value2 = b[k - 1][c]; // 不拿第k件物品 b[k][c] = Math.max(value1, value2); } } } System.out.println(b[5][20]); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入了解PHP闭包的使用以及实现]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3PHP%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/chenpingzhao/p/4553139.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划与贪心算法的区别与联系]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划的路径规划：https://blog.csdn.net/xgf415/article/details/52662389 0-1背包问题： https://www.jianshu.com/p/b86148c10142动态规划和贪心算法都是一种递推算法均有局部最优解来推导全局最优解背包问题可以由贪心算法求解，但是0-1背包问题不能而需要采取动态规划。 不同点： 贪心算法：1.贪心算法中，作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。2.由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。 贪心法的基本思路：从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的地求得更好的解。当达到某算法中的某一步不能再继续前进时，算法停止。该算法存在问题： 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。实现该算法的过程：从问题的某一初始解出发； while 能朝给定总目标前进一步 do求出可行解的一个解元素；由所有解元素组合成问题的一个可行解 贪心算法最经典的例子，给钱问题。比如中国的货币，只看元，有1元2元5元10元20、50、100 如果我要16元，可以拿16个1元，8个2元，但是怎么最少呢？如果用贪心算，就是我每一次拿那张可能拿的最大的。比如16，我第一次拿20拿不起，拿10元，OK，剩下6元，再拿个5元，剩下1元也就是3张 10、5、1。 每次拿能拿的最大的，就是贪心。 但是一定注意，贪心得到的并不是最优解，也就是说用贪心不一定是拿的最少的张数贪心只能得到一个比较好的解，而且贪心算法很好想得到。再注意，为什么我们的钱可以用贪心呢？因为我们国家的钱的大小设计，正好可以使得贪心算法算出来的是最优解（一般是个国家的钱币都应该这么设计）。如果设计成别的样子情况就不同了比如某国的钱币分为 1元3元4元如果要拿6元钱 怎么拿？贪心的话 先拿4 再拿两个1 一共3张钱实际最优呢？ 两张3元就够了 贪心算法两个最重要的性质：（1）贪心选择性质；（2）最优子结构性质； 其中，贪心选择性质：自顶向下进行决策，每次做出的决策都是局部最优解，且每次做出决策后问题规模都变小了；最优子结构性质：即问题的最优解结构中包含子问题的最优解； 动态规划算法的两个最重要的性质：（1）重叠子问题性质；（2）最优子结构性质； 其中最优解子结构性质和贪心算法相似，唯一不同的是重叠子问题性质，因为动态规划算法是自底向上的算法，它需要首先将原始问题分解为若干个相互有联系的子问题，在计算的时候有的子问题可能会被计算很多次，所以动态规划算法会将这些子问题的解存在一个表格中，使得最终对于这些子问题只需要求解一次（可以使原来需要再指数时间内解决的问题可以在多项式问题中得到解决）]]></content>
  </entry>
  <entry>
    <title><![CDATA[new]]></title>
    <url>%2F2019%2F03%2F29%2Fnew%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[前序与中序还原树]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E8%BF%98%E5%8E%9F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&lt;?php class TreeNode{ var $val; var $left = NULL; var $right = NULL; function __construct($val){ $this-&gt;val = $val; } } function reConstructBinaryTree($pre, $vin) { // write code here if($pre &amp;&amp; $vin){ //前序遍历的第一个节点一定是根节点 $treeRoot = new TreeNode($pre[0]); //index判断根节点在中序中是否存在,并返回根节点在vin中的键名 $index = array_search($pre[0],$vin); $treeRoot-&gt;left=reConstructBinaryTree(array_slice($pre,1,$index),array_slice($vin,0,$index)); $treeRoot-&gt;right = reConstructBinaryTree(array_slice($pre,$index+1),array_slice($vin,$index+1)); return $treeRoot; } } $pre = [1,2,4,7,3,5,6,8]; $vin = [4,7,2,1,5,3,8,6]; $re = reConstructBinaryTree($pre, $vin);]]></content>
  </entry>
  <entry>
    <title><![CDATA[前序遍历与中序遍历与后续遍历的php实现]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[&lt;?php class Node{ public $value; public $left; public $right; } //先序遍历 根节点 ---&gt; 左子树 ---&gt; 右子树 function preorder($root){ $stack=array(); array_push($stack,$root); while(!empty($stack)){ $center_node=array_pop($stack); echo $center_node-&gt;value.&apos; &apos;;//先输出根节点 if($center_node-&gt;right!=null){ array_push($stack,$center_node-&gt;right);//压入左子树 } if($center_node-&gt;left!=null){ array_push($stack,$center_node-&gt;left); } } } //中序遍历，左子树---&gt; 根节点 ---&gt; 右子树 function inorder($root){ $stack = array(); $center_node = $root; while (!empty($stack) || $center_node != null) { while ($center_node != null) { array_push($stack, $center_node); $center_node = $center_node-&gt;left; } $center_node = array_pop($stack); echo $center_node-&gt;value . &quot; &quot;; $center_node = $center_node-&gt;right; } } //后序遍历，左子树 ---&gt; 右子树 ---&gt; 根节点 function tailorder($root){ $stack=array(); $outstack=array(); array_push($stack,$root); while(!empty($stack)){ $center_node=array_pop($stack); array_push($outstack,$center_node);//最先压入根节点，最后输出 if($center_node-&gt;left!=null){ array_push($stack,$center_node-&gt;left); } if($center_node-&gt;right!=null){ array_push($stack,$center_node-&gt;right); } } while(!empty($outstack)){ $center_node=array_pop($outstack); echo $center_node-&gt;value.&apos; &apos;; } } $a=new Node(); $b=new Node(); $c=new Node(); $d=new Node(); $e=new Node(); $f=new Node(); $a-&gt;value=&apos;A&apos;; $b-&gt;value=&apos;B&apos;; $c-&gt;value=&apos;C&apos;; $d-&gt;value=&apos;D&apos;; $e-&gt;value=&apos;E&apos;; $f-&gt;value=&apos;F&apos;; $a-&gt;left=$b; $a-&gt;right=$c; $b-&gt;left=$d; $c-&gt;left=$e; $c-&gt;right=$f; preorder($a);//A B D C E F echo &apos;&lt;hr/&gt;&apos;; inorder($a);//D B A E C F echo &apos;&lt;hr/&gt;&apos;; tailorder($a);//D B E F C A]]></content>
  </entry>
  <entry>
    <title><![CDATA[php十进制二进制算法题]]></title>
    <url>%2F2019%2F03%2F28%2Fhp%E5%8D%81%E8%BF%9B%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[负数需要先置反为反码，然后再加1，并且循环需要32位 floor()舍去法取整 ceil – 进一法取整 round – 对浮点数进行四舍五入 %取余数 array_count_values()表示$v出现次数 &lt;?php function NumberOf1($n){ $arr = array(); if ($n &gt; 0){ while($n != 0) { $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); } $judge = array_count_values($arr); if(isset($judge[1])){ return $judge[1]; }else{ return 0; } }else{ $n = -1 * $n; while($n &gt; 0){ $temp = $n % 2; $n = floor($n/2); array_push($arr,$temp); } for($i=0;$i &lt; 32;$i++){ if($arr[$i] == 1){ $arr[$i] = 0; }elseif($arr[$i] == 0) { $arr[$i] = 1; }else{ $arr[$i] = 1; } } $length = count($arr); for($i = 0;$i &lt; $length;$i++){ if($arr[$i]==0){ $arr[$i] = 1; break; }else{ $arr[$i] = 0; } } $judge = array_count_values($arr); if(isset($judge[1])){ return $judge[1]; }else{ return 0; } } } ?&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里一面凉经]]></title>
    <url>%2F2019%2F03%2F27%2F%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[阿里面试问题1自我介绍2mysql索引3http三次握手四次挥手4session共享？5贪心算法和背包算法的区别联系？6session与cookie的联系区别7get和post的区别8get几次请求9linux 查询文件夹下的一个文件 查询某一端口没有问排序与查找、http状态码、redis、树、复杂度]]></content>
  </entry>
  <entry>
    <title><![CDATA[php多线程]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展，而要安装 pthread 扩展，必须使用 –enable-maintainer-zts 参数重新编译 PHP，这个参数是指定编译 PHP 时使用线程安全方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[查找总结]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析： 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ; 当查找不成功时，需要n+1次比较，时间复杂度为O(n); 所以，顺序查找的时间复杂度为O(n)。 二分查找 说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)； 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》 /二分查找（折半查找），版本1 int BinarySearch1(int a[], int value, int n) { int low, high, mid; low = 0; high = n-1; while(low&lt;=high) { mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; } return -1; } //二分查找，递归版本 int BinarySearch2(int a[], int value, int low, int high) { int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high); } 插值查找 在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？ 打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。 同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。 经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下： mid=(low+high)/2, 即mid=low+1/2(high-low); 通过类比，我们可以将查找的点改进为如下： mid=low+(key-a[low])/(a[high]-a[low])(high-low)， 也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。 C++实现源码：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2019%2F03%2F27%2Fp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[http协议的状态码 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误）Internal Server Error服务器遇到错误，无法完成请求。 501（尚未实施）Not Implemented服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）Bad Gateway服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）Service Unavailable服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时）Gateway Timeout服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）HTTP Version Not Supported服务器不支持请求中所用的 HTTP 协议版本。1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续）continue请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议）switch protocols请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx（成功）表示成功处理了请求的状态码。 200（成功）OK服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。201（已创建）Created请求成功并且服务器创建了新的资源。 202（已接受）Accepted服务器已接受请求，但尚未处理。 203（非授权信息）Non-Authoriative Information服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）No Content服务器成功处理了请求，但没有返回任何内容。 205（重置内容）Reset Content服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容）Partial Content服务器成功处理了部分 GET 请求。 3xx（重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google建议您在每次请求中使用重定向不要超过5次。您可以使用网站管理员工具查看一下 Googlebot在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 300（多种选择）Multiple Choices针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）Moved Permanently请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置）see other请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改）Not Modified自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。. 305（使用代理）Use Proxy请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）Temporary Redirect服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）Bad Request服务器不理解请求的语法。 401（未授权）Unauthorized请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）Forbidden服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）File Not Found服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用）Method Not Allowed禁用请求中指定的方法。 406（不接受）Not Acceptable无法使用请求的内容特性响应请求的网页。 407（需要代理授权）Proxy Authentication Required此状态码与 401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时）Request Time-out服务器等候请求时发生超时。 409（冲突）conflict服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除）Gone如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度）Length Required服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）Precondition Failed服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）Request Entity Too Large服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）Request-URL Too Large请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）Unsupported Media Type请求的格式不受请求页面的支持。 416（请求范围不符合要求）Requested range not statifiable如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值）Expectation Failed服务器未满足”期望”请求标头字段的要求。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET与POST区别]]></title>
    <url>%2F2019%2F03%2F27%2FET%E4%B8%8EPOST%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[get post本质：HTTP协议里两种发送请求的方法get向服务器请求资源post 向服务器发送请求 通常情况参数的传送渠道的不同get放在url里面 post放在body里面get请求url有限制（字符串） post没有限制但是http其实没明确规定什么get/post方法要用什么样的方式传输数据 get产生一个TCP数据包 而post产生两个：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。因为POST需要两步，时间上消耗的要多一点，但是在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F03%2F26%2Ftitled%2F</url>
    <content type="text"><![CDATA[&lt;?php //送给心爱的她5201314 $arr = array(&apos;5&apos;,&apos;2&apos;,&apos;0&apos;,&apos;1&apos;,&apos;3&apos;,&apos;1&apos;,&apos;4&apos;); function BubbleSort(array $arr) { for ($i=0 ; $i &lt;count($arr) ; $i++) { //设置一个空变量 $data = &apos;&apos;; for ($j=$i ; $j &lt; count($arr)-1 ; $j++) { if ($arr[$i] &gt; $arr[$j+1]) { $data = $arr[$i]; $arr[$i] = $arr[$j+1]; $arr[$j+1] = $data; } } } return $arr; } echo &quot;&lt;pre&gt;&quot;; print_r(BubbleSort($arr));]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&lt;?php $arr = [2, 3, 1, 6, 4, 7, 5, 9]; var_dump(insertsort($arr)); function insertSort($arr) { $len = count($arr); for ($i = 1; $i &lt; $len; $i++) { // 当前值 $key = $arr[$i]; // 当前位置 $pos = $i; // 如是当前位置 &gt;0 &amp;&amp; 当前值的前一个值 &gt; 当前值 选出最值 while ($pos &gt; 0 &amp;&amp; $arr[$pos - 1] &gt; $key) { // 当前值 = 前一个值 $arr[$pos] = $arr[$pos - 1]; // 当前位置后移 $pos = $pos - 1; } // 找到当前值的位置 $arr[$pos] = $key; } return $arr; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F03%2F26%2F%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&lt;?php //快速排序 //待排序数组 $arr=array(6,3,8,6,4,2,9,5,1); //函数实现快速排序 function quick_sort($arr) { //递归出口:数组长度为1，直接返回数组 $length=count($arr); if($length&lt;=1) return $arr; $left=$right=array(); for($i=1;$i&lt;$length;$i++){ if($arr[$i]&lt;$arr[0]){ //第一次排序，left为小于6的所有数 $left[] = $arr[$i]; }else{ //right为大于6的所有数 $right[] = $arr[$i]; } } $left = quick_sort($left); $right = quick_sort($right); return array_merge($left,array($arr[0]),$right); } //调用 echo &quot;&lt;pre&gt;&quot;; print_r(quick_sort($arr));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双栈实现队列]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[&lt;?php $pushV = [1,2,3,4,5]; $popV = [4,5,3,2,1]; function IsPopOrder($pushV, $popV) { // $stack = new SplStack(); $stack = []; $len = count($pushV); $j = 0; for($i=0;$i&lt;$len;$i++){ array_push($stack,$pushV[$i]); while($j&lt;$len &amp;&amp; $popV[$j]==end($stack)){ array_pop($stack); $j++; } } if($stack){ return false; }else { return true; } } echo IsPopOrder($pushV, $popV);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法时间复杂度空间复杂度]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[注：1、归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，2、快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念：1、时间复杂度 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2) 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),2、空间复杂度 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1) 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ax=N，则x=logaN， 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环队列叫号问题]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%A2%98-1%2F</url>
    <content type="text"><![CDATA[有m个猴子，按顺时针方向围成一个圈选大王。从第1号开始报数1，2，……，数到n号时该猴子退出到圈外，如此报数直到圈内只剩下一个猴子时，此猴子便是大王。由键盘输入m，n，打印出猴子大王序号。输入 10 3输出 4 &lt;?php echo monkey(4,1);//5 function monkey($m,$n){ //定义arr猴子数组， $arr=range(1,$m); $i=0; while(count($arr)&gt;1){ //出队 if(($i+1)%$n==0){ //如果猴子序号/猴王号n余数为0，踢走 unset($arr[$i]); }else{ //否则将该序号放在猴子数组队尾 $arr[]=$arr[$i]; unset($arr[$i]); } echo $i.&quot;\n&quot;; $i++; } //最后key i所对应的就是猴王 return $arr[$i]; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务、事务隔离、锁机制]]></title>
    <url>%2F2019%2F03%2F25%2Fmysql%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、什么是事务事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。Atomicity原子性：要不全部成功，要不全部撤销Isolation隔离性：事务之间相互独立，互不干扰Consistency一致性：数据库正确地改变状态后，数据库的一致性约束没有被破坏Durability持久性：事务的提交结果，将持久保存在数据库中 pass：不可重复读与幻读的本质区别不可重复读是读取了其他事务更改的数据，针对update操作解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。passpass:脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 幻读的重点在于新增或者删除. 脏读：数据读错方只读了一次数据库。不可重复读：数据读错方读了两次数据库 幻读是读取了其他事务新增的数据，针对insert操作解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。 2、事务并发会产生什么问题1）第一类丢失更新：在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。例如： 张三的工资为5000，事务A中获取工资为5000，事务B获取工资为5000，汇入100，并提交数据库，工资变为5100， 随后事务A发生异常，回滚了，恢复张三的工资为5000，这样就导致事务B的更新丢失了。2）脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。例如： 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。 与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。 随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。 最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。 3）不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如： 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。 与此同时，事务B把张三的工资改为8000，并提交了事务。 随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 4）第二类丢失更新：不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。例如： 在事务A中，读取到张三的存款为5000，操作没有完成，事务还没提交。 与此同时，事务B，存储1000，把张三的存款改为6000，并提交了事务。 随后，在事务A中，存储500，把张三的存款改为5500，并提交了事务，这样事务A的更新覆盖了事务B的更新。5）幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如： 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。 此时，事务B插入一条工资也为5000的记录。 这时，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 提醒：不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样 3、事务隔离级别，解决什么并发问题，以及存在什么并发问题（1）READ_UNCOMMITTED（读未提交） 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。 解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。（2）READ_COMMITTED（读已提交） 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。 解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题（3）REPEATABLE_READ（重复读） 保证一个事务相同条件下前后两次获取的数据是一致的 解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。（4）SERIALIZABLE（串行化） 事务被处理为顺序执行。 解决所有问题提醒：Mysql默认的事务隔离级别为repeatable_read 4、InnoDB引擎的锁机制（之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁）共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。说明： 1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。共享锁（S）：SELECT FROM table_name WHERE … LOCK IN SHARE MODE。排他锁（X)：SELECT FROM table_name WHERE … FOR UPDATE。3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php垃圾回收机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/u011957758/article/details/76864400 refcount：多少个变量是一样的用了相同的值，这个数值就是多少。is_ref：bool类型，当refcount大于2的时候，其中一个变量用了地址&amp;的形式进行赋值，好了，它就变成1了。 unset并非一定会释放内存，当有两个变量指向的时候，并非会释放变量占用的内存，只是refcount减1. 如果unset（$a） 如果在小于php5.3的版本就会出现一个问题：$a已经不在符号表了，没有变量再指向此zval容器，用户已无法访问，但是由于数组的refcount变为1而不是0，导致此部分内存不能被回收从而产生了内存泄漏。 5.3之后版本处理垃圾判断处理过程1.如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾2.如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾3.如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾 白话文版：就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾 A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。 B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。 C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性） D：遍历zval节点，将C中标记成白色的节点zval释放掉。 &lt;?php $a = [&apos;one&apos;]; --- zval_a（将$a对应的zval，命名为zval_a） $a[] = &amp;$a; --- step1 unset($a); --- step2 为进行unset之前(step1)，进行算法计算，对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样说明zval_a不是一个垃圾不进行回收。 当执行unset的时候(step2)，进行算法计算，由于环形引用，上文得出会有垃圾的结构体，zval_a的refcount是1(zval_a中的索引1指向zval_a)，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就认为zval_a是一个需要回收的垃圾。 算法总的套路:对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。 unsetunset只是断开一个变量到一块内存区域的连接，同时将该内存区域的引用计数-1；内存是否回收主要还是看refount是否到0了，以及gc算法判断。 = null 操作；a=null是直接将a 指向的数据结构置空，同时将其引用计数归0。 脚本执行结束脚本执行结束，该脚本中使用的所有内存都会被释放，不论是否有引用环。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用数组操作]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、数组操作的基本函数 数组的键名和值array_values($arr); 获得数组的值array_keys($arr); 获得数组的键名array_flip($arr); 数组中的值与键名互换（如果有重复前面的会被后面的覆盖）in_array(“apple”,$arr); 在数组中检索applearray_search(“apple”,$arr); 在数组中检索apple ，如果存在返回键名array_key_exists(“apple”,$arr); 检索给定的键名是否存在数组中isset($arr[apple]): 检索给定的键名是否存在数组中 数组的内部指针current($arr); 返回数组中的当前单元pos($arr); 返回数组中的当前单元key($arr); 返回数组中当前单元的键名prev($arr); 将数组中的内部指针倒回一位next($arr); 将数组中的内部指针向前移动一位end($arr); 将数组中的内部指针指向最后一个单元reset($arr; 将数组中的内部指针指向第一个单元each($arr); 将返回数组当前元素的一个键名/值的构造数组，并使数组指针向前移动一位list($key,$value)=each($arr); 获得数组当前元素的键名和值 数组和变量之间的转换extract($arr);用于把数组中的元素转换成变量导入到当前文件中，键名当作变量名，值作为变量值注：（第二个参数很重要，可以看手册使用）使用方法 echo $a;compact(var1,var2,var3);用给定的变量名创建一个数组 二、数组的分段和填充 数组的分段array_slice($arr,0,3); 可以将数组中的一段取出，此函数忽略键名array_splice($arr,0,3，array(“black”,”maroon”)); 可以将数组中的一段取出，与上个函数不同在于返回的序列从原数组中删除 分割多个数组array_chunk($arr,3,TRUE); 可以将一个数组分割成多个，TRUE为保留原数组的键名 数组的填充array_pad($arr,5,’x’); 将一个数组填补到制定长度 三、数组与栈 array_push($arr,”apple”,”pear”); 将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数array_pop($arr); 将数组栈的最后一个元素弹出（出栈） 四、数组与列队 array_shift($arr);数组中的第一个元素移出并作为结果返回（数组长度减1，其他元素向前移动一位，数字键名改为从零技术，文字键名不变）array_unshift($arr,”a”,array(1,2));在数组的开头插入一个或多个元素 五、回调函数 array_walk($arr,’function’,’words’); 使用用户函数对数组中的每个成员进行处理（第三个参数传递给回调函数function）array_mpa(“function”,$arr1,$arr2); 可以处理多个数组（当使用两个或更多数组时，他们的长度应该相同）array_filter($arr,”function”); 使用回调函数过滤数组中的每个元素，如果回调函数为TRUE，数组的当前元素会被包含在返回的结果数组中，数组的键名保留不变array_reduce($arr,”function”,”“); 转化为单值函数（为数组的第一个值） 六、数组的排序 通过元素值对数组排序sort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序rsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）忽略键名的数组排序usort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）忽略键名的数组排序asort($arr); 由小到大的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序arsort($arr); 由大到小的顺序排序（第二个参数为按什么方式排序）保留键名的数组排序uasort($arr,”function”); 使用用户自定义的比较函数对数组中的值进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个）保留键名的数组排序 通过键名对数组排序ksort($arr); 按照键名正序排序krsort($arr); 按照键名逆序排序uksort($arr,”function”); 使用用户自定义的比较函数对数组中的键名进行排序（function中有两个参数，0表示相等，正数表示第一个大于第二个，负数表示第一个小于第二个） 自然排序法排序natsort($arr); 自然排序（忽略键名）natcasesort($arr); 自然排序（忽略大小写，忽略键名） 七、数组的计算 数组元素的求和array_sum($arr); 对数组内部的所有元素做求和运算 数组的合并array_merge($arr1,$arr2); 合并两个或多个数组（相同的字符串键名，后面的覆盖前面的，相同的数字键名，后面的不会做覆盖操作，而是附加到后面）“+”$arr1+$arr2; 对于相同的键名只保留后一个array_merge_recursive($arr1,$arr2); 递归合并操作，如果数组中有相同的字符串键名，这些值将被合并到一个数组中去。如果一个值本身是一个数组，将按照相应的键名把它合并为另一个数组。当数组 具有相同的数组键名时，后一个值将不会覆盖原来的值，而是附加到后面 数组的差集array_diff($arr1,$arr2); 返回差集结果数组array_diff_assoc($arr1,$arr2,$arr3); 返回差集结果数组，键名也做比较 数组的交集array_intersect($arr1,$arr2); 返回交集结果数组array_intersect_assoc($arr1,$arr2); 返回交集结果数组，键名也做比较 八、其他的数组函数 range(0,12); 创建一个包含指定范围单元的数组array_unique($arr); 移除数组中重复的值，新的数组中会保留原始的键名array_reverse($arr,TRUE); 返回一个单元顺序与原数组相反的数组，如果第二个参数为TRUE保留原来的键名//srand((float)microtime()*10000000); 随机种子触发器array_rand($arr,2); 从数组中随机取出一个或 多个元素shuffle($arr); 将数组的顺序打乱]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常用字符串函数]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[strlen($str);//返回字符串长度 mb_strlen($str) 可以返回中文字符长度 strtolower($str);//字母转小写 strtoupper($str);//字母转大写 ucwords($str);//每一个单词的首字母转大写 ucfirst($str);//首字母转大写 str_replace(‘a’,’b’,$str);//b替换$str 中的a 区分大小写 ; str_ireplace(‘a’,’b’,$str);//替换 不区分大小写 htmlspecialchars($str,ENT_NOQUOTES);//字符串转换为html 实体 ENT_COMPT(默认只编译双引号)ENT_QUOTES单引号双引号都编译,ENT_NOQUOTES不编译任何引号 trim($str);//删除字符串前后（左右）空格 ltrim($str);//只删除字符串左侧的空格 rtrim($str);//只删除字符串右侧的空格//trim加第二个参数 就是移除指定的字符集 如ltrim($str,’0..9’) 移除左侧数字开头的字符 strpos($str,’a’);//字符串a 在$str 第一次出现的位置 索引0开始 没有出现返回false 区分大小写 stripos($str,’a’);//同上 但是不区分大小写 strrpos($str,’a’);//字符串a 在$str 最后一次出现的位置 索引0开始 没有出现返回false 区分大小写 strripos($str,’a’);//同上 但是不区分大小写 substr($str,0,3);//截取字符串 $str 的第一个字符 截取长度3 长度不填默认截取到最后 参数为负数则倒数 strstr($str,’a’);//截取字符串 $str 中的第一个字符’a’后的字符串 如 sabc -&gt; abc strrchr($str,’a’);//截取字符串 $str 中最后一一个字符’a’后的字符串 strrev($str);//字符串反转 abcd-&gt;dcba md5($str);//字符串MD5加密 str_shuffle($str);//随机打乱字符串顺序 explode(‘-‘,$str);//指定分隔符分割字符串 返回数组 ‘-’ 分割$str implode(‘-‘,$str);//数组拼接字符串 与explode()相反]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php拷贝机制]]></title>
    <url>%2F2019%2F03%2F24%2Fphp%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号）php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引总结]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[mysql索引总结索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。如果我们把SQL语句换成“SELECT * FROM article WHERE id=2000000”，那么你是希望数据库按照顺序读取完200万行数据以后给你结果还是直接在索引中定位呢？上面的两个图片鲜明的用时对比已经给出了答案（注：一般数据库默认都会为主键生成索引）。索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。 普通索引这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。 唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。 全文索引（FULLTEXT）MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。 单列索引、多列索引多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：–title,time–title]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
